<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mat Harvey ‚Äî Portfolio World</title>
    <style>
        :root{--hud:rgba(10,18,12,.72);--hb:rgba(120,180,100,.22);--t:#e8f0e4;--s:#9ab892;--a:#6ec86e;--a2:#f0c060;--w:#5cc0b8}
        *{margin:0;padding:0;box-sizing:border-box}html,body{width:100%;height:100%;overflow:hidden;font-family:"Segoe UI",system-ui,sans-serif;color:var(--t);background:#1a2818}
        #app{width:100%;height:100%;position:relative}canvas{display:block;width:100%;height:100%}
        #loading{position:fixed;inset:0;background:linear-gradient(135deg,#1a2818,#0e180c);display:flex;align-items:center;justify-content:center;z-index:999;transition:opacity .8s}
        #loading h1{font-size:2rem;color:#8fcc6a;letter-spacing:.14em;text-transform:uppercase;font-weight:700}#loading p{margin-top:10px;color:#6a9a5c;font-size:.95rem}
        .panel{position:absolute;backdrop-filter:blur(10px);border:1px solid var(--hb);background:var(--hud);border-radius:12px;box-shadow:0 12px 28px rgba(0,0,0,.3)}
        .hud{top:14px;left:14px;width:min(360px,calc(100vw - 28px));padding:12px 14px;display:grid;gap:6px}.hud-title{font-size:.8rem;text-transform:uppercase;letter-spacing:.1em;color:var(--a);font-weight:700}
        .hud-row{display:flex;justify-content:space-between;gap:12px;font-size:.86rem}.hud-row .v{color:var(--a2);font-weight:600;text-align:right}.hint{color:var(--s);font-size:.76rem;line-height:1.4}
        .side-panel{top:14px;right:14px;width:min(300px,calc(100vw - 28px));padding:12px;display:grid;gap:7px;max-height:50vh;overflow-y:auto}
        .section-label{font-size:.72rem;text-transform:uppercase;letter-spacing:.08em;color:var(--s)}
        .badge{display:flex;align-items:center;gap:8px;font-size:.74rem;border:1px solid rgba(110,200,110,.12);border-radius:10px;color:var(--s);background:rgba(255,255,255,.02);padding:7px 10px;transition:all .25s;opacity:.45}
        .badge.on{color:#d4ffd4;border-color:rgba(110,200,110,.4);background:rgba(110,200,110,.08);opacity:1}
        .badge .badge-icon{font-size:1.3rem;flex-shrink:0;filter:grayscale(1);transition:filter .3s}
        .badge.on .badge-icon{filter:grayscale(0)}
        .badge .badge-info{display:flex;flex-direction:column;gap:1px}
        .badge .badge-title{font-weight:600;font-size:.76rem}
        .badge .badge-desc{font-size:.64rem;color:var(--s);opacity:.7}
        .badge.on .badge-desc{opacity:1}
        /* Steam-style achievement popup */
        .ach-popup{position:fixed;bottom:24px;right:24px;display:flex;align-items:center;gap:14px;padding:14px 20px 14px 16px;border-radius:12px;background:linear-gradient(135deg,rgba(20,30,18,.97),rgba(12,20,10,.98));border:1.5px solid rgba(110,200,110,.35);box-shadow:0 8px 32px rgba(0,0,0,.5),0 0 20px rgba(110,200,110,.08);z-index:58;transform:translateX(120%);transition:transform .45s cubic-bezier(.22,1,.36,1);max-width:340px}
        .ach-popup.show{transform:translateX(0)}
        .ach-popup .ach-icon{font-size:2.2rem;flex-shrink:0;animation:achBounce .5s ease-out}
        .ach-popup .ach-body{display:flex;flex-direction:column;gap:3px}
        .ach-popup .ach-label{font-size:.65rem;text-transform:uppercase;letter-spacing:.08em;color:var(--a);font-weight:600}
        .ach-popup .ach-name{font-size:.95rem;font-weight:700;color:#e0f0dc}
        .ach-popup .ach-desc{font-size:.72rem;color:var(--s)}
        .ach-popup .ach-bar{height:3px;border-radius:2px;background:rgba(110,200,110,.15);margin-top:6px;overflow:hidden}
        .ach-popup .ach-bar-fill{height:100%;width:0;background:var(--a);border-radius:2px;transition:width 3.5s linear}
        @keyframes achBounce{0%{transform:scale(0) rotate(-20deg)}50%{transform:scale(1.25) rotate(5deg)}100%{transform:scale(1) rotate(0)}}
        .prompt{position:absolute;left:50%;bottom:18px;transform:translateX(-50%);min-width:min(440px,calc(100vw - 32px));text-align:center;padding:10px 14px;font-size:.86rem;border:1px solid rgba(110,200,110,.4);background:rgba(14,22,14,.88);border-radius:12px;opacity:0;pointer-events:none;transition:opacity .2s}.prompt.show{opacity:1}
        .toast{position:absolute;left:50%;top:78px;transform:translateX(-50%) translateY(-16px);border:1px solid rgba(110,200,110,.4);background:rgba(10,24,16,.92);color:#b8ffd0;border-radius:12px;padding:9px 14px;font-size:.82rem;opacity:0;pointer-events:none;transition:all .2s}.toast.show{opacity:1;transform:translateX(-50%) translateY(0)}
        .links{position:absolute;left:14px;bottom:14px;display:flex;gap:8px}
        .btn{display:inline-flex;align-items:center;font-size:.76rem;color:#c8dcc4;border:1px solid rgba(200,220,196,.28);border-radius:8px;padding:6px 10px;text-decoration:none;background:rgba(14,22,14,.65);cursor:pointer}.btn:hover{border-color:var(--a);color:#fff}
        .dt{display:inline-block;font-size:.64rem;padding:2px 5px;border-radius:4px;margin-left:5px;font-weight:600}
        .dt-port{background:rgba(92,192,184,.15);color:var(--w)}.dt-sim{background:rgba(120,140,220,.15);color:#8898dd}.dt-tool{background:rgba(220,180,80,.15);color:var(--a2)}.dt-per{background:rgba(200,100,140,.15);color:#dd88aa}
        .dialog-overlay{position:fixed;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:50;opacity:0;pointer-events:none;transition:opacity .25s}
        .dialog-overlay.show{opacity:1;pointer-events:auto}
        .dialog-box{width:min(520px,calc(100vw - 32px));background:linear-gradient(180deg,#e8d5a8,#d4be8a);border:3px solid #8b6914;border-radius:6px;padding:28px 32px 22px;box-shadow:0 16px 48px rgba(0,0,0,.5),inset 0 0 40px rgba(139,105,20,.1);position:relative;font-family:Georgia,"Times New Roman",serif;color:#3a2a10}
        .dialog-box::before{content:"";position:absolute;inset:6px;border:1px solid rgba(139,105,20,.25);border-radius:3px;pointer-events:none}
        .dialog-npc{font-size:.72rem;text-transform:uppercase;letter-spacing:.14em;color:#8b6914;margin-bottom:6px;font-weight:700}
        .dialog-title{font-size:1.35rem;font-weight:700;color:#2a1a05;margin-bottom:10px;border-bottom:1px solid rgba(139,105,20,.3);padding-bottom:8px}
        .dialog-text{font-size:1.02rem;color:#4a3618;line-height:1.6;margin-bottom:14px;white-space:pre-line}
        .dialog-progress{font-size:.92rem;color:#6b4e1e;margin-bottom:10px;font-style:italic}
        .dialog-btns{display:flex;gap:10px;justify-content:flex-end}
        .dialog-btn{padding:8px 20px;border:2px solid #8b6914;border-radius:4px;background:linear-gradient(180deg,#d4be8a,#c0a870);color:#3a2a10;font-size:.86rem;cursor:pointer;transition:all .15s;font-family:Georgia,serif;font-weight:600}
        .dialog-btn:hover{background:linear-gradient(180deg,#e8d5a8,#d4be8a);box-shadow:0 2px 8px rgba(139,105,20,.3)}
        .dialog-btn.primary{background:linear-gradient(180deg,#c8a030,#a08020);color:#fff;border-color:#7a5a10}
        .dialog-btn.primary:hover{background:linear-gradient(180deg,#d8b040,#b89030)}
        .garage-overlay{position:fixed;inset:0;background:rgba(0,0,0,.75);backdrop-filter:blur(6px);display:flex;align-items:center;justify-content:center;z-index:55;opacity:0;pointer-events:none;transition:opacity .35s}
        .garage-overlay.show{opacity:1;pointer-events:auto}
        .garage-modal{background:linear-gradient(160deg,rgba(14,26,12,.97),rgba(8,18,6,.98));border:1.5px solid rgba(110,200,110,.25);border-radius:20px;padding:32px 40px 28px;max-width:600px;width:92vw;box-shadow:0 20px 60px rgba(0,0,0,.6),0 0 40px rgba(110,200,110,.06);position:relative}
        .garage-close{position:absolute;top:14px;right:18px;background:none;border:none;color:#8a9a80;font-size:1.4rem;cursor:pointer;transition:color .2s;line-height:1}
        .garage-close:hover{color:#fff}
        .garage-header{text-align:center;margin-bottom:18px}
        .garage-title{font-family:Georgia,serif;font-size:1.6rem;font-weight:700;color:#ffd700;letter-spacing:.08em;text-transform:uppercase;text-shadow:0 0 18px rgba(255,215,0,.25)}
        .garage-subtitle{font-size:.8rem;color:#8a9a80;margin-top:4px;letter-spacing:.04em}
        .garage-carousel{display:flex;align-items:center;gap:14px}
        .garage-nav{width:44px;height:44px;border-radius:50%;border:2px solid rgba(110,200,110,.35);background:rgba(14,24,12,.85);color:var(--a);font-size:1.4rem;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .2s;flex-shrink:0}
        .garage-nav:hover{background:rgba(110,200,110,.18);border-color:var(--a);transform:scale(1.08)}
        .garage-stage{flex:1;display:flex;flex-direction:column;align-items:center}
        .garage-preview{width:100%;aspect-ratio:16/10;border-radius:14px;overflow:hidden;background:radial-gradient(ellipse at 50% 60%,rgba(30,50,25,.85),rgba(8,16,6,.98));border:1.5px solid rgba(110,200,110,.18);box-shadow:inset 0 -40px 50px -30px rgba(110,200,110,.04);position:relative}
        .garage-preview canvas{width:100%;height:100%;display:block}
        .garage-preview .locked-overlay{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(0,0,0,.55);font-size:2.4rem}
        .garage-preview .locked-text{font-size:.82rem;color:#776;margin-top:8px}
        .garage-info{margin-top:14px;text-align:center}
        .garage-car-name{font-family:Georgia,serif;font-size:1.3rem;font-weight:700;color:#e0f0dc;margin-bottom:3px}
        .garage-car-desc{font-size:.82rem;color:var(--s);max-width:380px}
        .garage-car-badge{display:inline-block;margin-top:8px;padding:3px 12px;border-radius:6px;font-size:.72rem;font-weight:700;letter-spacing:.06em;text-transform:uppercase}
        .garage-car-badge.current{background:rgba(110,200,110,.15);color:var(--a);border:1px solid rgba(110,200,110,.35)}
        .garage-car-badge.available{background:rgba(255,215,0,.12);color:#ffd700;border:1px solid rgba(255,215,0,.3)}
        .garage-car-badge.locked{background:rgba(80,80,60,.15);color:#665;border:1px solid rgba(80,80,60,.3)}
        .garage-select-btn{margin-top:14px;padding:10px 36px;border:2px solid rgba(110,200,110,.5);border-radius:10px;background:rgba(110,200,110,.1);color:var(--a);font-size:.95rem;font-weight:600;cursor:pointer;transition:all .2s;letter-spacing:.04em}
        .garage-select-btn:hover{background:rgba(110,200,110,.22);border-color:var(--a);box-shadow:0 0 14px rgba(110,200,110,.12)}
        .garage-select-btn:disabled{opacity:.35;cursor:default;box-shadow:none}
        .garage-dots{display:flex;gap:8px;margin-top:16px}
        .garage-dot{width:10px;height:10px;border-radius:50%;background:rgba(110,200,110,.18);border:1px solid rgba(110,200,110,.3);cursor:pointer;transition:all .2s}
        .garage-dot.active{background:var(--a);box-shadow:0 0 8px rgba(110,200,110,.4);transform:scale(1.15)}
        .garage-dot.locked{background:rgba(80,80,60,.25);border-color:rgba(80,80,60,.35)}
        .garage-counter{font-size:.72rem;color:#8a9a80;margin-top:8px;letter-spacing:.04em}
        .garage-hint{position:absolute;bottom:14px;left:0;right:0;text-align:center;font-size:.7rem;color:#666;letter-spacing:.03em}
        .mode-badge{position:absolute;top:14px;left:50%;transform:translateX(-50%);padding:5px 14px;border-radius:8px;font-size:.74rem;font-weight:600;letter-spacing:.08em;text-transform:uppercase;opacity:0;pointer-events:none;transition:opacity .3s;z-index:20}
        .mode-badge.show{opacity:1}
        .mode-badge.walk{background:rgba(110,200,110,.15);border:1px solid rgba(110,200,110,.4);color:var(--a)}
        .mode-badge.dialog{background:rgba(240,192,96,.15);border:1px solid rgba(240,192,96,.4);color:var(--a2)}
        .quest-tracker{position:absolute;bottom:60px;right:14px;width:min(300px,calc(100vw - 28px));padding:16px 18px 14px;border-radius:6px;border:2px solid #8b6914;background:linear-gradient(180deg,rgba(232,213,168,.94),rgba(212,190,138,.96));backdrop-filter:blur(6px);box-shadow:0 4px 16px rgba(0,0,0,.25);opacity:0;pointer-events:none;transition:opacity .3s;font-family:Georgia,serif;color:#3a2a10}
        .quest-tracker.show{opacity:1}
        .quest-tracker .qt{font-size:1rem;font-weight:700;color:#2a1a05;margin-bottom:8px;border-bottom:1px solid rgba(139,105,20,.25);padding-bottom:6px}
        .quest-tracker .qobj{font-size:.9rem;color:#5a4020;margin-bottom:10px;font-style:italic}
        .quest-tracker .checklist{display:grid;gap:5px}
        .quest-tracker .check-item{display:flex;align-items:center;gap:8px;font-size:.92rem;color:#4a3818;transition:all .3s}
        .quest-tracker .check-item.done{color:#2a6a10;text-decoration:line-through}
        .quest-tracker .check-item .ck{width:16px;height:16px;border:1.5px solid #8b6914;border-radius:3px;display:flex;align-items:center;justify-content:center;font-size:.7rem;color:#2a6a10;flex-shrink:0}
        .quest-tracker .check-item.done .ck{background:rgba(42,106,16,.15);border-color:#2a6a10}
        .quest-fanfare{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:60;opacity:0;pointer-events:none;transition:opacity .4s}
        .quest-fanfare.show{opacity:1;pointer-events:auto}
        .quest-fanfare .qf-bg{position:absolute;inset:0;background:radial-gradient(ellipse at center,rgba(255,215,0,.15),rgba(0,0,0,.7))}
        .quest-fanfare .qf-title{font-family:Georgia,serif;font-size:2.2rem;font-weight:700;color:#ffd700;text-shadow:0 0 30px rgba(255,215,0,.5),0 4px 12px rgba(0,0,0,.4);z-index:1;animation:qfBounce .6s ease-out}
        .quest-fanfare .qf-sub{font-family:Georgia,serif;font-size:1rem;color:#e8d5a8;margin-top:8px;z-index:1;animation:qfFade .8s ease-out}
        .quest-fanfare .qf-reward{font-size:.9rem;color:var(--a);margin-top:16px;z-index:1;padding:8px 16px;border:1px solid rgba(110,200,110,.4);border-radius:8px;background:rgba(14,24,12,.8);animation:qfFade 1s ease-out}
        .quest-fanfare .qf-particles{position:absolute;inset:0;overflow:hidden;z-index:0}
        .quest-fanfare .qf-particle{position:absolute;width:8px;height:8px;border-radius:50%;animation:qfParticle 2s ease-out forwards}
        @keyframes qfBounce{0%{transform:scale(0) translateY(30px);opacity:0}50%{transform:scale(1.15) translateY(-10px)}100%{transform:scale(1) translateY(0);opacity:1}}
        @keyframes qfFade{0%{opacity:0;transform:translateY(20px)}100%{opacity:1;transform:translateY(0)}}
        @keyframes qfParticle{0%{opacity:1;transform:translateY(0) scale(1)}100%{opacity:0;transform:translateY(-200px) scale(0)}}
        .obj-complete-banner{position:fixed;top:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:28px 20px 22px;z-index:55;opacity:0;pointer-events:none;transition:opacity .5s;background:linear-gradient(180deg,rgba(0,0,0,.85) 0%,rgba(0,0,0,.6) 70%,transparent 100%)}
        .obj-complete-banner.show{opacity:1;pointer-events:auto}
        .obj-complete-banner .ocb-icon{font-size:2.4rem;animation:qfBounce .6s ease-out}
        .obj-complete-banner .ocb-title{font-family:Georgia,serif;font-size:1.8rem;font-weight:700;color:#ffd700;text-shadow:0 0 20px rgba(255,215,0,.4);margin-top:6px;animation:qfBounce .7s ease-out}
        .obj-complete-banner .ocb-sub{font-family:Georgia,serif;font-size:1.1rem;color:#e8d5a8;margin-top:4px;animation:qfFade 1s ease-out}
        .obj-complete-banner .ocb-hint{font-size:.85rem;color:#bbb;margin-top:10px;animation:qfFade 1.2s ease-out}
        .speech-bubble{position:absolute;pointer-events:none;max-width:280px;padding:12px 16px;border-radius:14px 14px 14px 4px;background:rgba(255,255,245,.94);color:#3a2a10;font-family:Georgia,serif;font-size:.95rem;line-height:1.5;box-shadow:0 4px 16px rgba(0,0,0,.3);border:1.5px solid rgba(139,105,20,.3);opacity:0;transition:opacity .4s;z-index:15;transform:translateX(-50%)}
        .speech-bubble.show{opacity:1}
        .speech-bubble::after{content:"";position:absolute;bottom:-8px;left:16px;width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:8px solid rgba(255,255,245,.92)}
        .crosshair{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:25;pointer-events:none;opacity:0;transition:opacity .2s}
        .crosshair.show{opacity:1}
        .crosshair::before,.crosshair::after{content:"";position:absolute;background:#fff;box-shadow:0 0 4px rgba(0,255,136,.6)}
        .crosshair::before{width:2px;height:20px;left:50%;top:50%;transform:translate(-50%,-50%)}
        .crosshair::after{width:20px;height:2px;left:50%;top:50%;transform:translate(-50%,-50%)}
        .crosshair .dot{width:4px;height:4px;background:#ff3344;border-radius:50%;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%)}
        .gun-hud{position:absolute;bottom:14px;left:14px;padding:10px 16px;border-radius:8px;background:rgba(10,10,10,.8);border:1px solid rgba(255,60,60,.4);color:#ff6644;font-size:.85rem;font-weight:600;letter-spacing:.05em;opacity:0;pointer-events:none;transition:opacity .3s;z-index:20;display:flex;align-items:center;gap:10px}
        .gun-hud.show{opacity:1}
        .gun-hud .gun-icon{font-size:1.2rem}
        .death-screen{position:fixed;inset:0;background:rgba(180,0,0,.8);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:70;opacity:0;pointer-events:none;transition:opacity .5s}
        .death-screen.show{opacity:1;pointer-events:auto}
        .death-screen .death-title{font-family:Georgia,serif;font-size:2.4rem;color:#fff;text-shadow:0 0 30px rgba(255,0,0,.6)}
        .death-screen .death-sub{font-size:1rem;color:#ffaa88;margin-top:12px}
        .hp-bar{position:fixed;top:55%;left:50%;transform:translate(-50%,20px);width:120px;height:6px;background:rgba(0,0,0,.6);border-radius:3px;z-index:25;opacity:0;pointer-events:none;transition:opacity .2s}
        .hp-bar.show{opacity:1}
        .hp-bar .hp-fill{height:100%;background:linear-gradient(90deg,#ff3344,#ffaa44);border-radius:3px;transition:width .15s}
        .muzzle-flash{position:fixed;top:50%;left:50%;width:40px;height:40px;margin:-20px 0 0 -20px;background:radial-gradient(circle,rgba(255,200,60,.9),rgba(255,100,20,.4),transparent);border-radius:50%;z-index:24;pointer-events:none;opacity:0;transition:none}
        @media(max-width:860px){.side-panel{top:auto;bottom:60px;right:14px;max-height:32vh}.hud{width:min(280px,calc(100vw - 28px))}}
    </style>
</head>
<body>
<div id="app">
    <div id="loading"><div style="text-align:center"><h1>Portfolio World</h1><p>Building world‚Ä¶ 45 projects across 4 districts</p></div></div>
    <div class="panel hud">
        <div class="hud-title">Mat Harvey ‚Äî Portfolio World</div>
        <div class="hud-row"><span>District</span><span class="v" id="district">Town Center</span></div>
        <div class="hud-row"><span>Speed</span><span class="v" id="speed">0 km/h</span></div>
        <div class="hud-row"><span>Discovered</span><span class="v" id="visited">0 / 45</span></div>
        <div class="hud-row"><span>Season</span><span class="v" id="season">Spring</span></div>
        <div class="hint">Driving: W/S forward/brake ¬∑ A/D steer ¬∑ Shift boost ¬∑ E interact ¬∑ F exit car ¬∑ G garage ¬∑ M mute</div>
        <div class="hint">Walking: W/S move ¬∑ A/D strafe ¬∑ Hold LMB look ¬∑ E talk ¬∑ F car ¬∑ G garage ¬∑ 1 equip SMG ¬∑ Scroll zoom</div>
    </div>
    <div class="panel side-panel"><div class="section-label">Achievements <span id="ach-count" style="float:right;color:var(--a);font-weight:600"></span></div><div id="badges"></div></div>
    <div class="ach-popup" id="ach-popup"><div class="ach-icon" id="ach-popup-icon"></div><div class="ach-body"><div class="ach-label">Achievement Unlocked</div><div class="ach-name" id="ach-popup-name"></div><div class="ach-desc" id="ach-popup-desc"></div><div class="ach-bar"><div class="ach-bar-fill" id="ach-popup-bar"></div></div></div></div>
    <div class="prompt" id="prompt"></div><div class="toast" id="toast"></div>
    <div class="dialog-overlay" id="dialog"><div class="dialog-box"><div class="dialog-npc" id="dialog-npc">Wizard</div><div class="dialog-title" id="dialog-title"></div><div class="dialog-text" id="dialog-text"></div><div class="dialog-progress" id="dialog-progress"></div><div class="dialog-btns" id="dialog-btns"></div></div></div>
    <div class="garage-overlay" id="garage-overlay">
        <div class="garage-modal">
            <button class="garage-close" onclick="window._garageClose()" title="Close (Esc)">&#10005;</button>
            <div class="garage-header">
                <div class="garage-title">My Garage</div>
                <div class="garage-subtitle">Your car collection</div>
            </div>
            <div class="garage-carousel">
                <button class="garage-nav" onclick="window._garagePrev()">&#9664;</button>
                <div class="garage-stage">
                    <div class="garage-preview" id="garage-preview"></div>
                    <div class="garage-info">
                        <div class="garage-car-name" id="garage-car-name"></div>
                        <div class="garage-car-desc" id="garage-car-desc"></div>
                        <div class="garage-car-badge" id="garage-car-badge"></div>
                        <br>
                        <button class="garage-select-btn" id="garage-select-btn" onclick="window._garageSelect()">Spawn This Car</button>
                    </div>
                    <div class="garage-dots" id="garage-dots"></div>
                    <div class="garage-counter" id="garage-counter"></div>
                </div>
                <button class="garage-nav" onclick="window._garageNext()">&#9654;</button>
            </div>
            <div class="garage-hint">Press G anytime to open &middot; &#9664; &#9654; or click dots to browse &middot; Esc to close</div>
        </div>
    </div>
    <div class="mode-badge" id="mode-badge"></div>
    <div class="quest-tracker" id="quest-tracker"><div class="qt" id="qt-title"></div><div class="qobj" id="qt-obj"></div><div class="checklist" id="qt-checklist"></div></div>
    <div class="speech-bubble" id="speech-bubble"></div>
    <div class="quest-fanfare" id="quest-fanfare"><div class="qf-bg"></div><div class="qf-particles" id="qf-particles"></div><div class="qf-title">Quest Complete!</div><div class="qf-sub" id="qf-sub">Portfolio Scout</div><div class="qf-reward" id="qf-reward">New car unlocked: Sport Car</div></div>
    <div class="obj-complete-banner" id="obj-complete-banner"><div class="ocb-icon">&#9733;</div><div class="ocb-title" id="ocb-title">Objectives Complete!</div><div class="ocb-sub" id="ocb-sub">Return to The Wizard to claim your reward</div><div class="ocb-hint">Walk to the quest giver and press E</div></div>
    <div class="crosshair" id="crosshair"><div class="dot"></div></div>
    <div class="gun-hud" id="gun-hud"><span class="gun-icon">üî´</span><span>SMG</span><span style="color:#aaa">| ‚àû</span></div>
    <div class="death-screen" id="death-screen"><div class="death-title" id="death-title">You Died</div><div class="death-sub" id="death-sub">The Wizard has struck you down!</div></div>
    <div class="hp-bar" id="hp-bar"><div class="hp-fill" id="hp-fill" style="width:100%"></div></div>
    <div class="muzzle-flash" id="muzzle-flash"></div>
    <div class="links"><a class="btn" href="index.html">‚Üê Classic Portfolio</a><button class="btn" id="mute-btn" type="button">Audio: ON</button></div>
</div>
<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.161.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/" } }
</script>
<script type="module">
import * as THREE from "three";
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

/* ====== PERFORMANCE PROFILE ====== */
const PERF={
    // Fixed settings across all devices for a consistent experience.
    antialias:true,
    pixelRatioCap:1.25,
    postFx:true,
    terrainSegs:165,
    grassBlades:18000,
    pineCount:180,
    deciCount:140,
    leafCount:120,
    waterSegX:34,
    waterSegY:16,
    extraGltf:true,
    traffic:true,
    fpsCap:0,
};

/* ====== SHADERS ====== */
const BOTW_VS=`
#ifdef USE_INSTANCING_COLOR
varying vec3 vIC;
#endif
varying vec3 vWN,vVD;varying float vFD;
void main(){
    #ifdef USE_INSTANCING_COLOR
    vIC=instanceColor;
    #endif
    vec4 wp;
    #ifdef USE_INSTANCING
    wp=modelMatrix*instanceMatrix*vec4(position,1.);vWN=normalize((modelMatrix*instanceMatrix*vec4(normal,0.)).xyz);
    #else
    wp=modelMatrix*vec4(position,1.);vWN=normalize((modelMatrix*vec4(normal,0.)).xyz);
    #endif
    vec4 mv=viewMatrix*wp;vVD=cameraPosition-wp.xyz;vFD=-mv.z;gl_Position=projectionMatrix*mv;}`;
const BOTW_FS=`
uniform vec3 uColor,uShadow,uSunDir,fogColor;uniform float fogNear,fogFar;
#ifdef USE_INSTANCING_COLOR
varying vec3 vIC;
#endif
varying vec3 vWN,vVD;varying float vFD;
void main(){vec3 base=uColor,sh=uShadow;
    #ifdef USE_INSTANCING_COLOR
    base*=vIC;sh*=vIC;
    #endif
    vec3 n=normalize(vWN);float NdL=dot(n,uSunDir)*.5+.5;NdL=floor(NdL*3.+.5)/3.;vec3 col=mix(sh,base,NdL);
    float rim=1.-max(dot(n,normalize(vVD)),0.);col+=vec3(1.,.95,.85)*smoothstep(.5,1.,rim)*.22;
    float ff=smoothstep(fogNear,fogFar,vFD);col=mix(col,fogColor,ff);gl_FragColor=vec4(col,1.);}`;
const WATER_VS=`uniform float uTime;varying vec2 vUv;varying float vFD;
void main(){vUv=uv;vec3 p=position;p.z-=sin(p.x*.15+uTime*1.5)*.2+cos(p.y*.12+uTime*1.2)*.15;
vec4 mv=modelViewMatrix*vec4(p,1.);vFD=-mv.z;gl_Position=projectionMatrix*mv;}`;
const WATER_FS=`uniform float uTime;uniform vec3 uShallow,uDeep,fogColor;uniform float fogNear,fogFar;
varying vec2 vUv;varying float vFD;
void main(){float w1=sin(vUv.x*28.+uTime*2.)*.5+.5;float w2=sin(vUv.y*20.+uTime*1.6+1.7)*.5+.5;
float w=w1*w2;vec3 col=mix(uDeep,uShallow,w*.35+.35);
col+=vec3(1.)*pow(w,6.)*.35+vec3(1.)*pow(max(sin(vUv.x*50.+uTime*3.)*sin(vUv.y*40.-uTime*2.5),0.),12.)*.2;
float ff=smoothstep(fogNear,fogFar,vFD);col=mix(col,fogColor,ff);gl_FragColor=vec4(col,.8);}`;

/* ====== MATCAP (car only) ====== */
function matcap(l,m,d){const s=256,cv=document.createElement("canvas");cv.width=s;cv.height=s;
const g=cv.getContext("2d"),gr=g.createRadialGradient(s*.38,s*.34,s*.05,s*.5,s*.52,s*.5);
gr.addColorStop(0,l);gr.addColorStop(.5,m);gr.addColorStop(1,d);g.fillStyle=gr;g.beginPath();g.arc(s/2,s/2,s/2,0,Math.PI*2);g.fill();
const t=new THREE.CanvasTexture(cv);t.colorSpace=THREE.SRGBColorSpace;return t;}
const MC={red:matcap("#ff9999","#cc2830","#601010"),dark:matcap("#606060","#1c1c20","#0a0a0a"),glass:matcap("#b0e8ff","#5898c8","#1c3860")};

/* ====== 45 PROJECTS ====== */
const DISTRICTS={
maritime:{label:"Port District",dtClass:"dt-port",color:"#3eaaa2",projects:[
    {t:"MarineStream Platform",u:"https://temp-msdt-for-review.onrender.com",g:"temp-msdt-for-review.gif"},
    {t:"Biofouling ID Guide",u:"https://mathew-harvey.github.io/BiofoulingIdGuide/",g:"BiofoulingIdGuide.gif"},
    {t:"Fouling Cost Calculator",u:"https://mathew-harvey.github.io/FoulingCostCalculator/",g:"FoulingCostCalculator.gif"},
    {t:"MarineStream Workspace",u:"https://MarineStream-Workspace.onrender.com",g:"MarineStream-Workspace.gif"},
    {t:"MarineStream Landing",u:"https://mathew-harvey.github.io/MarineStreamLandingPage/",g:"MarineStreamLandingPage.gif"},
    {t:"MarineStream App",u:"https://mathew-harvey.github.io/MarineStream/",g:"MarineStream.gif"},
    {t:"BFMP Doc Generator",u:"https://mathew-harvey.github.io/Document-Generator/",g:"Document-Generator.gif"},
    {t:"The Hull Truth",u:"https://mathew-harvey.github.io/TheHullTruth/",g:"TheHullTruth.gif"},
    {t:"Clean Hulls Clear Waters",u:"https://mathew-harvey.github.io/CleanHullsClearWaters/",g:"CleanHullsClearWaters.gif"},
]},
simulations:{label:"Science Park",dtClass:"dt-sim",color:"#6878cc",projects:[
    {t:"3D Ship Visualization",u:"https://mathew-harvey.github.io/3dShip/",g:"3dShip.gif"},
    {t:"Agentic Bubble Sort",u:"https://mathew-harvey.github.io/AgenticBubbleSort/",g:"AgenticBubbleSort.gif"},
    {t:"Ant Simulator",u:"https://mathew-harvey.github.io/AntSimulator/",g:"AntSimulator.gif"},
    {t:"Artificial Life",u:"https://mathew-harvey.github.io/Artificial-Life/",g:"Artificial-Life.gif"},
    {t:"Cancer Simulator",u:"https://mathew-harvey.github.io/CancerSimulator/",g:"CancerSimulator.gif"},
    {t:"Game of Life",u:"https://mathew-harvey.github.io/GameOfLife/",g:"GameOfLife.gif"},
    {t:"One Human Life",u:"https://mathew-harvey.github.io/One-Human-Life-React/",g:"One-Human-Life-React.gif"},
    {t:"Moltbook Throng",u:"https://mathew-harvey.github.io/Moltbook-Throng/",g:"Moltbook-Throng.gif"},
    {t:"Consciousness Framework",u:"https://mathew-harvey.github.io/A-New-Framework-for-Understanding-Consciousness/",g:"A-New-Framework-for-Understanding-Consciousness.gif"},
    {t:"Stages of Mind",u:"https://mathew-harvey.github.io/StagesOfMind/",g:"StagesOfMind.gif"},
]},
tools:{label:"Tech Hub",dtClass:"dt-tool",color:"#d0a030",projects:[
    {t:"Blurred Photos",u:"https://mathew-harvey.github.io/BlurredPhotos/",g:"BlurredPhotos.gif"},
    {t:"Image Compressor",u:"https://mathew-harvey.github.io/SimpleImageComression/",g:"SimpleImageComression.gif"},
    {t:"FormSync",u:"https://mathew-harvey.github.io/FormSync/",g:"FormSync.gif"},
    {t:"Net Connection Monitor",u:"https://mathew-harvey.github.io/NetConnectionMonitor/",g:"NetConnectionMonitor.gif"},
    {t:"VR Sim Racing Calc",u:"https://mathew-harvey.github.io/VrSimRacingCalc/",g:"VrSimRacingCalc.gif"},
    {t:"Web Disk Analyser",u:"https://mathew-harvey.github.io/WebDiskAnalyser/",g:"WebDiskAnalyser.gif"},
    {t:"Document Engine",u:"https://mathew-harvey.github.io/DocumentEngine/",g:"DocumentEngine.gif"},
]},
personal:{label:"Creative Village",dtClass:"dt-per",color:"#cc6088",projects:[
    {t:"FPV Track Planner",u:"https://mathew-harvey.github.io/FPVTrackPlanner/",g:"FPVTrackPlanner.gif"},
    {t:"Cat Translator",u:"https://mathew-harvey.github.io/CatTranslator/",g:"CatTranslator.gif"},
    {t:"Elodie Book One",u:"https://mathew-harvey.github.io/ElodieBook_One/",g:"ElodieBook_One.gif"},
    {t:"Elodie Book Two",u:"https://mathew-harvey.github.io/ElodieBook_Two/",g:"ElodieBook_Two.gif"},
    {t:"Extreme Limit Films",u:"https://mathew-harvey.github.io/ExtremeLimitFilms/",g:"ExtremeLimitFilms.gif"},
    {t:"Family Hiking",u:"https://mathew-harvey.github.io/FamilyHiking/",g:"FamilyHiking.gif"},
    {t:"Koi Runner",u:"https://mathew-harvey.github.io/KoiRunner/",g:"KoiRunner.gif"},
    {t:"Japan Itinerary",u:"https://mathew-harvey.github.io/JapanItinery/",g:"JapanItinery.gif"},
    {t:"WC MultiRotor Club",u:"https://mathew-harvey.github.io/WestCoastMultiRotorClub/",g:"WestCoastMultiRotorClub.gif"},
    {t:"Virtual Property Tour",u:"https://mathew-harvey.github.io/VirtualPropertyTour/",g:"VirtualPropertyTour.gif"},
    {t:"Portfolio 2025",u:"https://mathew-harvey.github.io/Mat-Portfolio-2025/",g:"Mat-Portfolio-2025.gif"},
    {t:"House Sitter Guide",u:"https://mathew-harvey.github.io/HouseSitter/",g:"HouseSitter.gif"},
    {t:"Skye Portfolio",u:"https://mathew-harvey.github.io/SkyePortfolio/",g:"SkyePortfolio.gif"},
    {t:"My Stuff",u:"https://mathew-harvey.github.io/MyStuffHere/",g:"MyStuffHere.gif"},
    {t:"Only Prints",u:"https://mathew-harvey.github.io/OnlyPrints/",g:"OnlyPrints.gif"},
]},
};
/* ====== COMPUTE BILLBOARD POSITIONS ====== */
/* Map layout ‚Äî all buildings/billboards verified clear of road surfaces:
   Ocean z<-65 ‚Üí Port z=-50 to -30 (road z=-40, edges z=-46..-34)
   Tech Hub x=-75 to -35 (road x=-50) ‚Üê Town Center x=-20..+20 ‚Üí Science Park x=35 to 75 (road x=50)
   Creative Village z=34 to 68 (road z=50, edges z=44..56)
   Main roads: x=0 N-S (hw=8), z=0 E-W (hw=8), connectors x=¬±38 (hw=4), entries x=¬±50 (hw=5) */
const ALL_PROJECTS=[];
function addRow(arr,sx,sz,n,dx,dz,dist){arr.forEach((p,i)=>{if(i>=n)return;p.district=dist;p.wx=sx+i*dx;p.wz=sz+i*dz;ALL_PROJECTS.push(p);});}
// Port: road z=-40 (z=-46..-34), avoid N-S road (x=-8..8), W-conn (x=-42..-34 at z>-40)
const portRow1=[[-50,-30],[-30,-30],[-22,-30],[-14,-30],[14,-30],[22,-30],[50,-30]];
const portRow2=[[-48,-50],[-34,-50],[-18,-50],[18,-50],[34,-50],[48,-50]];
DISTRICTS.maritime.projects.forEach((p,i)=>{const pos=i<7?portRow1[i]:portRow2[i-7];if(!pos)return;p.district="maritime";p.wx=pos[0];p.wz=pos[1];ALL_PROJECTS.push(p);});
// Science: N-S road at x=50 (x=45..55), also avoid E-W road (z=-8..8)
// East col (x=60) safe z: skip z=-8..8 ‚Üí z=-18,-12,12,18,24
const sciCol1=[[60,-18],[60,-12],[60,12],[72,16],[72,28]];
const sciCol2=[[40,-18],[40,-12],[40,12],[40,18],[40,28]];
DISTRICTS.simulations.projects.forEach((p,i)=>{const pos=i<5?sciCol1[i]:sciCol2[i-5];if(!pos)return;p.district="simulations";p.wx=pos[0];p.wz=pos[1];ALL_PROJECTS.push(p);});
// Tech: N-S road at x=-50 (x=-55..-45), avoid E-W road (z=-8..8)
const techCol1=[[-60,-18],[-60,-12],[-60,12],[-74,28]];
const techCol2=[[-40,-18],[-40,-12],[-40,14]];
DISTRICTS.tools.projects.forEach((p,i)=>{const pos=i<4?techCol1[i]:techCol2[i-4];if(!pos)return;p.district="tools";p.wx=pos[0];p.wz=pos[1];ALL_PROJECTS.push(p);});
// Creative: road z=50 (z=44..56), also avoid N-S road (x=-8..8), connectors (x=-42..-34, x=34..42 at z<50)
// Row 1 z=38: manually skip road bands
const creRow1=[[-50,38],[-28,38],[-20,38],[-14,38],[14,38],[20,38],[28,38],[50,38]];
const creRow2=[[-48,62],[-34,62],[-18,62],[14,62],[28,62],[42,62],[52,62]];
DISTRICTS.personal.projects.forEach((p,i)=>{const pos=i<8?creRow1[i]:creRow2[i-8];if(!pos)return;p.district="personal";p.wx=pos[0];p.wz=pos[1];ALL_PROJECTS.push(p);});

/* Billboard rotation: face toward the nearest road */
function bbRot(p){
    if(p.district==="maritime"||p.district==="personal"){
        const rz=p.district==="maritime"?-40:50;
        return p.wz<rz?0:Math.PI; // face +z or -z toward road
    }else{
        const rx=p.district==="simulations"?50:-50;
        return p.wx>rx?-Math.PI/2:Math.PI/2; // face toward road
    }
}

const ACHIEVEMENTS=[
    {id:"ignite",title:"Ignition",desc:"Start the engine.",icon:"\u{1F525}"},
    {id:"first",title:"Explorer",desc:"Visit your first project.",icon:"\u{1F9ED}"},
    {id:"port",title:"Harbor Master",desc:"All maritime projects.",icon:"\u{2693}"},
    {id:"science",title:"Scientist",desc:"All simulation projects.",icon:"\u{1F52C}"},
    {id:"all",title:"Portfolio Complete",desc:"Visit every project.",icon:"\u{1F3C6}"},
    {id:"speed",title:"JDM Spirit",desc:"Hit 120 km/h.",icon:"\u{1F3CE}"},
    {id:"collector",title:"Treasure Hunter",desc:"Collect all orbs.",icon:"\u{1F48E}"},
    {id:"crash",title:"Demolition Derby",desc:"Send 10 objects flying.",icon:"\u{1F4A5}"},
];

/* ====== STATE ====== */
// Load persisted garage data from localStorage
const _savedGarage=JSON.parse(localStorage.getItem("portfolioGarage")||"null");
// Load persisted achievements from localStorage
const _savedAch=JSON.parse(localStorage.getItem("portfolioAchievements")||"[]");
const state={speed:0,maxSpeed:0,canInteract:null,visited:new Set(),achievements:new Set(_savedAch),collectibles:new Set(),muted:false,seasonIndex:0,crashes:0,
    mode:"driving",questLog:[],
    unlockedCars:_savedGarage?.unlockedCars||["mazda"],
    activeCar:_savedGarage?.activeCar||"mazda",
    carParkedAt:null,nearNPC:false,avatarAngle:0,
    // Hot Lap quest
    gatesHit:0,totalGates:12,hotlapActive:false,
    // Gun & combat
    hasGun:false,gunEquipped:false,
    // Wizard protection
    wizardWarnings:0,isDead:false};
function _saveGarage(){localStorage.setItem("portfolioGarage",JSON.stringify({unlockedCars:state.unlockedCars,activeCar:state.activeCar}));}
const QUESTS=[{
    id:"scout",title:"Portfolio Scout",giver:"guide",
    desc:"Drive around the city and check out 5 project billboards.\nPark in the yellow bay and press E to visit each one.",
    objectiveText:"Visit 5 billboards",
    objective:()=>state.visited.size>=5,
    rewardText:"A new ride! The Pixelated Sport Car is now available in your garage!",
    reward:()=>{if(!state.unlockedCars.includes("sport")){state.unlockedCars.push("sport");_saveGarage();}},
    status:state.unlockedCars.includes("sport")?"done":"available"
},{
    id:"hotlap",title:"City Circuit",giver:"guide",
    desc:"Think you can handle speed? Complete a hot lap of the city ‚Äî drive through every checkpoint gate in order!\nYour reward will be... powerful.",
    objectiveText:"Drive through all 12 gates",
    objective:()=>state.gatesHit>=state.totalGates,
    rewardText:"The Wizard grants you an SMG! Press 1 while on foot to equip it.",
    reward:()=>{state.hasGun=true;},
    status:"locked", // unlocked when scout is done
    prerequisite:"scout"
}];
const districtEl=document.getElementById("district"),speedEl=document.getElementById("speed"),visitedEl=document.getElementById("visited"),seasonEl=document.getElementById("season"),badgesEl=document.getElementById("badges"),promptEl=document.getElementById("prompt"),toastEl=document.getElementById("toast"),muteBtn=document.getElementById("mute-btn");
function showToast(t){toastEl.textContent=t;toastEl.classList.add("show");clearTimeout(showToast._t);showToast._t=setTimeout(()=>toastEl.classList.remove("show"),2200);}
const achCountEl=document.getElementById("ach-count"),
      achPopup=document.getElementById("ach-popup"),
      achPopupIcon=document.getElementById("ach-popup-icon"),
      achPopupName=document.getElementById("ach-popup-name"),
      achPopupDesc=document.getElementById("ach-popup-desc"),
      achPopupBar=document.getElementById("ach-popup-bar");
function _saveAchievements(){localStorage.setItem("portfolioAchievements",JSON.stringify([...state.achievements]));}
function renderBadges(){
    badgesEl.innerHTML="";
    const earned=state.achievements.size;
    achCountEl.textContent=`${earned} / ${ACHIEVEMENTS.length}`;
    ACHIEVEMENTS.forEach(a=>{
        const on=state.achievements.has(a.id);
        const e=document.createElement("div");e.className="badge"+(on?" on":"");
        e.innerHTML=`<span class="badge-icon">${a.icon}</span><div class="badge-info"><span class="badge-title">${a.title}</span><span class="badge-desc">${on?a.desc:"???"}</span></div>`;
        badgesEl.appendChild(e);
    });
}
let _achPopupTimer=null;
function _showAchPopup(a){
    achPopupIcon.textContent=a.icon;
    achPopupName.textContent=a.title;
    achPopupDesc.textContent=a.desc;
    achPopupBar.style.transition="none";achPopupBar.style.width="0";
    achPopup.classList.add("show");
    // Audio fanfare ‚Äî ascending chime
    audio.chime(523,.1);setTimeout(()=>audio.chime(659,.1),120);
    setTimeout(()=>audio.chime(784,.12),240);setTimeout(()=>audio.chime(1047,.15),400);
    // Animate progress bar across the popup lifetime
    requestAnimationFrame(()=>{achPopupBar.style.transition="width 3.5s linear";achPopupBar.style.width="100%";});
    // Auto-dismiss
    clearTimeout(_achPopupTimer);
    _achPopupTimer=setTimeout(()=>{achPopup.classList.remove("show");},4500);
}
function unlock(id){
    if(state.achievements.has(id))return;
    state.achievements.add(id);
    _saveAchievements();
    renderBadges();
    const a=ACHIEVEMENTS.find(x=>x.id===id);
    if(a)_showAchPopup(a);
}
renderBadges();
function getDistrict(x,z){if(z<-28)return"Port District";if(z>30)return"Creative Village";if(x>28)return"Science Park";if(x<-28)return"Tech Hub";return"Town Center";}

/* ====== SCENE ====== */
const scene=new THREE.Scene();scene.background=new THREE.Color("#78b8e6");scene.fog=new THREE.Fog("#a8d4ec",70,240);
const camera=new THREE.PerspectiveCamera(55,innerWidth/innerHeight,.1,500);camera.position.set(0,10,18);
const renderer=new THREE.WebGLRenderer({antialias:PERF.antialias,powerPreference:"high-performance",precision:"highp"});
renderer.setSize(innerWidth,innerHeight);renderer.setPixelRatio(Math.min(devicePixelRatio,PERF.pixelRatioCap));
renderer.outputColorSpace=THREE.SRGBColorSpace;renderer.toneMapping=THREE.ACESFilmicToneMapping;renderer.toneMappingExposure=1.15;
document.getElementById("app").appendChild(renderer.domElement);
let composer=null;
if(PERF.postFx){
    composer=new EffectComposer(renderer);composer.addPass(new RenderPass(scene,camera));
    composer.addPass(new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight),.24,.55,.85));composer.addPass(new OutputPass());
}
const hemi=new THREE.HemisphereLight("#b4d8f0","#5a8040",.9);scene.add(hemi);
const sun=new THREE.DirectionalLight("#fff0c8",1.1);sun.position.set(60,90,40);scene.add(sun);
const sunSphere=new THREE.Mesh(new THREE.SphereGeometry(5,16,16),new THREE.MeshBasicMaterial({color:"#ffe8a0"}));scene.add(sunSphere);

/* ====== MATERIALS ====== */
const sunDir=new THREE.Vector3(.5,.86,.3).normalize();
function botw(c,s,o){const cc=new THREE.Color(c),ss=s?new THREE.Color(s):cc.clone().multiplyScalar(.35);
return new THREE.ShaderMaterial({uniforms:{uColor:{value:cc},uShadow:{value:ss},uSunDir:{value:sunDir},fogColor:{value:scene.fog.color},fogNear:{value:70},fogFar:{value:240}},vertexShader:BOTW_VS,fragmentShader:BOTW_FS,side:(o&&o.side)||THREE.FrontSide});}
const waterMat=new THREE.ShaderMaterial({uniforms:{uTime:{value:0},uShallow:{value:new THREE.Color("#60d8c8")},uDeep:{value:new THREE.Color("#2888a0")},fogColor:{value:scene.fog.color},fogNear:{value:70},fogFar:{value:240}},vertexShader:WATER_VS,fragmentShader:WATER_FS,transparent:true,side:THREE.DoubleSide});

/* ====== TERRAIN ====== */
function hash2(a,b){const s=Math.sin(a*127.1+b*311.7)*43758.5453;return s-Math.floor(s);}
function ss(t){return t*t*(3-2*t);}function vn(x,z){const x0=Math.floor(x),z0=Math.floor(z),tx=ss(x-x0),tz=ss(z-z0);const a=hash2(x0,z0)+(hash2(x0+1,z0)-hash2(x0,z0))*tx;const b=hash2(x0,z0+1)+(hash2(x0+1,z0+1)-hash2(x0,z0+1))*tx;return a+(b-a)*tz;}
function fbm(x,z){let a=1,f=1,s=0,n=0;for(let i=0;i<5;i++){s+=vn(x*f,z*f)*a;n+=a;a*=.5;f*=2.1;}return s/n;}
const ROAD_SEGS=[
    {x1:0,z1:-68,x2:0,z2:75,hw:8},{x1:-88,z1:0,x2:88,z2:0,hw:8},        // Main boulevards 16 wide
    {x1:-55,z1:-40,x2:55,z2:-40,hw:6},{x1:-48,z1:50,x2:48,z2:50,hw:6},   // Port & Creative roads 12 wide
    {x1:-50,z1:-22,x2:-50,z2:22,hw:5},{x1:50,z1:-22,x2:50,z2:22,hw:5},   // Tech & Science entries 10 wide
    {x1:-38,z1:-40,x2:-38,z2:50,hw:4},{x1:38,z1:-40,x2:38,z2:50,hw:4},   // Side connectors 8 wide
];
function ptSeg(px,pz,x1,z1,x2,z2){const dx=x2-x1,dz=z2-z1,l2=dx*dx+dz*dz;if(l2<.01)return Math.hypot(px-x1,pz-z1);const t=Math.max(0,Math.min(1,((px-x1)*dx+(pz-z1)*dz)/l2));return Math.hypot(px-(x1+t*dx),pz-(z1+t*dz));}
function roadDist(x,z){let m=999;for(const r of ROAD_SEGS)m=Math.min(m,ptSeg(x,z,r.x1,r.z1,r.x2,r.z2)-r.hw);return m;}
const ROAD_Y=.25;
function terrainHeight(x,z){
    let h=(fbm(x*.02,z*.02)-.5)*9;h+=Math.sin(x*.04)*.6+Math.cos(z*.04)*.6;
    h*=Math.min(1,Math.max(.2,Math.hypot(x,z)/60));
    const rd=roadDist(x,z);if(rd<=0)h=ROAD_Y;else if(rd<8)h=ROAD_Y+(h-ROAD_Y)*ss(rd/8);
    if(z<-44){const p=Math.min(1,(-z-44)/22);h=h*(1-p*p)+(-1.2)*p*p;}return h;}
const WORLD=400,SEGS=PERF.terrainSegs;
const tGeo=new THREE.PlaneGeometry(WORLD,WORLD,SEGS,SEGS);tGeo.rotateX(-Math.PI/2);
const tPos=tGeo.attributes.position,tColors=new Float32Array(tPos.count*3);
for(let i=0;i<tPos.count;i++)tPos.setY(i,terrainHeight(tPos.getX(i),tPos.getZ(i)));
tGeo.computeVertexNormals();
const terrain=new THREE.Mesh(tGeo,new THREE.MeshStandardMaterial({vertexColors:true,roughness:.92,metalness:.02}));scene.add(terrain);

/* ====== ROADS ====== */
const roadMat=new THREE.MeshStandardMaterial({color:"#5a6050",roughness:.92}),lineMat=new THREE.MeshBasicMaterial({color:"#e8d89c"});
function addRoad(cx,cz,w,d){const m=new THREE.Mesh(new THREE.PlaneGeometry(w,d),roadMat);m.rotation.x=-Math.PI/2;m.position.set(cx,ROAD_Y+.02,cz);scene.add(m);
const hz=w>d,len=hz?w:d;for(let i=-len/2+3;i<len/2;i+=6){const mk=new THREE.Mesh(new THREE.PlaneGeometry(1.6,.22),lineMat);mk.rotation.x=-Math.PI/2;
if(hz)mk.position.set(cx-len/2+i+3,ROAD_Y+.04,cz);else{mk.rotation.z=Math.PI/2;mk.position.set(cx,ROAD_Y+.04,cz-len/2+i+3);}scene.add(mk);}}
addRoad(0,3.5,16,143);addRoad(0,0,176,16);addRoad(0,-40,110,12);addRoad(0,50,96,12);
addRoad(-50,0,10,44);addRoad(50,0,10,44);addRoad(-38,5,8,90);addRoad(38,5,8,90);

/* ====== GRASS ‚Äî always visible, reacts to car + wind ====== */
const GRASS_N=PERF.grassBlades;
const bVerts=new Float32Array([-.05,0,0,.05,0,0,-.035,.35,0,.035,.35,0,-.02,.7,0,.02,.7,0,0,1,0]);
const bGeo2=new THREE.BufferGeometry();bGeo2.setAttribute("position",new THREE.BufferAttribute(bVerts,3));bGeo2.setIndex([0,1,2,2,1,3,2,3,4,4,3,5,4,5,6]);
const grassGeo=new THREE.InstancedBufferGeometry();grassGeo.index=bGeo2.index;grassGeo.setAttribute("position",bGeo2.getAttribute("position"));
const gO=new Float32Array(GRASS_N*3),gS=new Float32Array(GRASS_N),gA2=new Float32Array(GRASS_N);
let gi=0;while(gi<GRASS_N){const x=(Math.random()-.5)*320,z=(Math.random()-.5)*300;if(roadDist(x,z)<2||z<-48)continue;const y=terrainHeight(x,z);if(y<-.4)continue;gO[gi*3]=x;gO[gi*3+1]=y;gO[gi*3+2]=z;gS[gi]=.3+Math.random()*1.0;gA2[gi]=Math.random()*Math.PI*2;gi++;}
grassGeo.setAttribute("aO",new THREE.InstancedBufferAttribute(gO,3));grassGeo.setAttribute("aS",new THREE.InstancedBufferAttribute(gS,1));grassGeo.setAttribute("aA",new THREE.InstancedBufferAttribute(gA2,1));
const GRASS_DIST=80; // render distance for grass (units from camera)
const grassMat=new THREE.ShaderMaterial({uniforms:{
    uTime:{value:0},uCarPos:{value:new THREE.Vector3()},uCarSpeed:{value:0},
    uCamPos:{value:new THREE.Vector3()},uRenderDist:{value:GRASS_DIST},
    uBase:{value:new THREE.Color("#3d8a2e")},uTip:{value:new THREE.Color("#a8d44e")},
    fogColor:{value:scene.fog.color},fogNear:{value:60},fogFar:{value:GRASS_DIST*0.95}},
vertexShader:`
attribute vec3 aO; attribute float aS, aA;
uniform float uTime, uCarSpeed, uRenderDist;
uniform vec3 uCarPos, uCamPos;
varying float vH, vFD;
void main(){
    // --- Render distance cull: scale to zero beyond range ---
    float dCam = distance(aO.xz, uCamPos.xz);
    float fade = 1.0 - smoothstep(uRenderDist * 0.75, uRenderDist, dCam);
    if(fade < 0.01){ gl_Position = vec4(0.0); return; } // GPU skips zero-area triangles

    vH = position.y;
    float c = cos(aA), s = sin(aA);
    float scaledH = position.y * aS * fade; // fade shrinks blade height
    vec3 p = vec3(position.x*c - position.z*s, scaledH, position.x*s + position.z*c);
    // --- Multi-layer wind ---
    float ph = uTime*1.8 + aO.x*.12 + aO.z*.1;
    float windMain = sin(ph) + 0.5*sin(ph*2.3 + 1.5) + 0.25*sin(ph*4.7 + 3.0);
    float windGust = 0.3*sin(uTime*0.4 + aO.x*0.03)*sin(uTime*0.7 + aO.z*0.05);
    float h2 = position.y * position.y;
    p.x += h2 * 0.2 * (windMain + windGust) * fade;
    p.z += (h2 * 0.12 * cos(ph*0.7 + 1.3) + h2 * 0.08 * windGust) * fade;
    // --- Car interaction: blades bend away from car ---
    vec3 wPos = p + aO;
    vec2 toCar = wPos.xz - uCarPos.xz;
    float carDist = length(toCar);
    float pushR = 2.5 + abs(uCarSpeed) * 0.3;
    if(carDist < pushR && carDist > 0.01){
        float pushStr = (1.0 - carDist/pushR) * position.y * (0.8 + abs(uCarSpeed)*0.15);
        pushStr = pushStr * pushStr;
        vec2 pushDir = toCar / carDist;
        p.x += pushDir.x * pushStr;
        p.z += pushDir.y * pushStr;
        p.y -= pushStr * 0.25;
    }
    vec4 mv = modelViewMatrix * vec4(p + aO, 1.0);
    vFD = -mv.z;
    gl_Position = projectionMatrix * mv;
}`,
fragmentShader:`
uniform vec3 uBase, uTip, fogColor;
uniform float fogNear, fogFar;
varying float vH, vFD;
void main(){
    vec3 col = mix(uBase, uTip, smoothstep(0.0, 1.0, vH)) * (0.8 + vH*0.2);
    float ff = smoothstep(fogNear, fogFar, vFD);
    col = mix(col, fogColor, ff);
    gl_FragColor = vec4(col, 1.0);
}`,side:THREE.DoubleSide});
const grassMesh=new THREE.Mesh(grassGeo,grassMat);
grassMesh.frustumCulled=false; // ALWAYS render grass ‚Äî no popping
scene.add(grassMesh);

/* ====== TREES ‚Äî pine + deciduous ====== */
const PINE_N=PERF.pineCount,DECI_N=PERF.deciCount;const dm=new THREE.Object3D();
const trunkIM=new THREE.InstancedMesh(new THREE.CylinderGeometry(.14,.24,2.6,8),botw("#7d5a38","#3a2818"),PINE_N);
const c1IM=new THREE.InstancedMesh(new THREE.ConeGeometry(1.6,2.6,7),botw("#3a8a3a","#1a4a1a"),PINE_N);
const c2IM=new THREE.InstancedMesh(new THREE.ConeGeometry(1.2,2.2,7),botw("#48984a","#1a541a"),PINE_N);
const c3IM=new THREE.InstancedMesh(new THREE.ConeGeometry(.85,1.8,7),botw("#58aa48","#285a18"),PINE_N);
scene.add(trunkIM,c1IM,c2IM,c3IM);
let tp=0;while(tp<PINE_N){const x=(Math.random()-.5)*320,z=(Math.random()-.5)*300;if(roadDist(x,z)<6||z<-50)continue;const y=terrainHeight(x,z);if(y<-.3)continue;const s=.7+Math.random();dm.position.set(x,y+1.2,z);dm.scale.set(1,s,1);dm.updateMatrix();trunkIM.setMatrixAt(tp,dm.matrix);dm.position.y=y+2.4*s;dm.scale.setScalar(s);dm.updateMatrix();c1IM.setMatrixAt(tp,dm.matrix);dm.position.y=y+3.4*s;dm.scale.setScalar(s*.88);dm.updateMatrix();c2IM.setMatrixAt(tp,dm.matrix);dm.position.y=y+4.2*s;dm.scale.setScalar(s*.72);dm.updateMatrix();c3IM.setMatrixAt(tp,dm.matrix);tp++;}
[trunkIM,c1IM,c2IM,c3IM].forEach(m=>m.instanceMatrix.needsUpdate=true);
// Round deciduous trees
const dTrunkIM=new THREE.InstancedMesh(new THREE.CylinderGeometry(.18,.28,3,8),botw("#7d5a38","#3a2818"),DECI_N);
const dCanopyIM=new THREE.InstancedMesh(new THREE.IcosahedronGeometry(2,2),botw("#4aa040","#1a5a1a"),DECI_N);
scene.add(dTrunkIM,dCanopyIM);
let dp=0;while(dp<DECI_N){const x=(Math.random()-.5)*280,z=(Math.random()-.5)*260;if(roadDist(x,z)<6||z<-46)continue;const y=terrainHeight(x,z);if(y<-.2)continue;const s=.6+Math.random()*.7;dm.position.set(x,y+1.4,z);dm.scale.set(1,s,1);dm.updateMatrix();dTrunkIM.setMatrixAt(dp,dm.matrix);dm.position.y=y+3.2*s;dm.scale.set(s*.9,s*.7,s*.9);dm.updateMatrix();dCanopyIM.setMatrixAt(dp,dm.matrix);dp++;}
dm.scale.set(1,1,1);[dTrunkIM,dCanopyIM].forEach(m=>m.instanceMatrix.needsUpdate=true);

/* ====== SCATTER ====== */
const flowerIM=new THREE.InstancedMesh(new THREE.SphereGeometry(.14,6,6),botw("#e0e0e0","#606060"),500);
const rockIM=new THREE.InstancedMesh(new THREE.DodecahedronGeometry(.35,0),botw("#888890","#404048"),200);
const bushIM=new THREE.InstancedMesh(new THREE.IcosahedronGeometry(.55,1),botw("#4a9a3a","#1a4a1a"),300);
scene.add(flowerIM,rockIM,bushIM);
let fi=0;while(fi<500){const x=(Math.random()-.5)*260,z=(Math.random()-.5)*260;if(roadDist(x,z)<2||z<-46)continue;const y=terrainHeight(x,z);if(y<-.2)continue;dm.position.set(x,y+.12,z);dm.scale.setScalar(.5+Math.random()*.8);dm.rotation.set(0,0,0);dm.updateMatrix();flowerIM.setMatrixAt(fi,dm.matrix);flowerIM.setColorAt(fi,new THREE.Color().setHSL(Math.random()*.15+.85,.7,.65));fi++;}
let ri=0;while(ri<200){const x=(Math.random()-.5)*300,z=(Math.random()-.5)*300;if(roadDist(x,z)<4)continue;const y=terrainHeight(x,z);dm.position.set(x,y+.1,z);dm.scale.set(.5+Math.random(),.4+Math.random()*.6,.5+Math.random());dm.rotation.set(Math.random(),Math.random(),0);dm.updateMatrix();rockIM.setMatrixAt(ri,dm.matrix);ri++;}
let bi=0;while(bi<300){const x=(Math.random()-.5)*280,z=(Math.random()-.5)*260;if(roadDist(x,z)<4||z<-46)continue;const y=terrainHeight(x,z);if(y<-.2)continue;dm.position.set(x,y+.3,z);dm.scale.setScalar(.4+Math.random()*.7);dm.rotation.set(0,0,0);dm.updateMatrix();bushIM.setMatrixAt(bi,dm.matrix);bi++;}
dm.rotation.set(0,0,0);[flowerIM,rockIM,bushIM].forEach(m=>{m.instanceMatrix.needsUpdate=true;if(m.instanceColor)m.instanceColor.needsUpdate=true;});

/* ====== WATER ====== */
const water=new THREE.Mesh(new THREE.PlaneGeometry(260,80,PERF.waterSegX,PERF.waterSegY),waterMat);water.rotation.x=-Math.PI/2;water.position.set(0,-1,-78);scene.add(water);

/* ====== COLLISION ====== */
const staticCol=[];const dynCol=[];
function addStatic(mesh,pad){const b=new THREE.Box3().setFromObject(mesh);b.expandByScalar(pad||.2);staticCol.push(b);return staticCol.length-1;}
function addDynamic(mesh){dynCol.push({mesh,vel:new THREE.Vector3()});}

/* ====== DESTROYABLE REGISTRY ====== */
const destroyables=[];
function registerDestroyable(mesh,health,type){
    const idx=destroyables.length;
    mesh.traverse(ch=>{if(ch.isMesh)ch.userData._destroyIdx=idx;});
    mesh.userData._destroyIdx=idx;
    destroyables.push({mesh,health,maxHealth:health,type,alive:true});
    return idx;
}

/* ====== HOT LAP GATE SYSTEM ====== */
const GATE_POSITIONS=[
    {x:4,z:-15,rotY:0},          // 1: South on main road
    {x:4,z:-36,rotY:0},          // 2: Approaching port
    {x:25,z:-40,rotY:Math.PI/2}, // 3: East on port road
    {x:50,z:-36,rotY:0},         // 4: Port meets science
    {x:50,z:-10,rotY:0},         // 5: Science entry heading north
    {x:50,z:12,rotY:0},          // 6: Through science
    {x:38,z:35,rotY:0},          // 7: East connector north
    {x:20,z:50,rotY:Math.PI/2},  // 8: Creative road east
    {x:-20,z:50,rotY:Math.PI/2}, // 9: Creative road west
    {x:-38,z:30,rotY:0},         // 10: West connector south
    {x:-50,z:0,rotY:0},          // 11: Tech hub
    {x:-15,z:0,rotY:Math.PI/2},  // 12: E-W road finish
];
const hotlapGates=[];
function spawnGates(){
    // Remove existing gates
    hotlapGates.forEach(g=>scene.remove(g.group));
    hotlapGates.length=0;
    state.gatesHit=0;
    GATE_POSITIONS.forEach((gp,i)=>{
        const group=new THREE.Group();
        // Gate arch ‚Äî torus ring
        const torus=new THREE.Mesh(
            new THREE.TorusGeometry(4,0.3,8,24),
            new THREE.MeshBasicMaterial({color:i===0?"#00ff88":"#334444",transparent:true,opacity:i===0?0.9:0.35})
        );
        torus.rotation.y=gp.rotY;
        group.add(torus);
        // Left pillar
        const pillarGeo=new THREE.CylinderGeometry(0.25,0.25,8,8);
        const pillarMat=new THREE.MeshStandardMaterial({color:i===0?"#00ff88":"#445555",emissive:i===0?"#00ff88":"#112222",emissiveIntensity:i===0?0.5:0.1});
        const lp=new THREE.Mesh(pillarGeo,pillarMat);
        const rp=new THREE.Mesh(pillarGeo,pillarMat.clone());
        // Position pillars based on gate rotation
        const offX=Math.cos(gp.rotY)*4, offZ=Math.sin(gp.rotY)*4;
        lp.position.set(-offX,4,offZ);
        rp.position.set(offX,4,-offZ);
        group.add(lp,rp);
        // Number label
        const cv=document.createElement("canvas");cv.width=64;cv.height=64;
        const ctx=cv.getContext("2d");
        ctx.fillStyle=i===0?"#00ff88":"#445555";ctx.font="bold 48px sans-serif";
        ctx.textAlign="center";ctx.textBaseline="middle";ctx.fillText(""+(i+1),32,32);
        const numTex=new THREE.CanvasTexture(cv);
        const numSprite=new THREE.Sprite(new THREE.SpriteMaterial({map:numTex,transparent:true,depthTest:false}));
        numSprite.scale.set(2,2,1);numSprite.position.y=8.5;
        group.add(numSprite);
        const gy=Math.max(terrainHeight(gp.x,gp.z),ROAD_Y);
        group.position.set(gp.x,gy,gp.z);
        scene.add(group);
        hotlapGates.push({group,pos:new THREE.Vector3(gp.x,gy,gp.z),hit:false,idx:i,torus,lPillar:lp,rPillar:rp,numSprite});
    });
}
function updateGateVisuals(){
    hotlapGates.forEach((g,i)=>{
        if(g.hit){g.group.visible=false;return;}
        g.group.visible=true;
        const isNext=i===state.gatesHit;
        const color=isNext?0x00ff88:0x334444;
        g.torus.material.color.setHex(color);
        g.torus.material.opacity=isNext?0.9:0.35;
        g.lPillar.material.color.setHex(color);
        g.lPillar.material.emissive.setHex(isNext?0x00ff88:0x112222);
        g.lPillar.material.emissiveIntensity=isNext?0.5:0.1;
        g.rPillar.material.color.setHex(color);
        g.rPillar.material.emissive.setHex(isNext?0x00ff88:0x112222);
        g.rPillar.material.emissiveIntensity=isNext?0.5:0.1;
    });
}
function removeGates(){
    hotlapGates.forEach(g=>scene.remove(g.group));
    hotlapGates.length=0;state.hotlapActive=false;
}

/* ====== TOWN CENTER ‚Äî Times Square ====== */
function mkTSBuilding(x,z,w,h,d,rotY,screenText,screenColor){
    const g=new THREE.Group();
    const body=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),botw("#4a4a58","#2a2a30"));body.position.y=h/2;g.add(body);
    // Windows grid
    const winMat=new THREE.MeshBasicMaterial({color:"#a0c8e0"});
    for(let fy=3;fy<h-1;fy+=2.5)for(let fx=-(w/2-1);fx<w/2;fx+=1.8){g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.9,1.4),winMat);m.position.set(fx,fy,d/2+.01);return m;})());g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.9,1.4),winMat);m.position.set(fx,fy,-d/2-.01);m.rotation.y=Math.PI;return m;})());}
    // Decorative screen
    const cv=document.createElement("canvas");cv.width=512;cv.height=256;const ct=cv.getContext("2d");
    ct.fillStyle="#0a0a14";ct.fillRect(0,0,512,256);ct.fillStyle=screenColor;ct.font="bold 32px Segoe UI";ct.textAlign="center";ct.fillText(screenText,256,100);
    ct.fillStyle="rgba(255,255,255,.3)";ct.font="18px Segoe UI";ct.fillText("DRIVE TO DISCOVER",256,160);
    for(let y=0;y<256;y+=3)ct.fillRect(0,y,512,1);ct.strokeStyle=screenColor;ct.lineWidth=4;ct.strokeRect(2,2,508,252);
    const tex=new THREE.CanvasTexture(cv);tex.colorSpace=THREE.SRGBColorSpace;
    const scr=new THREE.Mesh(new THREE.PlaneGeometry(w*.8,h*.3),new THREE.MeshStandardMaterial({map:tex,emissive:"#fff",emissiveMap:tex,emissiveIntensity:.5}));
    scr.position.set(0,h*.65,d/2+.03);g.add(scr);
    // Neon frame
    const nm=new THREE.MeshBasicMaterial({color:screenColor});
    const sw=w*.8,sh=h*.3,sy=h*.65;
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(sw+.3,.15,.15),nm);m.position.set(0,sy+sh/2+.1,d/2+.08);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(sw+.3,.15,.15),nm);m.position.set(0,sy-sh/2-.1,d/2+.08);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.15,sh+.3,.15),nm);m.position.set(-sw/2-.1,sy,d/2+.08);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.15,sh+.3,.15),nm);m.position.set(sw/2+.1,sy,d/2+.08);return m;})());
    g.position.set(x,terrainHeight(x,z),z);g.rotation.y=rotY||0;scene.add(g);addStatic(g,.3);registerDestroyable(g,100,"building");return g;
}
mkTSBuilding(-16,-16, 8,16,7, Math.PI/6,"M A T  H A R V E Y","#00ff88");
mkTSBuilding(16,-16, 7,18,6, -Math.PI/6,"4 5  P R O J E C T S","#ff6688");
mkTSBuilding(-16,16, 7,14,7, -Math.PI/6,"P O R T F O L I O  2 0 2 6","#66aaff");
mkTSBuilding(16,16, 8,15,6, Math.PI/6,"D R I V E  ¬∑  E X P L O R E","#ffcc44");
// Fountain ‚Äî small collider only
const fountain=new THREE.Group();
fountain.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(3.5,4,1,24),botw("#8899aa","#445566"));m.position.y=.5;return m;})());
fountain.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.55,.7,3.6,12),botw("#b0b8c0","#505860"));m.position.y=2.3;return m;})());
fountain.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(1.1,.5,.6,12),botw("#a0a8b0","#505860"));m.position.y=4.4;return m;})());
fountain.add((()=>{const m=new THREE.Mesh(new THREE.SphereGeometry(.4,12,12),new THREE.MeshBasicMaterial({color:"#88ddff"}));m.position.y=4.8;return m;})());
fountain.position.set(0,ROAD_Y,0);scene.add(fountain);
// Only a small sphere collider for fountain
staticCol.push(new THREE.Box3(new THREE.Vector3(-2,-.5,-2),new THREE.Vector3(2,6,2)));
// District signs ‚Äî dynamic (breakable)
function mkSign(x,z,text,color){const g=new THREE.Group();g.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.06,.08,2.5,8),botw("#5a4a30","#2a2010"));m.position.y=1.25;return m;})());const cv=document.createElement("canvas");cv.width=256;cv.height=64;const ct=cv.getContext("2d");ct.fillStyle=color;ct.fillRect(0,0,256,64);ct.fillStyle="#fff";ct.font="bold 26px Segoe UI";ct.textAlign="center";ct.fillText(text,128,42);const tex=new THREE.CanvasTexture(cv);tex.colorSpace=THREE.SRGBColorSpace;g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(1.8,.45),new THREE.MeshStandardMaterial({map:tex,emissive:color,emissiveIntensity:.15}));m.position.y=2.6;return m;})());g.position.set(x,Math.max(terrainHeight(x,z),ROAD_Y),z);scene.add(g);addDynamic(g);return g;}
// District signs ‚Äî placed on sidewalks, not in road bands
mkSign(10,-25,"PORT DISTRICT","#2a6a66");mkSign(-10,26,"CREATIVE VILLAGE","#8a4060");
mkSign(24,10,"SCIENCE PARK","#3a4080");mkSign(-24,10,"TECH HUB","#8a6a20");
// Lamp posts ‚Äî NO collision, just decorative
function mkLamp(x,z){const g=new THREE.Group();g.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.06,.1,4.2,8),botw("#383840","#1a1a20"));m.position.y=2.1;return m;})());g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.06,.06,.8),botw("#383840","#1a1a20"));m.position.set(0,3.9,.35);return m;})());g.add((()=>{const m=new THREE.Mesh(new THREE.SphereGeometry(.22,8,8),new THREE.MeshBasicMaterial({color:"#ffe8a0"}));m.position.set(0,3.6,.65);return m;})());g.position.set(x,Math.max(terrainHeight(x,z),ROAD_Y),z);scene.add(g);return g;}
// Lamp posts at corners of town center ‚Äî all outside road bands (x=-8..8, z=-8..8)
[[11,11],[-11,11],[11,-11],[-11,-11],[15,11],[-15,11],[15,-11],[-15,-11]].forEach(([x,z])=>mkLamp(x,z));
// Benches ‚Äî dynamic (breakable)
function mkBench(x,z,r){const g=new THREE.Group();g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(1.6,.08,.5),botw("#a08060","#504020"));m.position.y=.5;return m;})());g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(1.6,.5,.06),botw("#907050","#483828"));m.position.set(0,.75,-.2);return m;})());g.position.set(x,Math.max(terrainHeight(x,z),ROAD_Y),z);g.rotation.y=r||0;scene.add(g);addDynamic(g);return g;}
// Benches in town center quadrants ‚Äî outside road bands (x=-8..8, z=-8..8)
[[-12,10,0],[12,10,Math.PI],[-12,-10,0],[12,-10,Math.PI],[18,18,Math.PI/4],[-18,18,-Math.PI/4]].forEach(([x,z,r])=>mkBench(x,z,r));

/* ====== PORT ====== */
const dock=new THREE.Mesh(new THREE.BoxGeometry(120,.6,20),botw("#7d5a38","#3a2818"));dock.position.set(0,-.1,-55);scene.add(dock);addStatic(dock);
for(let x=-55;x<=55;x+=8){const p=new THREE.Mesh(new THREE.CylinderGeometry(.22,.3,3.5,8),botw("#6a4a28","#301a08"));p.position.set(x,-1.5,-64);scene.add(p);}
const lh=new THREE.Group();lh.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(1.2,1.7,14,12),botw("#e0dcd0","#808078"));m.position.y=7;return m;})());lh.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(1.4,1.4,2.5,12),botw("#cc2830","#601010"));m.position.y=9;return m;})());lh.add((()=>{const m=new THREE.Mesh(new THREE.SphereGeometry(.5,12,12),new THREE.MeshBasicMaterial({color:"#ffee60"}));m.position.y=16;return m;})());lh.position.set(-62,terrainHeight(-62,-55),-55);scene.add(lh);addStatic(lh,.5);
const contC=["#c44030","#3060a0","#d08030","#309050","#a040a0","#c0a030"];
for(let i=0;i<12;i++){const c=new THREE.Mesh(new THREE.BoxGeometry(3.2,2,2),botw(contC[i%6]));c.position.set(48+(i%4)*4,.8,-55-Math.floor(i/4)*2.6);c.rotation.y=.08*(i%3);scene.add(c);addStatic(c);}
// Dynamic crates and barrels ‚Äî these fly when hit
const crateMat=botw("#8a7048","#4a3820"),barrelMat=botw("#6a5838","#3a2818");
[[-40,-52],[-37,-53],[-34,-51],[52,-48],[55,-49],[57,-47],[-42,-48],[-30,-50],[45,-52],[50,-46]].forEach(([x,z])=>{const cr=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),crateMat);cr.position.set(x,.3+Math.max(terrainHeight(x,z),ROAD_Y),z);cr.rotation.y=Math.random()*.5;scene.add(cr);addDynamic(cr);});
[[-38,-54],[54,-50],[58,-48],[-32,-52],[48,-47]].forEach(([x,z])=>{const br=new THREE.Mesh(new THREE.CylinderGeometry(.45,.45,1.1,10),barrelMat);br.position.set(x,.35+Math.max(terrainHeight(x,z),ROAD_Y),z);scene.add(br);addDynamic(br);});
// Crane
const crane=new THREE.Group();crane.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.8,16,.8),botw("#d08030","#704010"));m.position.y=8;return m;})());crane.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(12,.6,.6),botw("#d08030","#704010"));m.position.set(4,15.5,0);return m;})());crane.position.set(62,terrainHeight(62,-55),-55);scene.add(crane);addStatic(crane,.3);registerDestroyable(crane,60,"building");

// Kotor-class frigate docked at port (GLB model)
new GLTFLoader().load('models/ship/kotor-class_frigate.glb',gltf=>{
    const m=gltf.scene;
    m.updateMatrixWorld(true);
    // Measure raw bounds for scaling
    const b=realBounds(m);
    const rawLen=Math.max(b.max.x-b.min.x,b.max.z-b.min.z);
    // Scale so ship is ~35 units long (fills port nicely)
    const sc=35/rawLen;m.scale.setScalar(sc);
    m.updateMatrixWorld(true);
    const b2=realBounds(m);
    // Create group, ground the model so bottom sits at water level
    const shipGroup=new THREE.Group();shipGroup.add(m);
    m.position.y=-b2.min.y-1.0; // sink slightly into water
    m.position.x-=(b2.min.x+b2.max.x)/2; // center X
    m.position.z-=(b2.min.z+b2.max.z)/2; // center Z
    // Fix materials ‚Äî ensure everything renders solid
    m.traverse(ch=>{if(ch.isMesh&&ch.material){
        const mats=Array.isArray(ch.material)?ch.material:[ch.material];
        mats.forEach(mt=>{mt.depthWrite=true;mt.side=THREE.FrontSide;});}});
    // Position at port dock ‚Äî rotated so bow faces along dock (parallel to shore)
    shipGroup.position.set(10,-0.5,-70);
    shipGroup.rotation.y=Math.PI/2+0.08;
    scene.add(shipGroup);
    addStatic(shipGroup,1);
    registerDestroyable(shipGroup,200,"ship");
    console.log('Ship loaded: length='+(b2.max.x-b2.min.x).toFixed(1)+' scaled='+sc.toFixed(3));
},undefined,e=>{
    console.warn('Ship GLB failed, placing fallback:',e);
    // Fallback: simple hull shape
    const fb=new THREE.Group();
    fb.add(new THREE.Mesh(new THREE.BoxGeometry(32,4.5,10),botw("#2a3a4a","#101820")));
    fb.children[0].position.y=2.25;
    fb.add(new THREE.Mesh(new THREE.BoxGeometry(8,6,7),botw("#e0dcd0","#808078")));
    fb.children[1].position.set(-8,7,0);
    fb.position.set(10,-1.5,-70);fb.rotation.y=.08;scene.add(fb);addStatic(fb,.3);
});

/* ====== SCIENCE PARK ====== */
function mkModern(x,z,h,w,d,color){const g=new THREE.Group();g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),botw(color));m.position.y=h/2;return m;})());
const wm=new THREE.MeshBasicMaterial({color:"#88b8dd",transparent:true,opacity:.6});
for(let fy=2;fy<h-1;fy+=2.2)for(let fx=-(w/2-.8);fx<w/2;fx+=1.6){g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.9,1.3),wm);m.position.set(fx,fy,d/2+.01);return m;})());g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.9,1.3),wm);m.position.set(fx,fy,-d/2-.01);m.rotation.y=Math.PI;return m;})());}
g.position.set(x,terrainHeight(x,z),z);scene.add(g);addStatic(g,.3);registerDestroyable(g,80,"building");return g;}
mkModern(62,20,10,5,4,"#9098b0");mkModern(68,-18,8,4,4,"#8090a8");mkModern(74,18,12,5,4,"#a0a8c0");mkModern(66,-20,7,4,3,"#8898b0");

/* ====== TECH HUB ====== */
function mkWarehouse(x,z,w,d,color){const g=new THREE.Group();g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(w,5,d),botw(color));m.position.y=2.5;return m;})());
g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(w*.35,3,.1),new THREE.MeshBasicMaterial({color:"#88aacc",transparent:true,opacity:.5}));m.position.set(0,2.5,d/2+.05);return m;})());
g.position.set(x,terrainHeight(x,z),z);scene.add(g);addStatic(g,.3);registerDestroyable(g,60,"building");return g;}
mkWarehouse(-64,18,8,6,"#a09888");mkWarehouse(-75,-14,6,5,"#90a090");mkWarehouse(-72,16,7,5,"#a0a898");mkWarehouse(-62,-16,7,5,"#988880");

/* ====== CREATIVE VILLAGE ====== */
function mkHouse(x,z,wallColor,sc){const g=new THREE.Group(),s=sc||1;
g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(3.8*s,3*s,3.2*s),botw(wallColor));m.position.y=1.5*s;return m;})());
g.add((()=>{const m=new THREE.Mesh(new THREE.ConeGeometry(3.2*s,2*s,4),botw("#8a5030","#4a2818"));m.position.y=4*s;m.rotation.y=Math.PI/4;return m;})());
g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.7*s,1.3*s,.1),botw("#5a3a20","#2a1a08"));m.position.set(0,.65*s,1.61*s);return m;})());
g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.4*s,1.2*s,.4*s),botw("#707078","#383840"));m.position.set(.8*s,4.6*s,-.5*s);return m;})());
for(const wx of[-.8,.8])for(const wy of[1.5,2.3])g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.4*s,.45*s),new THREE.MeshBasicMaterial({color:"#d8e0ff"}));m.position.set(wx*s,wy*s,1.61*s);return m;})());
g.position.set(x,terrainHeight(x,z),z);scene.add(g);addStatic(g,.2);registerDestroyable(g,40,"building");return g;}
const hCols=["#e8d8c0","#f0e8e0","#d0e0d0","#e0d0c0","#e8e0d8","#d8e0d8","#e0e0d0","#d8d0c0"];
// Houses placed clear of all roads: N-S(x=-8..8), W-conn(x=-42..-34), E-conn(x=34..42), Creative(z=44..56)
[[-52,34],[-28,34],[-16,34],[14,34],[26,34],[50,34],[-48,66],[-30,66],[-16,66],[16,66],[30,66],[48,66]].forEach(([x,z],i)=>mkHouse(x,z,hCols[i%hCols.length],.85+Math.random()*.3));
// Windmill
const windmill=new THREE.Group();windmill.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.9,1.3,8,10),botw("#d8d0c0","#8a8070"));m.position.y=4;return m;})());windmill.add((()=>{const m=new THREE.Mesh(new THREE.ConeGeometry(1.3,2.2,10),botw("#8a5030","#4a2818"));m.position.y=9.1;return m;})());
const bladeGroup=new THREE.Group();for(let i=0;i<4;i++){const bl=new THREE.Mesh(new THREE.BoxGeometry(.3,3.5,.05),botw("#d0c8b0","#706850"));bl.position.set(0,1.75,0);const pv=new THREE.Group();pv.add(bl);pv.rotation.z=i*Math.PI/2;bladeGroup.add(pv);}
bladeGroup.position.set(0,8,1.2);windmill.add(bladeGroup);windmill.position.set(42,terrainHeight(42,72),72);scene.add(windmill);addStatic(windmill,.5);registerDestroyable(windmill,50,"building");
// Garden props clear of roads
[[-24,36],[16,36],[28,36],[-18,66],[18,66],[44,66]].forEach(([x,z])=>{const cr=new THREE.Mesh(new THREE.BoxGeometry(.8,.8,.8),botw("#7a6040","#3a2818"));cr.position.set(x,.2+Math.max(terrainHeight(x,z),ROAD_Y),z);scene.add(cr);addDynamic(cr);});

/* ====== MOUNTAINS ====== */
const mtMats=[botw("#707078","#383840"),botw("#7a7a82","#404048"),botw("#686870","#303038")];
for(let i=0;i<30;i++){const a=(i/30)*Math.PI*2,r=150+Math.random()*35;const mt=new THREE.Mesh(new THREE.ConeGeometry(14+Math.random()*12,26+Math.random()*20,6),mtMats[i%3]);mt.position.set(Math.cos(a)*r,6,Math.sin(a)*r);mt.rotation.y=Math.random()*Math.PI;scene.add(mt);}

/* ====== GIF BILLBOARDS + PARKING BAYS ====== */
const interactables=[],billboards=[];
// GIF host: images at 0,0 in viewport (behind canvas) so browsers keep animating them
const gifHost=document.createElement("div");
gifHost.style.cssText="position:fixed;left:0;top:0;width:100vw;height:100vh;z-index:-100;pointer-events:none;opacity:0.01;overflow:hidden;";
document.body.appendChild(gifHost);
const pCv=document.createElement("canvas");pCv.width=64;pCv.height=64;const pCtx=pCv.getContext("2d");pCtx.fillStyle="#e8d060";pCtx.font="bold 48px sans-serif";pCtx.textAlign="center";pCtx.fillText("P",32,48);const pTex=new THREE.CanvasTexture(pCv);
const bayMat=new THREE.MeshBasicMaterial({color:"#e8d060"});const frameMat=botw("#1a1a20","#0a0a10");
const HAS_IMG_DEC='ImageDecoder' in window;
const gifData=ALL_PROJECTS.map(pr=>{
const cv=document.createElement("canvas");cv.width=512;cv.height=256;const ctx=cv.getContext("2d");
// Draw initial static poster
ctx.fillStyle="#0a0a14";ctx.fillRect(0,0,512,256);
const di=DISTRICTS[pr.district]||{color:"#888",label:"Project"};
ctx.fillStyle=di.color;ctx.font="bold 14px Segoe UI";ctx.fillText(di.label.toUpperCase(),20,30);
ctx.fillStyle="#fff";ctx.font="bold 22px Segoe UI";ctx.fillText(pr.t,20,65);
ctx.fillStyle="rgba(255,255,255,.4)";ctx.font="16px Segoe UI";ctx.fillText("\u25B6 Park to preview",20,100);
ctx.strokeStyle=di.color;ctx.lineWidth=3;ctx.strokeRect(2,2,508,252);
const tex=new THREE.CanvasTexture(cv);tex.colorSpace=THREE.SRGBColorSpace;
const url=`gifs/${pr.g}`;
const d={cv,ctx,tex,title:pr.t,district:pr.district,url,
    loaded:false,playing:false,_hasStatic:false,_failed:false,
    img:null,_dec:null,_fCount:0,_fIdx:0,_busy:false};
// 1) Fallback: <img> in viewport for browsers that animate visible GIFs
const img=new Image();img.crossOrigin="anonymous";img.src=url;
img.style.cssText="width:4px;height:2px;display:inline-block;";
gifHost.appendChild(img);d.img=img;
img.onload=()=>{if(!d.loaded){d.loaded=true;}};
img.onerror=()=>{d._failed=true;d.loaded=true;};
// 2) Primary: ImageDecoder API (Chrome/Edge) ‚Äî decodes GIF frames reliably
if(HAS_IMG_DEC){
    fetch(url).then(r=>{if(!r.ok)throw new Error(r.status);
        const dec=new ImageDecoder({data:r.body,type:'image/gif'});
        d._dec=dec;return dec.completed;
    }).then(()=>{
        d._fCount=d._dec.tracks.selectedTrack.frameCount;
        d.loaded=true;
    }).catch(()=>{d._dec=null;});}
return d;});

ALL_PROJECTS.forEach((pr,idx)=>{
    const g=new THREE.Group();const y=Math.max(terrainHeight(pr.wx,pr.wz),ROAD_Y)+.1;
    g.position.set(pr.wx,y,pr.wz);
    // Posts
    const pm=botw("#707078","#383840");
    const pl=new THREE.Mesh(new THREE.CylinderGeometry(.1,.14,5,8),pm);const pr2=pl.clone();
    pl.position.set(-1.8,2.5,0);pr2.position.set(1.8,2.5,0);g.add(pl,pr2);
    // Frame
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(5,2.2,.14),frameMat);m.position.y=4;return m;})());
    // Screen
    const bm=new THREE.MeshStandardMaterial({map:gifData[idx].tex,roughness:.3,metalness:.05,emissive:"#fff",emissiveMap:gifData[idx].tex,emissiveIntensity:.35});
    const bd=new THREE.Mesh(new THREE.BoxGeometry(4.8,2,.2),bm);bd.position.set(0,4,.02);bd.userData.project=pr;g.add(bd);
    // Click target
    const tr=new THREE.Mesh(new THREE.PlaneGeometry(5.2,2.3),new THREE.MeshBasicMaterial({transparent:true,opacity:0,depthWrite:false}));
    tr.position.set(0,4,.25);tr.userData.project=pr;g.add(tr);
    // Neon accent bars (Times Square feel on all billboards)
    const nc=DISTRICTS[pr.district].color;const nm=new THREE.MeshBasicMaterial({color:nc});
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(5.2,.12,.12),nm);m.position.set(0,5.05,.05);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(5.2,.12,.12),nm);m.position.set(0,2.95,.05);return m;})());
    // Parking bay (local +z = in front of screen)
    const bay=new THREE.Group();
    bay.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.14,4),bayMat);m.rotation.x=-Math.PI/2;m.position.set(-1.6,.03,3);return m;})());
    bay.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.14,4),bayMat);m.rotation.x=-Math.PI/2;m.position.set(1.6,.03,3);return m;})());
    bay.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(3.2,.14),bayMat);m.rotation.x=-Math.PI/2;m.position.set(0,.03,1);return m;})());
    bay.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.8,.8),new THREE.MeshBasicMaterial({map:pTex,transparent:true}));m.rotation.x=-Math.PI/2;m.position.set(0,.04,3);return m;})());
    g.add(bay);
    // Rotation: use direct rotation.y (no lookAt) ‚Äî guaranteed correct
    g.rotation.y=bbRot(pr);
    scene.add(g);interactables.push(bd,tr);
    // Compute bay world position from rotation
    const bayLocal=new THREE.Vector3(0,0,3);
    bayLocal.applyAxisAngle(new THREE.Vector3(0,1,0),g.rotation.y);
    const bayPos=g.position.clone().add(bayLocal);
    billboards.push({group:g,project:pr,boardMat:bm,bayPos,gifIdx:idx});
    registerDestroyable(g,20,"billboard");
});

/* ====== ARCADE INTERACTION FRAME ====== */
// Retro arcade-style indicator when parked near a billboard
const arcadeFrame=new THREE.Group();
// Glowing animated border
const arcGlowMat=new THREE.MeshBasicMaterial({color:"#00ff88",transparent:true,opacity:.8,side:THREE.DoubleSide});
const arcBars=[];
[{s:[5.6,.12,.06],p:[0,5.15,0]},{s:[5.6,.12,.06],p:[0,2.85,0]},{s:[.12,2.42,.06],p:[-2.8,4,0]},{s:[.12,2.42,.06],p:[2.8,4,0]}].forEach(({s,p})=>{
    const b=new THREE.Mesh(new THREE.BoxGeometry(...s),arcGlowMat.clone());b.position.set(...p);arcadeFrame.add(b);arcBars.push(b);});
// Corner chevrons
const chevGeo=new THREE.BufferGeometry();chevGeo.setAttribute("position",new THREE.BufferAttribute(new Float32Array([0,0,0,.4,0,0,0,.4,0]),3));chevGeo.setIndex([0,1,2]);
const chevMat=new THREE.MeshBasicMaterial({color:"#ffcc00",transparent:true,opacity:.9,side:THREE.DoubleSide});
[[-2.9,5.25,1,1],[-2.9,2.75,1,-1],[2.9,5.25,-1,1],[2.9,2.75,-1,-1]].forEach(([x,y,sx,sy])=>{
    const c=new THREE.Mesh(chevGeo,chevMat.clone());c.position.set(x,y,.08);c.scale.set(sx,sy,1);arcadeFrame.add(c);});
// "PRESS E" floating text
const pressCv=document.createElement("canvas");pressCv.width=256;pressCv.height=64;
const pressCtx=pressCv.getContext("2d");
const pressTex=new THREE.CanvasTexture(pressCv);pressTex.colorSpace=THREE.SRGBColorSpace;
const pressPlane=new THREE.Mesh(new THREE.PlaneGeometry(2.8,.7),new THREE.MeshBasicMaterial({map:pressTex,transparent:true,depthWrite:false,side:THREE.DoubleSide}));
pressPlane.position.set(0,6,.1);arcadeFrame.add(pressPlane);
// Coin-slot arrows pointing down at billboard
const coinArrowGeo=new THREE.ConeGeometry(.18,.5,4);
const coinMat=new THREE.MeshBasicMaterial({color:"#ffcc00",transparent:true,opacity:.85});
const coinArr=[];
for(let i=-1;i<=1;i++){const a=new THREE.Mesh(coinArrowGeo,coinMat.clone());a.position.set(i*1.8,5.8,.1);a.rotation.z=Math.PI;arcadeFrame.add(a);coinArr.push(a);}
arcadeFrame.visible=false;scene.add(arcadeFrame);
// Arcade frame update function (called in game loop)
let arcadeBB=null,arcadeT=0;
function updateArcade(t,dt,active,bb){
    if(!active){arcadeFrame.visible=false;arcadeBB=null;return;}
    if(bb!==arcadeBB){arcadeBB=bb;arcadeT=t;audio.chime(660,.06);setTimeout(()=>audio.chime(880,.05),80);}
    arcadeFrame.visible=true;
    arcadeFrame.position.copy(bb.group.position);arcadeFrame.rotation.y=bb.group.rotation.y;
    const elapsed=t-arcadeT,pulse=Math.sin(t*8)*.5+.5,slowP=Math.sin(t*3)*.5+.5;
    // Pulsing glow border
    arcBars.forEach(b=>{b.material.opacity=.4+pulse*.6;b.material.color.setHSL(.38-pulse*.06,1,.55+pulse*.15);});
    // Bouncing coin arrows
    coinArr.forEach((a,i)=>{a.position.y=5.6+Math.sin(t*6+i*1.2)*.25;a.material.opacity=.5+slowP*.5;});
    // Animated "PRESS E" text
    const pc=pressCtx;pc.clearRect(0,0,256,64);
    // Scanline background
    pc.fillStyle=`rgba(0,${Math.floor(40+pulse*30)},${Math.floor(20+pulse*15)},.85)`;
    pc.fillRect(0,0,256,64);
    for(let y=0;y<64;y+=3){pc.fillStyle=`rgba(0,0,0,${.15+Math.sin(y*.5+t*12)*.05})`;pc.fillRect(0,y,256,1);}
    // Border
    pc.strokeStyle=`hsl(${140+pulse*20},100%,${55+pulse*15}%)`;pc.lineWidth=3;pc.strokeRect(2,2,252,60);
    // Text
    const blink=Math.sin(t*4)>.1;
    if(blink||elapsed<1){
        pc.fillStyle="#ffcc00";pc.font="bold 28px 'Courier New',monospace";pc.textAlign="center";pc.textBaseline="middle";
        // Glitch offset
        const gx=Math.sin(t*47)*.8,gy=Math.cos(t*31)*.4;
        pc.fillText("INSERT COIN",128+gx,28+gy);
        pc.fillStyle=`rgba(0,255,136,${.6+slowP*.4})`;pc.font="bold 16px 'Courier New',monospace";
        pc.fillText("[ PRESS E ]",128,52);
    }
    pressTex.needsUpdate=true;
}

/* ====== COLLECTIBLES ====== */
const orbs=[];
for(let i=0;i<15;i++){let ox,oz;do{ox=(Math.random()-.5)*260;oz=(Math.random()-.5)*260;}while(roadDist(ox,oz)<3||oz<-48);const oy=terrainHeight(ox,oz);if(oy<-.3){i--;continue;}const o=new THREE.Mesh(new THREE.IcosahedronGeometry(.5,1),new THREE.MeshStandardMaterial({color:"#60ffc0",emissive:"#1a6a50",emissiveIntensity:1.2}));o.position.set(ox,oy+1.8,oz);o.userData.id=`o${i}`;scene.add(o);orbs.push(o);}
// Direction arrow removed (user request) ‚Äî minimap compass replaces it

/* ====== CAR ====== */
// Procedural fallback while GLB loads
function createFallbackCar(){const body=new THREE.Group();const p=new THREE.MeshMatcapMaterial({matcap:MC.red}),tr=new THREE.MeshMatcapMaterial({matcap:MC.dark}),gl=new THREE.MeshMatcapMaterial({matcap:MC.glass});
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(3.6,.55,1.8),p);m.position.y=.68;return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(1.3,.18,1.76),p);m.position.set(1.05,.98,0);return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(1.48,.5,1.4),gl);m.position.set(-.28,1.2,0);return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(1.1,.36,1.66),p);m.position.set(-1.28,1,0);return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(3.7,.1,1.92),tr);m.position.y=.42;return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.12,.14,.48),new THREE.MeshBasicMaterial({color:"#fff8e0"}));m.position.set(1.84,.87,.54);return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.12,.14,.48),new THREE.MeshBasicMaterial({color:"#fff8e0"}));m.position.set(1.84,.87,-.54);return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.1,.16,.38),new THREE.MeshBasicMaterial({color:"#ff5050"}));m.position.set(-1.84,.85,.5);return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.1,.16,.38),new THREE.MeshBasicMaterial({color:"#ff5050"}));m.position.set(-1.84,.85,-.5);return m;})());
const wG=new THREE.CylinderGeometry(.35,.35,.3,18),wM=new THREE.MeshMatcapMaterial({matcap:MC.dark}),wheels=[];
[[1.08,.35,.84],[1.08,.35,-.84],[-1.06,.35,.84],[-1.06,.35,-.84]].forEach(([x,y,z])=>{const wh=new THREE.Mesh(wG,wM);wh.rotation.z=Math.PI/2;wh.position.set(x,y,z);body.add(wh);wheels.push(wh);});
body.rotation.y=Math.PI/2;return{group:body,wheels};}
const car=new THREE.Group();car.position.set(0,ROAD_Y,18);scene.add(car); // start on N-S road, north of fountain
const fb=createFallbackCar();car.add(fb.group);car.userData.wheels=fb.wheels;
// Shared vertex-accurate bounds helper
const _bv=new THREE.Vector3();
function realBounds(root,visibleOnly){root.updateMatrixWorld(true);const mn=new THREE.Vector3(1e9,1e9,1e9),mx=new THREE.Vector3(-1e9,-1e9,-1e9);
root.traverse(c=>{if(!c.isMesh||!c.geometry)return;if(visibleOnly&&!c.visible)return;const p=c.geometry.attributes.position;
    for(let i=0;i<p.count;i++){_bv.fromBufferAttribute(p,i).applyMatrix4(c.matrixWorld);mn.min(_bv);mx.max(_bv);}});return{min:mn,max:mx};}

let carShadowW=3.8,carShadowD=1.8;
const carShadow=new THREE.Mesh(new THREE.PlaneGeometry(1,1),new THREE.MeshBasicMaterial({color:"#000",transparent:true,opacity:.22,depthWrite:false}));carShadow.rotation.x=-Math.PI/2;carShadow.scale.set(carShadowW,carShadowD,1);scene.add(carShadow);
// Car models registry (used for initial load + garage swap)
const CAR_MODELS={
    mazda:{path:"models/mazda_rx-7_fd.glb",name:"Mazda RX-7 FD",desc:"Classic JDM icon",rotY:Math.PI,targetSize:4.0},
    sport:{path:"models/cars2/low-poly_pixelated_sport_car.glb",name:"Sport Car",desc:"Pixelated speed demon",rotY:Math.PI,targetSize:5.5}
};
// Load initial car from saved activeCar (or default mazda)
{const _initCar=CAR_MODELS[state.activeCar]||CAR_MODELS.mazda;
const _initRotY=_initCar.rotY;
new GLTFLoader().load(_initCar.path,gltf=>{
    const m=gltf.scene;
    let b=realBounds(m);
    const rawW=b.max.x-b.min.x,rawD=b.max.z-b.min.z;
    const sc=(_initCar.targetSize||4.0)/Math.max(rawW,rawD);
    m.scale.setScalar(sc);
    m.updateMatrixWorld(true);
    m.traverse(ch=>{
        if(!ch.isMesh)return;
        const chn=ch.name.toLowerCase();
        // Hide colliders, ground planes, shadow planes, and environment meshes by name
        if(chn.includes('collider')||chn.includes('ground')||chn.includes('floor')||chn.includes('shadow_plane')||chn.includes('road')||chn.includes('asphalt')||chn.includes('parking')){ch.visible=false;return;}
        // Detect ground planes in WORLD space: flat in Y but large in XZ
        const wb=new THREE.Box3().setFromObject(ch);
        const wh=wb.max.y-wb.min.y, ww=wb.max.x-wb.min.x, wd=wb.max.z-wb.min.z;
        const area=ww*wd;
        if(wh<0.05&&area>4){ch.visible=false;return;} // world-flat + large area = ground
        const mats=Array.isArray(ch.material)?ch.material:[ch.material];
        mats.forEach(mt=>{
            mt.depthWrite=true;
            const nm=(mt.name||'').toLowerCase()+chn;
            if(nm.includes('glass')||nm.includes('window')||nm.includes('transparent')){
                mt.transparent=true;mt.opacity=0.3;mt.side=THREE.FrontSide;
            }else{
                mt.transparent=false;mt.opacity=1;mt.side=THREE.FrontSide;
            }});});
    const wrap=new THREE.Group();wrap.add(m);
    wrap.rotation.y=_initRotY;
    car.remove(fb.group);car.add(wrap);
    // Reset car to origin, measure, center the model, then restore
    const savedPos=car.position.clone();
    const savedRot=car.rotation.y;
    car.position.set(0,0,0);car.rotation.y=0;
    wrap.position.set(0,0,0);
    car.updateMatrixWorld(true);
    b=realBounds(car);
    const cxW=(b.min.x+b.max.x)/2, czW=(b.min.z+b.max.z)/2;
    wrap.position.y=-b.min.y;
    wrap.position.x=-cxW;
    wrap.position.z=-czW;
    // Shadow sized from visible-only bounds
    const vb=realBounds(car,true);
    carShadowW=Math.min((vb.max.x-vb.min.x)*1.05,6);carShadowD=Math.min((vb.max.z-vb.min.z)*1.05,3);
    // Restore car position/rotation
    car.position.copy(savedPos);car.rotation.y=savedRot;
    const wh=[];m.traverse(c=>{if(c.isMesh){const n=c.name.toLowerCase();if(n.includes('wheel')||n.includes('tire')||n.includes('rim'))wh.push(c);}});
    car.userData.wheels=wh;
    console.log(`Initial car (${state.activeCar}) loaded`);
},undefined,e=>{console.warn('Initial car GLB load failed, using fallback:',e);});
}

/* ====== AVATAR (GLB: low_poly_man) ====== */
const avatar=new THREE.Group();
avatar.visible=false;
avatar.userData={walkTime:0,mixer:null,idleAction:null,walkAction:null};
scene.add(avatar);
// Load avatar GLB/GLTF ‚Äî use Box3 for reliable sizing
new GLTFLoader().load('models/person1/scene.gltf',gltf=>{
    const m=gltf.scene;
    // Reset root transform
    m.position.set(0,0,0);m.rotation.set(0,0,0);m.scale.set(1,1,1);
    m.updateMatrixWorld(true);
    // Measure with Box3
    const box=new THREE.Box3().setFromObject(m);
    const size=new THREE.Vector3();box.getSize(size);
    console.log('Avatar raw size:',size.x.toFixed(2),size.y.toFixed(2),size.z.toFixed(2));
    // Scale so height = 1.7 units (human-sized)
    const TARGET_H=1.7;
    const sc=TARGET_H/Math.max(size.y,.01);
    m.scale.setScalar(sc);
    m.updateMatrixWorld(true);
    const box2=new THREE.Box3().setFromObject(m);
    const center2=new THREE.Vector3();box2.getCenter(center2);
    // Center horizontally and ground vertically
    m.position.x-=center2.x;
    m.position.z-=center2.z;
    m.position.y-=box2.min.y; // feet on ground
    // Wrap in sub-group rotated 180¬∞ so model faces -Z (Three.js forward)
    const avatarWrap=new THREE.Group();
    avatarWrap.rotation.y=Math.PI;
    avatarWrap.add(m);
    m.traverse(ch=>{if(ch.isMesh){const mats=Array.isArray(ch.material)?ch.material:[ch.material];mats.forEach(mt=>{mt.side=THREE.FrontSide;});}});
    avatar.add(avatarWrap);
    console.log('Avatar scaled: height='+TARGET_H+' sc='+sc.toFixed(4));
    // Animation mixer ‚Äî this model has "Take 001" which is the walking animation
    if(gltf.animations&&gltf.animations.length){
        avatar.userData.mixer=new THREE.AnimationMixer(m);
        const clips=gltf.animations;
        console.log('Avatar animations:',clips.map(a=>a.name));
        // Find walk animation ‚Äî could be named "Take 001", "walk", "run", or just the first clip
        const walkClip=clips.find(a=>/walk|run/i.test(a.name))||clips[0];
        const idleClip=clips.find(a=>/idle|stand/i.test(a.name));
        if(walkClip){
            avatar.userData.walkAction=avatar.userData.mixer.clipAction(walkClip);
            // Start with walk paused at frame 0 (acts as idle pose)
            avatar.userData.walkAction.play();
            avatar.userData.walkAction.paused=true;
        }
        if(idleClip){
            avatar.userData.idleAction=avatar.userData.mixer.clipAction(idleClip);
            avatar.userData.idleAction.play();
        }
    }
},undefined,e=>{
    console.warn('Avatar GLB failed, using fallback:',e);
    const skinMat=botw("#e8c8a0","#b09070"),shirtMat=botw("#4080b0","#284060"),pantsMat=botw("#384858","#1a2830");
    const torso=new THREE.Mesh(new THREE.BoxGeometry(.48,.55,.28),shirtMat);torso.position.y=1.05;avatar.add(torso);
    const head=new THREE.Mesh(new THREE.SphereGeometry(.18,8,6),skinMat);head.position.y=1.55;avatar.add(head);
    const legGeo=new THREE.BoxGeometry(.14,.46,.14);
    const lLeg=new THREE.Mesh(legGeo,pantsMat);lLeg.position.set(.11,.36,0);avatar.add(lLeg);
    const rLeg=new THREE.Mesh(legGeo,pantsMat);rLeg.position.set(-.11,.36,0);avatar.add(rLeg);
    avatar.userData._fallback=true;avatar.userData.lLeg=lLeg;avatar.userData.rLeg=rLeg;
});

/* ====== NPC QUEST GIVER (GLB: wizard) ====== */
function makeIconSprite(text,color){
    const cv=document.createElement("canvas");cv.width=128;cv.height=128;
    const c=cv.getContext("2d");
    c.clearRect(0,0,128,128);
    // Drop shadow
    c.shadowColor="rgba(0,0,0,.6)";c.shadowBlur=8;c.shadowOffsetY=3;
    // Bold text only ‚Äî no circle background
    c.fillStyle=color;
    c.font="bold 100px sans-serif";
    c.textAlign="center";c.textBaseline="middle";
    c.fillText(text,64,58);
    // White outline for readability
    c.shadowColor="transparent";
    c.strokeStyle="#fff";c.lineWidth=4;
    c.strokeText(text,64,58);
    const tex=new THREE.CanvasTexture(cv);tex.premultiplyAlpha=true;
    const mat=new THREE.SpriteMaterial({map:tex,transparent:true,depthTest:false,sizeAttenuation:true});
    const sp=new THREE.Sprite(mat);sp.scale.set(1.6,1.6,1);
    return sp;
}
const npcGuide=new THREE.Group();
const _npcIconGroup=new THREE.Group();_npcIconGroup.position.y=3.2;
const _iconExclaim=makeIconSprite("!","#ffd700");
const _iconQReady=makeIconSprite("?","#ffd700");
const _iconQActive=makeIconSprite("?","#999999");
_npcIconGroup.add(_iconExclaim,_iconQReady,_iconQActive);
_iconQReady.visible=false;_iconQActive.visible=false;
npcGuide.add(_npcIconGroup);
const _npcNy=Math.max(terrainHeight(6,-5),ROAD_Y);
npcGuide.position.set(6,_npcNy,-5);
// Wizard wander waypoints ‚Äî roams across the entire map, staying off roads
// Town center, Port District (south), Science Park (east), Tech District (west), Creative (north)
const _wizWaypoints=[
    [6,-5],[15,10],[-12,8],               // town center area
    [25,20],[35,25],[50,15],[55,30],       // east (Science Park)
    [40,45],[20,50],[30,62],               // northeast (Creative)
    [-15,42],[-30,45],[-50,55],[-45,35],   // northwest (Creative)
    [-55,20],[-50,10],[-45,-15],[-55,-25], // west (Tech District)
    [-40,-35],[-25,-45],[-50,-48],         // southwest (Port)
    [-15,-55],[15,-50],[35,-45],[50,-35],   // south (Port)
    [45,-20],[30,-15],[15,-10],            // back toward center
];
npcGuide.userData={id:"guide",name:"The Wizard",iconGroup:_npcIconGroup,iconExclaim:_iconExclaim,iconQReady:_iconQReady,iconQActive:_iconQActive,baseY:_npcNy,mixer:null,
    // Wander state
    wpIdx:0,wpPause:2,wanderSpeed:2.5,isIdle:true,idleTimer:3+Math.random()*2,
    walkAction:null,idleAction:null};
scene.add(npcGuide);
// Don't add static collider ‚Äî wizard moves around now
// Load wizard GLB for NPC
new GLTFLoader().load('models/questGiver/low_poly_wizard_rigged.glb',gltf=>{
    const m=gltf.scene;
    m.position.set(0,0,0);m.rotation.set(0,0,0);m.scale.set(1,1,1);
    m.updateMatrixWorld(true);
    const box=new THREE.Box3().setFromObject(m);
    const size=new THREE.Vector3();box.getSize(size);
    const center=new THREE.Vector3();box.getCenter(center);
    console.log('NPC wizard raw size:',size.x.toFixed(2),size.y.toFixed(2),size.z.toFixed(2));
    const TARGET_H=2.0;
    const sc=TARGET_H/Math.max(size.y,.01);
    m.scale.setScalar(sc);
    m.updateMatrixWorld(true);
    const box2=new THREE.Box3().setFromObject(m);
    const center2=new THREE.Vector3();box2.getCenter(center2);
    m.position.x-=center2.x;
    m.position.z-=center2.z;
    m.position.y-=box2.min.y;
    m.traverse(ch=>{if(ch.isMesh){const mats=Array.isArray(ch.material)?ch.material:[ch.material];mats.forEach(mt=>{mt.side=THREE.FrontSide;});}});
    npcGuide.add(m);
    // Position icon clearly above the wizard's head
    const finalTop=(box2.max.y-box2.min.y)*sc; // scaled height
    _npcIconGroup.position.y=TARGET_H+0.8; // just above scaled wizard top
    console.log('NPC wizard loaded, finalTop='+finalTop.toFixed(2)+', icon at y='+_npcIconGroup.position.y.toFixed(2));
    // Animation mixer ‚Äî track idle & walk actions for wandering
    if(gltf.animations&&gltf.animations.length){
        npcGuide.userData.mixer=new THREE.AnimationMixer(m);
        const clips=gltf.animations;
        const idleClip=clips.find(a=>/idle/i.test(a.name))||clips[0];
        const walkClip=clips.find(a=>/walk|run|move/i.test(a.name));
        if(idleClip){
            npcGuide.userData.idleAction=npcGuide.userData.mixer.clipAction(idleClip);
            npcGuide.userData.idleAction.play();
        }
        if(walkClip){
            npcGuide.userData.walkAction=npcGuide.userData.mixer.clipAction(walkClip);
            npcGuide.userData.walkAction.setEffectiveWeight(0);
            npcGuide.userData.walkAction.play();
        }
    }
    console.log('NPC loaded: wizard, animations:',gltf.animations.map(a=>a.name));
},undefined,e=>{
    console.warn('NPC wizard GLB failed, using fallback:',e);
    const robeMat=botw("#c06830","#704018"),skinMat=botw("#e8c8a0","#b09070"),hatMat=botw("#a05828","#603010");
    const robe=new THREE.Mesh(new THREE.CylinderGeometry(.22,.32,.9,8),robeMat);robe.position.y=.65;npcGuide.add(robe);
    const npcHead=new THREE.Mesh(new THREE.SphereGeometry(.2,8,6),skinMat);npcHead.position.y=1.45;npcGuide.add(npcHead);
    const hat=new THREE.Mesh(new THREE.ConeGeometry(.25,.3,8),hatMat);hat.position.y=1.75;npcGuide.add(hat);
});

/* ====== DIALOG SYSTEM ====== */
const dialogEl=document.getElementById("dialog"),dialogNpc=document.getElementById("dialog-npc"),
      dialogTitle=document.getElementById("dialog-title"),dialogText=document.getElementById("dialog-text"),
      dialogProgress=document.getElementById("dialog-progress"),dialogBtns=document.getElementById("dialog-btns"),
      garageOverlay=document.getElementById("garage-overlay"),
      modeBadge=document.getElementById("mode-badge"),
      questTracker=document.getElementById("quest-tracker"),qtTitle=document.getElementById("qt-title"),
      qtObj=document.getElementById("qt-obj"),qtChecklist=document.getElementById("qt-checklist"),
      questFanfare=document.getElementById("quest-fanfare"),qfSub=document.getElementById("qf-sub"),
      qfReward=document.getElementById("qf-reward"),qfParticles=document.getElementById("qf-particles");

// Track which specific billboards have been visited for checklist
let _lastChecklistSize=0;

function showDialog(npc){
    if(state.gunEquipped)holsterGun();
    // Unlock prerequisite quests
    QUESTS.forEach(q=>{if(q.prerequisite&&q.status==="locked"){
        const pre=QUESTS.find(p=>p.id===q.prerequisite);
        if(pre&&pre.status==="done")q.status="available";
    }});
    const q=QUESTS.find(q=>q.giver===npc.userData.id&&(q.status==="available"||q.status==="active"||q.status==="complete"));
    state.mode="dialog";
    dialogNpc.textContent=npc.userData.name;
    if(!q){
        dialogTitle.textContent="Greetings, traveller!";
        dialogText.textContent="I have no more tasks for you. May your journey be filled with discovery!";
        dialogProgress.textContent="";
        dialogBtns.innerHTML=`<button class="dialog-btn" onclick="window._closeDialog()">Farewell</button>`;
    }else if(q.status==="available"){
        dialogTitle.textContent=q.title;
        dialogText.textContent=q.desc;
        dialogProgress.textContent="";
        dialogBtns.innerHTML=`<button class="dialog-btn primary" onclick="window._acceptQuest('${q.id}')">Accept Quest</button><button class="dialog-btn" onclick="window._closeDialog()">Not yet</button>`;
    }else if(q.status==="active"){
        dialogTitle.textContent=q.title;
        if(q.id==="hotlap"){
            dialogText.textContent="The checkpoint gates await! Get in your car and drive through them in order.";
            dialogProgress.textContent=`Progress: ${state.gatesHit} / ${state.totalGates} gates`;
        }else{
            dialogText.textContent="Your task remains unfinished. Continue exploring the city and visit the project billboards!";
            dialogProgress.textContent=`Progress: ${Math.min(state.visited.size,5)} / 5 billboards visited`;
        }
        dialogBtns.innerHTML=`<button class="dialog-btn" onclick="window._closeDialog()">I shall continue</button>`;
    }else if(q.status==="complete"){
        dialogTitle.textContent="Quest Complete!";
        if(q.id==="hotlap"){
            dialogText.textContent="Incredible driving! You've mastered every corner of this city. As promised, here's something... powerful. Use it wisely, mortal.";
        }else{
            dialogText.textContent="Excellent work, traveller! You've proven your dedication by exploring the city. Accept this reward ‚Äî a fine vehicle awaits you!";
        }
        dialogProgress.textContent="";
        dialogBtns.innerHTML=`<button class="dialog-btn primary" onclick="window._completeQuest('${q.id}')">Claim Reward</button>`;
    }
    dialogEl.classList.add("show");
    _mouseDragging=false;
    updateModeBadge();
}
window._closeDialog=function(){
    dialogEl.classList.remove("show");
    state.mode="walking";
    updateModeBadge();
};
window._acceptQuest=function(id){
    const q=QUESTS.find(q=>q.id===id);
    if(q){
        q.status="active";showToast("Quest accepted: "+q.title);
        if(id==="scout")_lastChecklistSize=state.visited.size;
        if(id==="hotlap"){spawnGates();state.hotlapActive=true;showToast("Drive through the gates in order! Get in your car.");}
    }
    dialogEl.classList.remove("show");
    state.mode="walking";
    updateModeBadge();updateQuestTracker();updateNPCIcon();
};
window._completeQuest=function(id){
    const q=QUESTS.find(q=>q.id===id);
    if(q){q.status="done";q.reward();}
    dialogEl.classList.remove("show");
    state.mode="walking";
    updateModeBadge();updateQuestTracker();updateNPCIcon();
    // Fanfare animation!
    showQuestFanfare(q);
    if(id==="hotlap"){
        removeGates();
        qfReward.textContent="SMG unlocked! Press 1 while on foot to equip it.";
        setTimeout(()=>showToast("SMG unlocked! Press 1 while on foot to equip."),5000);
    }else if(state.unlockedCars.length>1){
        setTimeout(()=>showToast("New car added to your garage! Press G to open it."),5000);
    }
};
function showQuestFanfare(q){
    qfSub.textContent=q?q.title:"Quest Complete";
    qfReward.textContent=q?q.rewardText:"Reward claimed!";
    // Spawn particles
    qfParticles.innerHTML="";
    const colors=["#ffd700","#ff6b35","#ff3366","#33ccff","#6eff6e","#cc66ff"];
    for(let i=0;i<40;i++){
        const p=document.createElement("div");p.className="qf-particle";
        p.style.left=Math.random()*100+"%";
        p.style.top=40+Math.random()*30+"%";
        p.style.background=colors[Math.floor(Math.random()*colors.length)];
        p.style.width=p.style.height=(4+Math.random()*8)+"px";
        p.style.animationDelay=Math.random()*.8+"s";
        p.style.animationDuration=(1.5+Math.random()*1)+"s";
        qfParticles.appendChild(p);
    }
    questFanfare.classList.add("show");
    // Fanfare audio
    audio.chime(523,.15);setTimeout(()=>audio.chime(659,.15),200);
    setTimeout(()=>audio.chime(784,.15),400);setTimeout(()=>audio.chime(1047,.25),600);
    // Auto-dismiss
    setTimeout(()=>{questFanfare.classList.remove("show");},4500);
}
const objBanner=document.getElementById("obj-complete-banner"),
      ocbTitle=document.getElementById("ocb-title"),
      ocbSub=document.getElementById("ocb-sub");
function showObjectiveCompleteFanfare(q){
    ocbTitle.textContent="Objectives Complete!";
    ocbSub.textContent="Return to "+npcGuide.userData.name+" to claim your reward";
    objBanner.classList.add("show");
    // Triumphant chime sequence
    audio.chime(440,.12);setTimeout(()=>audio.chime(554,.12),150);
    setTimeout(()=>audio.chime(659,.15),300);setTimeout(()=>audio.chime(880,.2),500);
    // Auto-dismiss after 6 seconds
    setTimeout(()=>{objBanner.classList.remove("show");},6000);
}
// Also show objective-complete reminder when user tabs back to the page
document.addEventListener("visibilitychange",()=>{
    if(!document.hidden){
        const cq=QUESTS.find(q=>q.status==="complete");
        if(cq){
            // Re-show the banner if quest objectives are done but reward not claimed
            showObjectiveCompleteFanfare(cq);
        }
    }
});
function updateModeBadge(){
    if(state.mode==="walking"&&state.gunEquipped){modeBadge.textContent="COMBAT ‚Äî LMB fire ¬∑ 1 holster ¬∑ WASD move";modeBadge.className="mode-badge show walk";}
    else if(state.mode==="walking"){modeBadge.textContent="On Foot ‚Äî F enter car ¬∑ G garage ¬∑ Hold LMB to look ¬∑ E talk"+(state.hasGun?" ¬∑ 1 equip SMG":"");modeBadge.className="mode-badge show walk";}
    else if(state.mode==="dialog"){modeBadge.textContent="Talking";modeBadge.className="mode-badge show dialog";}
    else{modeBadge.className="mode-badge";}
}
function updateQuestTracker(){
    const q=QUESTS.find(q=>q.status==="active");
    if(!q){questTracker.classList.remove("show");return;}
    qtTitle.textContent=q.title;
    qtObj.textContent=q.objectiveText;
    qtChecklist.innerHTML="";
    if(q.id==="hotlap"){
        // Gate checklist for hot lap
        for(let i=0;i<state.totalGates;i++){
            const done=i<state.gatesHit;
            const item=document.createElement("div");
            item.className="check-item"+(done?" done":"");
            item.innerHTML=`<span class="ck">${done?"‚úì":""}</span><span>Gate ${i+1}</span>`;
            qtChecklist.appendChild(item);
        }
    }else{
        // Billboard checklist for scout
        const visited=Array.from(state.visited);
        const needed=5;
        for(let i=0;i<needed;i++){
            const done=i<visited.length;
            const item=document.createElement("div");
            item.className="check-item"+(done?" done":"");
            const name=done?visited[i]:"Billboard "+(i+1);
            item.innerHTML=`<span class="ck">${done?"‚úì":""}</span><span>${name}</span>`;
            qtChecklist.appendChild(item);
        }
        // Check if new billboard visited ‚Äî show feedback toast
        if(state.visited.size>_lastChecklistSize&&_lastChecklistSize>0){
            const ct=Math.min(state.visited.size,5);
            showToast(`‚úì Billboard visited! (${ct}/5)`);
            audio.chime(700,.06);
            _lastChecklistSize=state.visited.size;
        }
    }
    questTracker.classList.add("show");
}
function updateNPCIcon(){
    // Unlock prerequisite quests
    QUESTS.forEach(q=>{if(q.prerequisite&&q.status==="locked"){
        const pre=QUESTS.find(p=>p.id===q.prerequisite);
        if(pre&&pre.status==="done")q.status="available";
    }});
    const q=QUESTS.find(q=>q.giver==="guide"&&(q.status==="available"||q.status==="active"||q.status==="complete"));
    const d=npcGuide.userData;
    d.iconExclaim.visible=false;d.iconQReady.visible=false;d.iconQActive.visible=false;
    if(!q)return;
    if(q.status==="available")d.iconExclaim.visible=true;
    else if(q.status==="active")d.iconQActive.visible=true;
    else if(q.status==="complete")d.iconQReady.visible=true;
}
updateNPCIcon();

/* ====== NPC SPEECH BUBBLES ====== */
const speechBubble=document.getElementById("speech-bubble");
const NPC_JOKES=[
    "I used to be an adventurer like you... then I took a bug to the codebase.",
    "Why do programmers prefer dark mode? Because light attracts bugs!",
    "A wizard is never late. He deploys precisely when he means to.",
    "I put a spell on your portfolio... it's called CSS.",
    "How many wizards does it take to change a lightbulb? None ‚Äî we use dark mode.",
    "My other staff is a mechanical keyboard.",
    "I cast Fireball... at the production server. It was very effective.",
    "They say magic isn't real. They haven't seen a well-crafted regex.",
    "I once turned a developer into a frog. He said it was a better job.",
    "The secret to good code? A pinch of logic, a dash of coffee, and a wizard's hat.",
    "Fun fact: I've been standing here for 3000 frames. My feet hurt.",
    "Did you know? Every billboard you visit makes me slightly happier.",
    "The fountain? That was me. Accidentally cast Water Bolt indoors.",
    "Don't tell the NPCs, but I control the weather here. Sorry about winter.",
    "If you crash enough cars, I might promote you to chaos wizard.",
    "My robe is +5 to charisma. Can't you tell?",
    "I have a quest for you! ...Oh wait, you haven't talked to me yet.",
    "Between you and me, the Sport Car handles like a dream.",
    "I've been a quest giver for 47 years. The dental plan is terrible.",
    "Legend has it, if you visit all the billboards, something magical happens...",
    "Why did the variable go to therapy? It had too many issues.",
    "My wizard school was mostly git merge conflicts.",
    "They wanted me to be a final boss, but I negotiated down to quest giver.",
    "Is it just me, or does this city have a lot of parking bays?",
];
let _jokeIdx=Math.floor(Math.random()*NPC_JOKES.length);
let _jokeTimer=0,_jokeShow=0;
const JOKE_INTERVAL=8; // seconds between jokes
const JOKE_DISPLAY=5;  // how long each joke stays visible

function updateSpeechBubble(t,dt){
    if(state.mode==="dialog"){speechBubble.classList.remove("show");return;}
    _jokeTimer+=dt;
    if(_jokeTimer>=JOKE_INTERVAL){
        _jokeTimer=0;_jokeShow=JOKE_DISPLAY;
        speechBubble.textContent=NPC_JOKES[_jokeIdx];
        _jokeIdx=(_jokeIdx+1)%NPC_JOKES.length;
        speechBubble.classList.add("show");
    }
    if(_jokeShow>0){
        _jokeShow-=dt;
        // Project NPC head position to screen
        const headPos=npcGuide.position.clone();
        headPos.y+=2.6; // above head
        const screenPos=headPos.project(camera);
        const hw=window.innerWidth/2,hh=window.innerHeight/2;
        const sx=(screenPos.x*hw)+hw;
        const sy=-(screenPos.y*hh)+hh;
        // Only show if NPC is in front of camera and on screen
        if(screenPos.z>0&&screenPos.z<1&&sx>-50&&sx<window.innerWidth+50&&sy>-50&&sy<window.innerHeight+50){
            speechBubble.style.left=sx+"px";
            speechBubble.style.top=(sy-20)+"px";
        }else{
            speechBubble.classList.remove("show");
        }
        if(_jokeShow<=0)speechBubble.classList.remove("show");
    }
}

/* ====== SMG GUN + COMBAT SYSTEM ====== */
const crosshairEl=document.getElementById("crosshair"),
      gunHudEl=document.getElementById("gun-hud"),
      deathScreen=document.getElementById("death-screen"),
      deathTitle=document.getElementById("death-title"),
      deathSub=document.getElementById("death-sub"),
      hpBar=document.getElementById("hp-bar"),
      hpFill=document.getElementById("hp-fill"),
      muzzleFlashEl=document.getElementById("muzzle-flash");

// Build SMG mesh ‚Äî gun pivots for pitch aiming
const gunPivot=new THREE.Group(); // this group rotates for pitch (aims up/down)
const gunGroup=new THREE.Group(); // inner group holds the gun mesh
const _gunMats={body:new THREE.MeshStandardMaterial({color:"#2a2a30",roughness:.6,metalness:.7}),
    barrel:new THREE.MeshStandardMaterial({color:"#1a1a20",roughness:.4,metalness:.9}),
    mag:new THREE.MeshStandardMaterial({color:"#3a3020",roughness:.7,metalness:.4}),
    accent:new THREE.MeshStandardMaterial({color:"#884422",roughness:.5,metalness:.3})};
// Receiver body
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.08,.11,.5),_gunMats.body);return m;})());
// Barrel
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.02,.025,.4,8),_gunMats.barrel);m.rotation.x=Math.PI/2;m.position.set(0,.02,.44);return m;})());
// Barrel shroud
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.07,.07,.2),_gunMats.body);m.position.set(0,.01,.3);return m;})());
// Front sight
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.015,.04,.015),_gunMats.barrel);m.position.set(0,.06,.55);return m;})());
// Rear sight
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.04,.03,.015),_gunMats.barrel);m.position.set(0,.07,.1);return m;})());
// Stock
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.05,.09,.25),_gunMats.body);m.position.set(0,-.01,-.3);return m;})());
// Stock pad
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.06,.1,.03),_gunMats.accent);m.position.set(0,-.01,-.43);return m;})());
// Magazine
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.04,.2,.07),_gunMats.mag);m.position.set(0,-.16,.02);return m;})());
// Grip
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.04,.13,.06),_gunMats.accent);m.position.set(0,-.11,-.1);m.rotation.x=.2;return m;})());
// Trigger guard
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.025,.02,.08),_gunMats.barrel);m.position.set(0,-.07,-.04);return m;})());
// Muzzle tip (for flash positioning)
const _gunMuzzleTip=new THREE.Object3D();_gunMuzzleTip.position.set(0,.02,.65);
gunGroup.add(_gunMuzzleTip);

gunPivot.add(gunGroup);
gunPivot.visible=false;
gunPivot.scale.setScalar(2.0);
scene.add(gunPivot);

// Muzzle flash light
const _muzzleLight=new THREE.PointLight(0xff8833,0,8);scene.add(_muzzleLight);

// Bullet tracer line
const _tracerGeo=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(),new THREE.Vector3()]);
const _tracerLine=new THREE.Line(_tracerGeo,new THREE.LineBasicMaterial({color:0xffdd44,transparent:true,opacity:0.8}));
_tracerLine.visible=false;scene.add(_tracerLine);
let _tracerTimer=0;

// Destruction particle system (simple instanced spheres)
const _debrisPool=[];
function spawnDebris(pos,color,count){
    for(let i=0;i<count;i++){
        const size=.15+Math.random()*.35;
        const geo=Math.random()>.5?new THREE.BoxGeometry(size,size,size):new THREE.TetrahedronGeometry(size);
        const m=new THREE.Mesh(geo,new THREE.MeshStandardMaterial({color:color||"#888888"}));
        m.position.copy(pos);
        m.position.x+=(Math.random()-.5)*2;m.position.y+=Math.random()*3;m.position.z+=(Math.random()-.5)*2;
        const vel=new THREE.Vector3((Math.random()-.5)*8,3+Math.random()*6,(Math.random()-.5)*8);
        scene.add(m);
        _debrisPool.push({mesh:m,vel,life:2+Math.random()});
    }
}
function tickDebris(dt){
    for(let i=_debrisPool.length-1;i>=0;i--){
        const d=_debrisPool[i];
        d.vel.y-=15*dt;
        d.mesh.position.addScaledVector(d.vel,dt);
        d.mesh.rotation.x+=dt*3;d.mesh.rotation.z+=dt*2;
        d.life-=dt;
        const gy=Math.max(terrainHeight(d.mesh.position.x,d.mesh.position.z),ROAD_Y);
        if(d.mesh.position.y<gy){d.mesh.position.y=gy;d.vel.y*=-.3;d.vel.x*=.8;d.vel.z*=.8;}
        if(d.life<=0){scene.remove(d.mesh);_debrisPool.splice(i,1);}
    }
}

// Fireball system (wizard's attack)
let _fireball=null;
function spawnFireball(from,to){
    const geo=new THREE.SphereGeometry(.5,12,12);
    const mat=new THREE.MeshBasicMaterial({color:"#ff4400"});
    const fb=new THREE.Mesh(geo,mat);
    fb.position.copy(from);fb.position.y+=2;
    // Glow
    const glow=new THREE.PointLight(0xff4400,3,12);
    fb.add(glow);
    scene.add(fb);
    const dir=new THREE.Vector3().subVectors(to,fb.position).normalize();
    _fireball={mesh:fb,vel:dir.multiplyScalar(25),target:to,life:5};
}
function tickFireball(dt){
    if(!_fireball)return;
    _fireball.mesh.position.addScaledVector(_fireball.vel,dt);
    _fireball.life-=dt;
    // Check if reached target (player)
    const playerPos=state.mode==="walking"?avatar.position:car.position;
    const dist=_fireball.mesh.position.distanceTo(playerPos);
    if(dist<2||_fireball.life<=0){
        // Hit!
        if(dist<3){
            killPlayer();
        }
        scene.remove(_fireball.mesh);
        spawnDebris(_fireball.mesh.position,"#ff4400",8);
        _fireball=null;
    }
}

// Player death
function killPlayer(){
    if(state.isDead)return;
    state.isDead=true;
    state.gunEquipped=false;
    _shooting=false;
    gunPivot.visible=false;
    crosshairEl.classList.remove("show");
    gunHudEl.classList.remove("show");
    hpBar.classList.remove("show");
    if(document.pointerLockElement)document.exitPointerLock();
    deathScreen.classList.add("show");
    audio.chime(150,.3);
    setTimeout(()=>{
        deathScreen.classList.remove("show");
        state.isDead=false;
        state.wizardWarnings=0;
        // Respawn at town center
        if(state.mode==="walking"){
            avatar.position.set(0,ROAD_Y+.1,5);
            state.avatarAngle=0;avatar.rotation.y=0;
            _camYaw=0;_camPitch=.3;
        }else{
            car.position.set(0,ROAD_Y+.1,5);car.rotation.y=0;state.speed=0;
        }
    },3000);
}

// Shooting raycaster
const _shootRay=new THREE.Raycaster();
let _shootCooldown=0;
let _shooting=false;
const FIRE_RATE=0.12; // seconds between shots
const BULLET_DAMAGE=10;

function findDestroyableAncestor(obj){
    let cur=obj;
    while(cur){
        if(cur.userData._destroyIdx!==undefined)return destroyables[cur.userData._destroyIdx];
        cur=cur.parent;
    }
    return null;
}

function isWizardHit(obj){
    let cur=obj;
    while(cur){
        if(cur===npcGuide)return true;
        cur=cur.parent;
    }
    return false;
}

function shootGun(){
    if(_shootCooldown>0||state.isDead||state.mode==="dialog")return;
    _shootCooldown=FIRE_RATE;
    // Muzzle flash
    muzzleFlashEl.style.opacity="1";
    setTimeout(()=>{muzzleFlashEl.style.opacity="0";},50);
    // Sound
    audio.chime(120+Math.random()*40,.06);
    setTimeout(()=>audio.chime(80,.03),30);
    // Raycast from camera center
    _shootRay.setFromCamera(new THREE.Vector2(0,0),camera);
    // Get gun muzzle tip world position for tracer
    const gunTip=new THREE.Vector3();
    _gunMuzzleTip.getWorldPosition(gunTip);
    _muzzleLight.position.copy(gunTip);
    _muzzleLight.intensity=4;
    // Intersect everything in scene
    const hits=_shootRay.intersectObjects(scene.children,true);
    let hitPoint=null;
    for(const hit of hits){
        // Skip gun, avatar, armed avatar, gates, tracer
        if(hit.object===_tracerLine)continue;
        let skip=false;
        let cur=hit.object;
        while(cur){
            if(cur===gunPivot||cur===gunGroup||cur===avatar||cur===_tracerLine){skip=true;break;}
            // Skip gate meshes
            if(hotlapGates.some(g=>g.group===cur)){skip=true;break;}
            cur=cur.parent;
        }
        if(skip)continue;
        hitPoint=hit.point.clone();
        // Check wizard
        if(isWizardHit(hit.object)){
            handleWizardShot();
            break;
        }
        // Check destroyable
        const dest=findDestroyableAncestor(hit.object);
        if(dest&&dest.alive){
            dest.health-=BULLET_DAMAGE;
            // Show HP bar
            hpBar.classList.add("show");
            hpFill.style.width=Math.max(0,(dest.health/dest.maxHealth)*100)+"%";
            clearTimeout(shootGun._hpT);
            shootGun._hpT=setTimeout(()=>hpBar.classList.remove("show"),1500);
            if(dest.health<=0){
                destroyObject(dest);
                hpBar.classList.remove("show");
            }
            // Hit particles
            spawnDebris(hit.point,"#aaaaaa",3);
            _camShake=Math.max(_camShake,.15);
            break;
        }
        // Hit terrain/road/other ‚Äî spark
        spawnDebris(hit.point,"#666666",2);
        break;
    }
    // Tracer line
    const endPoint=hitPoint||_shootRay.ray.at(80,new THREE.Vector3());
    const positions=_tracerLine.geometry.attributes.position;
    positions.setXYZ(0,gunTip.x,gunTip.y,gunTip.z);
    positions.setXYZ(1,endPoint.x,endPoint.y,endPoint.z);
    positions.needsUpdate=true;
    _tracerLine.visible=true;_tracerTimer=0.06;
}

function destroyObject(dest){
    if(!dest.alive)return;
    dest.alive=false;
    const pos=new THREE.Vector3();
    dest.mesh.getWorldPosition(pos);
    // Compute bounding box BEFORE hiding
    const meshBox=new THREE.Box3().setFromObject(dest.mesh);
    // Determine debris color from type
    const colors={building:"#8a8a80",car:"#556677",billboard:"#3a3a40",ship:"#2a3a4a"};
    const debrisCount={building:15,car:10,billboard:8,ship:25};
    spawnDebris(pos,colors[dest.type]||"#888",debrisCount[dest.type]||10);
    // Camera shake
    _camShake=Math.max(_camShake,dest.type==="ship"?1.5:dest.type==="building"?.8:.4);
    // Audio
    audio.chime(60,.15);setTimeout(()=>audio.chime(40,.1),100);
    // Hide mesh
    dest.mesh.visible=false;
    // Remove from staticCol ‚Äî find matching box
    for(let i=staticCol.length-1;i>=0;i--){
        const b=staticCol[i];
        if(b.intersectsBox(meshBox)||b.containsPoint(pos)){
            staticCol.splice(i,1);break;
        }
    }
}

// Wizard protection
function handleWizardShot(){
    state.wizardWarnings++;
    if(state.wizardWarnings===1){
        // First warning
        speechBubble.textContent="Careful where you aim that, mortal...";
        speechBubble.classList.add("show");
        _jokeShow=4;
        audio.chime(300,.1);
    }else if(state.wizardWarnings===2){
        speechBubble.textContent="I'm WARNING you. Stop. Now.";
        speechBubble.classList.add("show");
        _jokeShow=4;
        audio.chime(200,.15);
    }else if(state.wizardWarnings>=3){
        // Wizard attacks!
        speechBubble.textContent="You've chosen poorly!";
        speechBubble.classList.add("show");
        _jokeShow=3;
        audio.chime(100,.2);
        const wizPos=npcGuide.position.clone();
        const pPos=avatar.position.clone();
        spawnFireball(wizPos,pPos);
    }
}

// Equip/holster gun
function toggleGun(){
    if(!state.hasGun||state.mode!=="walking"||state.isDead)return;
    state.gunEquipped=!state.gunEquipped;
    if(state.gunEquipped){
        // Avatar stays visible ‚Äî gun appears at their side
        gunPivot.visible=true;
        crosshairEl.classList.add("show");
        gunHudEl.classList.add("show");
        _camPitch=0; // Level pitch for FPS
        // Request pointer lock for FPS aiming
        renderer.domElement.requestPointerLock();
        showToast("SMG equipped ‚Äî LMB to fire, 1 or ESC to holster");
        updateModeBadge();
    }else{
        holsterGun();
    }
}
function holsterGun(){
    state.gunEquipped=false;
    gunPivot.visible=false;
    crosshairEl.classList.remove("show");
    gunHudEl.classList.remove("show");
    hpBar.classList.remove("show");
    _camPitch=.3; // Reset to normal walking pitch
    if(document.pointerLockElement)document.exitPointerLock();
    updateModeBadge();
}

// Pointer lock change handler
document.addEventListener("pointerlockchange",()=>{
    if(!document.pointerLockElement&&state.gunEquipped){
        // Lost pointer lock ‚Äî holster
        holsterGun();
    }
});

/* ====== GARAGE RENDERER ====== */
// Mini renderer for garage preview
const _prevRenderer=new THREE.WebGLRenderer({alpha:true,antialias:true});
_prevRenderer.setSize(360,200);_prevRenderer.setPixelRatio(Math.min(devicePixelRatio,2));
const _prevScene=new THREE.Scene();
_prevScene.add(new THREE.AmbientLight(0xffffff,.6));
_prevScene.add(new THREE.DirectionalLight(0xffffff,.8));
const _prevCam=new THREE.PerspectiveCamera(35,1.6,0.1,50);
_prevCam.position.set(3,2,4);_prevCam.lookAt(0,.5,0);
// ===== Virtual Garage (Carousel Modal) =====
const _garageKeys=Object.keys(CAR_MODELS);
let _garageIdx=0;
let _garageModel=null;
let _garageSpinRAF=null;
let _garageOpenedFrom=null; // mode we came from ‚Äî return here on close without selecting
const garagePreviewEl=document.getElementById("garage-preview"),
      garageNameEl=document.getElementById("garage-car-name"),
      garageDescEl=document.getElementById("garage-car-desc"),
      garageBadgeEl=document.getElementById("garage-car-badge"),
      garageSelectBtn=document.getElementById("garage-select-btn"),
      garageDotsEl=document.getElementById("garage-dots"),
      garageCounterEl=document.getElementById("garage-counter");

function openGarage(){
    if(state.unlockedCars.length<2)return; // need at least 2 cars
    _garageOpenedFrom=state.mode; // remember so we can return on cancel
    _garageIdx=Math.max(0,_garageKeys.indexOf(state.activeCar));
    _updateGarageUI();
    garageOverlay.classList.add("show");
    _startGarageSpin();
}
function _updateGarageUI(){
    const key=_garageKeys[_garageIdx];
    const cm=CAR_MODELS[key];
    const unlocked=state.unlockedCars.includes(key);
    garageNameEl.textContent=cm.name;
    garageDescEl.textContent=cm.desc;
    // Counter
    const collected=state.unlockedCars.length;
    garageCounterEl.textContent=`${collected} / ${_garageKeys.length} collected`;
    // Badge & button
    if(state.activeCar===key){
        garageBadgeEl.textContent="Currently Equipped";garageBadgeEl.className="garage-car-badge current";
        garageSelectBtn.textContent="Spawn This Car";garageSelectBtn.disabled=false;
    }else if(unlocked){
        garageBadgeEl.textContent="Unlocked";garageBadgeEl.className="garage-car-badge available";
        garageSelectBtn.textContent="Spawn This Car";garageSelectBtn.disabled=false;
    }else{
        garageBadgeEl.textContent="Locked";garageBadgeEl.className="garage-car-badge locked";
        garageSelectBtn.textContent="Locked";garageSelectBtn.disabled=true;
    }
    // Clear old preview model
    while(_prevScene.children.length>2)_prevScene.remove(_prevScene.children[2]);
    _garageModel=null;
    // Preview canvas
    garagePreviewEl.innerHTML="";
    if(unlocked){
        const cvs=document.createElement("canvas");cvs.width=640;cvs.height=400;
        garagePreviewEl.appendChild(cvs);
        new GLTFLoader().load(cm.path,gltf=>{
            const m=gltf.scene;m.updateMatrixWorld(true);
            const b=realBounds(m);const maxDim=Math.max(b.max.x-b.min.x,b.max.y-b.min.y,b.max.z-b.min.z);
            const sc=2.5/maxDim;m.scale.setScalar(sc);m.updateMatrixWorld(true);
            const b2=realBounds(m);
            m.position.y-=b2.min.y;m.position.x-=(b2.min.x+b2.max.x)/2;m.position.z-=(b2.min.z+b2.max.z)/2;
            m.traverse(ch=>{if(ch.isMesh){const mats=Array.isArray(ch.material)?ch.material:[ch.material];mats.forEach(mt=>{mt.side=THREE.FrontSide;});}});
            _prevScene.add(m);
            _garageModel=m;
        });
    }else{
        garagePreviewEl.innerHTML='<div class="locked-overlay"><span>&#128274;</span><div class="locked-text">Complete the quest to unlock</div></div>';
    }
    // Dots
    garageDotsEl.innerHTML="";
    _garageKeys.forEach((k,i)=>{
        const dot=document.createElement("div");
        const u=state.unlockedCars.includes(k);
        dot.className="garage-dot"+(i===_garageIdx?" active":"")+(u?"":" locked");
        dot.onclick=()=>{_garageIdx=i;_updateGarageUI();audio.chime(440,.05);};
        garageDotsEl.appendChild(dot);
    });
}
function _startGarageSpin(){
    if(_garageSpinRAF)cancelAnimationFrame(_garageSpinRAF);
    function spin(){
        _garageSpinRAF=requestAnimationFrame(spin);
        if(!garageOverlay.classList.contains("show")){cancelAnimationFrame(_garageSpinRAF);_garageSpinRAF=null;return;}
        if(_garageModel)_garageModel.rotation.y+=0.008;
        _prevRenderer.setSize(640,400);
        _prevRenderer.render(_prevScene,_prevCam);
        const c2=garagePreviewEl.querySelector("canvas");
        if(c2){const ctx=c2.getContext("2d");ctx.clearRect(0,0,c2.width,c2.height);ctx.drawImage(_prevRenderer.domElement,0,0,c2.width,c2.height);}
    }
    spin();
}
function _cleanupGarage(){
    garageOverlay.classList.remove("show");
    if(_garageSpinRAF){cancelAnimationFrame(_garageSpinRAF);_garageSpinRAF=null;}
    while(_prevScene.children.length>2)_prevScene.remove(_prevScene.children[2]);
    _garageModel=null;
}
window._garageClose=function(){
    _cleanupGarage();
    // Return to the mode we came from ‚Äî don't force enterCarMode
    if(_garageOpenedFrom==="walking"){
        state.mode="walking";updateModeBadge();
    }else if(_garageOpenedFrom==="driving"){
        // Already in driving mode / car mode
    }
    _garageOpenedFrom=null;
};
window._garagePrev=function(){
    _garageIdx=(_garageIdx-1+_garageKeys.length)%_garageKeys.length;
    _updateGarageUI();
    audio.chime(440,.06);
};
window._garageNext=function(){
    _garageIdx=(_garageIdx+1)%_garageKeys.length;
    _updateGarageUI();
    audio.chime(440,.06);
};
window._garageSelect=function(){
    const key=_garageKeys[_garageIdx];
    if(!state.unlockedCars.includes(key))return;
    selectCar(key);
};
function selectCar(key){
    const fromMode=_garageOpenedFrom||state.mode;
    const wasSameCar=(key===state.activeCar);
    _cleanupGarage();
    _garageOpenedFrom=null;
    // Save to localStorage
    state.activeCar=key;
    _saveGarage();
    if(wasSameCar){
        // Same car selected ‚Äî just enter car mode
        enterCarMode();return;
    }
    // Remove current car children & load new model
    while(car.children.length)car.remove(car.children[0]);
    const cm=CAR_MODELS[key];
    // If opened from walking mode, move the car to the avatar's position
    if(fromMode==="walking"){
        const heading=state.avatarAngle;
        const spawnDist=3.5;
        car.position.set(
            avatar.position.x+Math.sin(heading)*spawnDist,
            avatar.position.y,
            avatar.position.z+Math.cos(heading)*spawnDist
        );
        car.rotation.y=heading;
        state.speed=0;
        state.carParkedAt=car.position.clone();
    }
    // Load new model
    new GLTFLoader().load(cm.path,gltf=>{
        const m=gltf.scene;
        let b=realBounds(m);
        const rawW=b.max.x-b.min.x,rawD=b.max.z-b.min.z;
        const sc=(cm.targetSize||4.0)/Math.max(rawW,rawD);
        m.scale.setScalar(sc);
        m.updateMatrixWorld(true);
        m.traverse(ch=>{
            if(!ch.isMesh)return;
            const chn=ch.name.toLowerCase();
            if(chn.includes('collider')||chn.includes('ground')||chn.includes('floor')||chn.includes('shadow_plane')||chn.includes('road')||chn.includes('asphalt')||chn.includes('parking')){ch.visible=false;return;}
            const wb=new THREE.Box3().setFromObject(ch);
            const wh=wb.max.y-wb.min.y, ww=wb.max.x-wb.min.x, wd=wb.max.z-wb.min.z;
            const area=ww*wd;
            if(wh<0.05&&area>4){ch.visible=false;return;}
            const mats=Array.isArray(ch.material)?ch.material:[ch.material];
            mats.forEach(mt=>{
                mt.depthWrite=true;
                const nm=(mt.name||'').toLowerCase()+chn;
                if(nm.includes('glass')||nm.includes('window')||nm.includes('transparent')){
                    mt.transparent=true;mt.opacity=0.3;mt.side=THREE.FrontSide;
                }else{
                    mt.transparent=false;mt.opacity=1;mt.side=THREE.FrontSide;
                }});});
        const wrap=new THREE.Group();wrap.add(m);
        wrap.rotation.y=cm.rotY;
        // Reset car transform, measure, then center the model on origin
        const savedPos=car.position.clone();
        const savedRot=car.rotation.y;
        car.position.set(0,0,0);car.rotation.y=0;
        car.add(wrap);
        wrap.position.set(0,0,0);
        car.updateMatrixWorld(true);
        b=realBounds(car);
        const cxW=(b.min.x+b.max.x)/2,czW=(b.min.z+b.max.z)/2;
        wrap.position.y=-b.min.y;
        wrap.position.x=-cxW;
        wrap.position.z=-czW;
        // Shadow sized from visible-only bounds
        const vb=realBounds(car,true);
        carShadowW=Math.min((vb.max.x-vb.min.x)*1.05,6);carShadowD=Math.min((vb.max.z-vb.min.z)*1.05,3);
        // Restore car position/rotation
        car.position.copy(savedPos);car.rotation.y=savedRot;
        const wh=[];m.traverse(c=>{if(c.isMesh){const n=c.name.toLowerCase();if(n.includes('wheel')||n.includes('tire')||n.includes('rim'))wh.push(c);}});
        car.userData.wheels=wh;
        enterCarMode();
        showToast("Now driving: "+cm.name);
    },undefined,()=>{
        car.add(fb.group);car.userData.wheels=fb.wheels;
        enterCarMode();
    });
}
function enterCarMode(){
    if(state.gunEquipped)holsterGun();
    state.mode="driving";
    avatar.visible=false;
    state.speed=0;
    state.canInteract=null;
    promptEl.classList.remove("show");
    _mouseDragging=false;
    updateModeBadge();
}

/* ====== PARTICLES ====== */
const LEAF_N=PERF.leafCount;const leafPos=new Float32Array(LEAF_N*3),leafSizes=new Float32Array(LEAF_N);
for(let i=0;i<LEAF_N;i++){leafPos[i*3]=(Math.random()-.5)*160;leafPos[i*3+1]=3+Math.random()*25;leafPos[i*3+2]=(Math.random()-.5)*160;leafSizes[i]=1.5+Math.random()*2.5;}
const leafGeo=new THREE.BufferGeometry();leafGeo.setAttribute("position",new THREE.BufferAttribute(leafPos,3));leafGeo.setAttribute("aSize",new THREE.BufferAttribute(leafSizes,1));
const leafMat=new THREE.ShaderMaterial({uniforms:{fogColor:{value:scene.fog.color},fogNear:{value:70},fogFar:{value:240}},vertexShader:`attribute float aSize;varying float vAlpha,vFD;void main(){vAlpha=.5+.3*sin(position.x+position.z);vec4 mv=modelViewMatrix*vec4(position,1.);vFD=-mv.z;gl_PointSize=aSize*(200./max(-mv.z,1.));gl_Position=projectionMatrix*mv;}`,fragmentShader:`uniform vec3 fogColor;uniform float fogNear,fogFar;varying float vAlpha,vFD;void main(){float d=length(gl_PointCoord-.5);if(d>.45)discard;float ff=smoothstep(fogNear,fogFar,vFD);vec3 col=mix(vec3(.85,.6,.28),fogColor,ff);gl_FragColor=vec4(col,vAlpha*(1.-d*2.2));}`,transparent:true,depthWrite:false});
scene.add(new THREE.Points(leafGeo,leafMat));

/* ====== AUDIO ====== */
class AudioEngine{constructor(){this.ctx=null;this.master=null;this.initialized=false;this.muted=false;}
init(){if(this.initialized)return;try{this.ctx=new(window.AudioContext||window.webkitAudioContext)();this.master=this.ctx.createGain();this.master.gain.value=.2;this.master.connect(this.ctx.destination);this.lo=this.ctx.createOscillator();this.hi=this.ctx.createOscillator();this.lo.type="sawtooth";this.hi.type="triangle";this.lg=this.ctx.createGain();this.hg=this.ctx.createGain();this.lg.gain.value=0;this.hg.gain.value=0;this.lo.connect(this.lg).connect(this.master);this.hi.connect(this.hg).connect(this.master);this.lo.start();this.hi.start();const buf=this.ctx.createBuffer(1,this.ctx.sampleRate*2,this.ctx.sampleRate),d=buf.getChannelData(0);for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;this.wind=this.ctx.createBufferSource();this.wind.buffer=buf;this.wind.loop=true;const bp=this.ctx.createBiquadFilter();bp.type="bandpass";bp.frequency.value=500;this.wg=this.ctx.createGain();this.wg.gain.value=.01;this.wind.connect(bp).connect(this.wg).connect(this.master);this.wind.start();this.initialized=true;}catch(e){}}
update(spd,thr){if(!this.initialized||this.muted)return;const n=this.ctx.currentTime,r=.2+Math.min(Math.abs(spd)/30,1);this.lo.frequency.setTargetAtTime(65+r*110,n,.03);this.hi.frequency.setTargetAtTime(120+r*240,n,.03);this.lg.gain.setTargetAtTime(.02+r*.06+thr*.02,n,.04);this.hg.gain.setTargetAtTime(.006+r*.035,n,.04);this.wg.gain.setTargetAtTime(.007+r*.02,n,.1);}
chime(f=880,d=.12){if(!this.initialized||this.muted)return;const o=this.ctx.createOscillator(),g=this.ctx.createGain();o.type="sine";o.frequency.value=f;g.gain.value=0;o.connect(g).connect(this.master);const n=this.ctx.currentTime;g.gain.setValueAtTime(0,n);g.gain.linearRampToValueAtTime(.1,n+.015);g.gain.exponentialRampToValueAtTime(.0001,n+d);o.start(n);o.stop(n+d+.03);}
setMuted(v){this.muted=v;if(this.initialized)this.master.gain.value=v?0:.2;}}
const audio=new AudioEngine();
function toggleMute(){state.muted=!state.muted;audio.setMuted(state.muted);muteBtn.textContent=`Audio: ${state.muted?"OFF":"ON"}`;}
muteBtn.addEventListener("click",toggleMute);

/* ====== INPUT ====== */
const pressed=new Set();const KM={KeyW:"f",ArrowUp:"f",KeyS:"b",ArrowDown:"b",KeyA:"l",ArrowLeft:"l",KeyD:"r",ArrowRight:"r",ShiftLeft:"x",ShiftRight:"x"};
window.addEventListener("keydown",e=>{
    const k=KM[e.code];if(k){pressed.add(k);e.preventDefault();}
    if(!audio.initialized)audio.init();
    if(e.code==="KeyM")toggleMute();
    // F key: exit/enter car
    if(e.code==="KeyF"){
        if(state.mode==="driving"&&Math.abs(state.speed)<1){
            // Exit car ‚Üí walking mode
            state.mode="walking";
            state.carParkedAt=car.position.clone();
            state.canInteract=null;
            state.speed=0;
            // Place avatar next to car (driver side offset)
            const heading=car.rotation.y;
            // Place avatar to the left side of the car (driver door)
            const sideAngle=heading+Math.PI/2;
            const ox=Math.sin(sideAngle)*2.5, oz=Math.cos(sideAngle)*2.5;
            avatar.position.set(car.position.x+ox,car.position.y,car.position.z+oz);
            // Avatar faces the same direction the car is facing
            state.avatarAngle=heading;
            avatar.rotation.y=heading;
            _camYaw=heading; // camera behind avatar (looking at avatar's back)
            _camPitch=1.0; // near-isometric top-down view
            zoomFactor=3; // full zoom out
            avatar.visible=true;
            audio.chime(600,.08);
            updateModeBadge();
        }else if(state.mode==="walking"){
            // Check near car ‚Äî enter directly or open garage
            const _fPos=avatar.position;
            if(state.carParkedAt&&_fPos.distanceTo(state.carParkedAt)<4){
                if(state.unlockedCars.length>1){openGarage();return;}
                enterCarMode();
                audio.chime(800,.08);
            }
        }
    }
    // G key: open garage from any mode (if 2+ cars unlocked)
    if(e.code==="KeyG"&&!garageOverlay.classList.contains("show")&&state.mode!=="dialog"){
        if(state.unlockedCars.length>1){openGarage();e.preventDefault();}
    }
    // E key: context-sensitive interaction
    if(e.code==="KeyE"){
        if(state.mode==="driving"){
            openBB(); // existing billboard interaction
        }else if(state.mode==="walking"){
            // Check NPC proximity first, then billboard
            const _ePos=avatar.position;
            if(_ePos.distanceTo(npcGuide.position)<4){
                showDialog(npcGuide);
            }else if(state.canInteract){
                openBB(); // open billboard on foot
            }
        }else if(state.mode==="dialog"){
            window._closeDialog();
        }
    }
    // 1 key: toggle gun
    if(e.code==="Digit1"){
        toggleGun();
    }
    // Escape: close dialogs / garage / holster gun
    if(e.code==="Escape"){
        if(state.gunEquipped){holsterGun();return;}
        if(state.mode==="dialog")window._closeDialog();
        if(garageOverlay.classList.contains("show")){window._garageClose();}
    }
    // F key also holsters gun first
    if(e.code==="KeyF"&&state.gunEquipped){holsterGun();return;}
},{passive:false});
window.addEventListener("keyup",e=>{const k=KM[e.code];if(k){pressed.delete(k);e.preventDefault();}},{passive:false});
window.addEventListener("pointerdown",()=>{if(!audio.initialized)audio.init();});
document.addEventListener("visibilitychange",()=>{if(document.hidden)pressed.clear();});

/* ====== ZOOM (mouse wheel) ====== */
let zoomFactor=1; // 0.12 = bonnet cam, 1 = default, 3 = bird's eye
renderer.domElement.addEventListener("wheel",e=>{zoomFactor+=e.deltaY*.0008;zoomFactor=THREE.MathUtils.clamp(zoomFactor,.12,3);e.preventDefault();},{passive:false});

/* ====== MOUSE LOOK (walking mode ‚Äî LMB hold to orbit) ====== */
let _camYaw=0,_camPitch=.3; // radians ‚Äî yaw orbits around avatar, pitch is elevation
let _mouseDragging=false;
renderer.domElement.addEventListener("mousedown",e=>{
    if(state.gunEquipped&&document.pointerLockElement&&e.button===0){
        _shooting=true;shootGun();e.preventDefault();return;
    }
    if(state.mode==="walking"&&e.button===0&&!state.gunEquipped){_mouseDragging=true;e.preventDefault();}
});
window.addEventListener("mouseup",e=>{
    if(e.button===0){_mouseDragging=false;_shooting=false;}
});
window.addEventListener("mousemove",e=>{
    // FPS aiming with pointer lock ‚Äî full vertical range like any FPS
    if(document.pointerLockElement&&state.gunEquipped){
        _camYaw-=e.movementX*.002;
        _camPitch=THREE.MathUtils.clamp(_camPitch+e.movementY*.002,-1.4,1.4); // ~80¬∞ up/down
        return;
    }
    if(!_mouseDragging||state.mode!=="walking")return;
    _camYaw-=e.movementX*.004;
    _camPitch=THREE.MathUtils.clamp(_camPitch-e.movementY*.003,.05,1.2);
});

/* ====== INTERACTION ====== */
const raycaster=new THREE.Raycaster(),pointer=new THREE.Vector2();
function openBB(){if(!state.canInteract)return;window.open(state.canInteract.u,"_blank","noopener");state.visited.add(state.canInteract.t);visitedEl.textContent=`${state.visited.size} / ${ALL_PROJECTS.length}`;unlock("first");
const portAll=DISTRICTS.maritime.projects.every(p=>state.visited.has(p.t));if(portAll)unlock("port");
const simAll=DISTRICTS.simulations.projects.every(p=>state.visited.has(p.t));if(simAll)unlock("science");
if(state.visited.size===ALL_PROJECTS.length)unlock("all");audio.chime(960,.12);updateQuestTracker();}
renderer.domElement.addEventListener("pointerdown",e=>{const rc=renderer.domElement.getBoundingClientRect();pointer.x=((e.clientX-rc.left)/rc.width)*2-1;pointer.y=-((e.clientY-rc.top)/rc.height)*2+1;raycaster.setFromCamera(pointer,camera);const hit=raycaster.intersectObjects(interactables,false)[0];if(!hit)return;const p=hit.object.userData.project;if(!p||!state.canInteract||state.canInteract.t!==p.t)return;openBB();});

/* ====== SEASONS ====== */
const SP=[
    {sky:"#78b8e6",fog:"#a8d4ec",sun:"#fff0c8",hS:"#b4d8f0",hG:"#5a8040",gA:"#3d8a2e",gB:"#80c848",gBase:"#3d8a2e",gTip:"#a8d44e"},
    {sky:"#68a8e0",fog:"#90c4e4",sun:"#ffe8a0",hS:"#a0d0f0",hG:"#4a7a34",gA:"#308020",gB:"#6ab838",gBase:"#2e7a22",gTip:"#8cc040"},
    {sky:"#90a4c8",fog:"#b0b8cc",sun:"#ffd090",hS:"#c8d0e0",hG:"#7a6040",gA:"#8a7040",gB:"#b09040",gBase:"#7a6030",gTip:"#c0a048"},
    {sky:"#c0cce0",fog:"#d0d8e4",sun:"#fff4d4",hS:"#e0e8f4",hG:"#708090",gA:"#a0aab8",gB:"#c4ccd8",gBase:"#90a0a8",gTip:"#c0d0d4"},
];
function applyTerrain(p){const gA=new THREE.Color(p.gA),gB=new THREE.Color(p.gB),sand=new THREE.Color("#c8b888"),dirt=new THREE.Color("#8a7858");
for(let i=0;i<tPos.count;i++){const x=tPos.getX(i),z=tPos.getZ(i),y=tPos.getY(i);const bl=Math.min(Math.max((y+4)/12,0),1);
const c=gA.clone().lerp(gB,bl);if(z<-35)c.lerp(sand,Math.min(1,Math.max(0,(-z-35)/25))*.5);
const rd=roadDist(x,z);if(rd>0&&rd<4)c.lerp(dirt,(1-rd/4)*.35);const nv=vn(x*.3,z*.3);c.r*=.92+nv*.16;c.g*=.92+nv*.16;c.b*=.92+nv*.16;
tColors[i*3]=c.r;tColors[i*3+1]=c.g;tColors[i*3+2]=c.b;}tGeo.setAttribute("color",new THREE.BufferAttribute(tColors,3));tGeo.attributes.color.needsUpdate=true;}
function applySeason(){const p=SP[state.seasonIndex];scene.background.set(p.sky);scene.fog.color.set(p.fog);sun.color.set(p.sun);sunSphere.material.color.set(p.sun);hemi.color.set(p.hS);hemi.groundColor.set(p.hG);applyTerrain(p);grassMat.uniforms.uBase.value.set(p.gBase);grassMat.uniforms.uTip.value.set(p.gTip);}
applySeason();visitedEl.textContent=`0 / ${ALL_PROJECTS.length}`;

/* ====== LOAD LOCAL GLB MODELS ====== */
const glbLoader=new GLTFLoader();
// Helper: extract named child from GLTF scene
function extractChild(root,name){let found=null;root.traverse(c=>{if(!found&&c.name===name)found=c;});return found;}
// Helper: place a model at world position, auto-grounded, scaled to target height
function placeGLB(model,x,z,targetH,rotY){
    const m=model.clone();const b=realBounds(m);
    const curH=b.max.y-b.min.y;const sc=curH>0?targetH/curH:1;
    m.scale.multiplyScalar(sc);
    m.position.set(x,Math.max(terrainHeight(x,z),ROAD_Y),z);
    // Ground: recompute bounds after scaling and shift so bottom touches position.y
    const b2=realBounds(m);m.position.y-=(b2.min.y-m.position.y);
    if(rotY!==undefined)m.rotation.y=rotY;
    scene.add(m);return m;}
function placeGLBDestroy(model,x,z,targetH,rotY,hp,type){
    const m=placeGLB(model,x,z,targetH,rotY);addStatic(m,.2);registerDestroyable(m,hp||80,type||"building");return m;}

// ---- BUILDINGS PACK ----
if(PERF.extraGltf)glbLoader.load('models/buidlings/low_poly_public_buildings_pack.glb',gltf=>{
    const root=gltf.scene;root.updateMatrixWorld(true);
    const bldgs={};
    ['Pharmacy','Police','CityHall','Hospital','GasStation','School','Light','Bin'].forEach(n=>{
        const c=extractChild(root,'PublicBuilding_'+n);if(c)bldgs[n]=c;});
    // Town Center ‚Äî CityHall + Police
    if(bldgs.CityHall)placeGLBDestroy(bldgs.CityHall,-18,-18,12,0,80);
    if(bldgs.Police)placeGLBDestroy(bldgs.Police,18,-18,10,Math.PI,80);
    // Science Park ‚Äî Hospital
    if(bldgs.Hospital){placeGLBDestroy(bldgs.Hospital,64,22,11,Math.PI/2,80);placeGLBDestroy(bldgs.Hospital,70,-20,9,-Math.PI/2,80);}
    // Tech Hub ‚Äî GasStation
    if(bldgs.GasStation){placeGLBDestroy(bldgs.GasStation,-66,20,7,0,60);placeGLBDestroy(bldgs.GasStation,-74,-16,7,Math.PI,60);}
    // Creative Village ‚Äî School + Pharmacy
    if(bldgs.School)placeGLBDestroy(bldgs.School,-50,68,9,0,80);
    if(bldgs.Pharmacy){placeGLBDestroy(bldgs.Pharmacy,50,68,8,Math.PI,60);placeGLBDestroy(bldgs.Pharmacy,-18,18,8,Math.PI/2,60);}
    // Port ‚Äî extra buildings
    if(bldgs.CityHall)placeGLBDestroy(bldgs.CityHall,18,18,10,Math.PI,80);
    // Street Lights ‚Äî lined along road EDGES, never in the middle of roads
    // Road bands: N-S x=-8..8, E-W z=-8..8, Port z=-46..-34, Creative z=44..56,
    //   Connectors x=-42..-34 & x=34..42, Science x=45..55, Tech x=-55..-45
    if(bldgs.Light){
        [
         // Town center corners (outside all road bands)
         [12,12],[-12,12],[12,-12],[-12,-12],
         // Along N-S road edges (x=¬±10, safe z values away from E-W road)
         [10,-20],[-10,-20],[10,-28],[-10,-28],[10,20],[-10,20],[10,28],[-10,28],
         // Along E-W road edges (z=¬±10, safe x values away from N-S road)
         [20,10],[-20,10],[20,-10],[-20,-10],[30,10],[-30,10],[30,-10],[-30,-10],
         // Port district road edges (z=-33 or z=-47, x values clear of N-S & connectors)
         [20,-33],[-20,-33],[40,-33],[-40,-33],[20,-47],[-20,-47],
         // Creative district road edges (z=43 or z=57, x clear of N-S & connectors)
         [20,43],[-20,43],[20,57],[-20,57],[44,57],[-44,57],
         // Science park (x=56 or x=44, z clear of E-W road)
         [56,14],[56,-14],[44,14],[44,-14],
         // Tech hub (x=-56 or x=-44, z clear of E-W road)
         [-56,14],[-56,-14],[-44,14],[-44,-14],
        ].forEach(([lx,lz])=>placeGLB(bldgs.Light,lx,lz,4.5,Math.random()*Math.PI*2));}
    // Bins near benches/intersections ‚Äî all clear of roads
    if(bldgs.Bin){
        [[12,12],[-12,12],[12,-12],[-12,-12],[20,20],[-20,-20],
         [22,-33],[-22,-33],[22,43],[-22,43],[56,20],[-56,20]
        ].forEach(([bx,bz])=>placeGLB(bldgs.Bin,bx,bz,1.2,Math.random()*Math.PI*2));}
    console.log('Buildings pack loaded:',Object.keys(bldgs).join(', '));
},undefined,e=>console.warn('Buildings GLB failed:',e));

// ---- CARS PACK ‚Äî NPC vehicles for city life ----
const npcCars=[];
if(PERF.traffic)glbLoader.load('models/cars/low_poly_cars_pack.glb',gltf=>{
    const root=gltf.scene;root.updateMatrixWorld(true);
    const vehicles=[];
    for(let i=1;i<=7;i++){const c=extractChild(root,'Transport'+i);if(c){
        // Fix materials: hide colliders, solid body, tinted windows
        c.traverse(ch=>{
            if(!ch.isMesh)return;
            // Hide invisible collider meshes
            if(ch.name.toLowerCase().includes('collider')){ch.visible=false;return;}
            const mats=Array.isArray(ch.material)?ch.material:[ch.material];
            mats.forEach(mt=>{
                mt.depthWrite=true;
                if(ch.name.includes('transparent')){
                    // Windows ‚Äî semi-transparent tinted glass
                    mt.transparent=true;mt.opacity=0.35;mt.side=THREE.FrontSide;
                }else{
                    // Body ‚Äî fully opaque, front-face only (hides interior)
                    mt.transparent=false;mt.opacity=1;mt.side=THREE.FrontSide;
                }});});
        vehicles.push(c);}}
    if(!vehicles.length)return;
    // Model orientation offset: test common rotations
    // Low-poly packs vary ‚Äî PI/2 means model's +X becomes forward (-Z)
    const MODEL_ROT=Math.PI/2;
    // Helper: place car with correct orientation + fixed materials
    function placeCar(model,x,z,facingAngle){
        const v=placeGLB(model,x,z,1.4,facingAngle+MODEL_ROT);
        return v;}
    // Parked cars along roads ‚Äî facing matches road direction
    // N-S roads: facing 0 (north, -Z) or PI (south, +Z)
    // E-W roads: facing PI/2 (east, -X) or -PI/2 (west, +X)
    const parkSpots=[
        // N-S main road ‚Äî parked at road edges (x=¬±7), not in travel lanes
        [7,-22,0],[7,-14,0],[7,20,0],[7,30,0],[7,40,0],
        [-7,-18,Math.PI],[-7,-10,Math.PI],[-7,24,Math.PI],[-7,34,Math.PI],
        // E-W main road ‚Äî edges (z=¬±7)
        [22,7,Math.PI/2],[32,7,Math.PI/2],[-22,-7,-Math.PI/2],[-32,-7,-Math.PI/2],
        // Port road edges (z=-35 or z=-45)
        [18,-35,Math.PI/2],[30,-35,Math.PI/2],[-18,-45,-Math.PI/2],[-30,-45,-Math.PI/2],
        // Creative road edges (z=45 or z=55)
        [18,45,Math.PI/2],[30,45,Math.PI/2],[-18,55,-Math.PI/2],[-30,55,-Math.PI/2],
        // Science entry edges (x=46)
        [46,14,0],[46,-14,Math.PI],
        // Tech entry edges (x=-46)
        [-46,14,0],[-46,-14,Math.PI],
    ];
    parkSpots.forEach(([px,pz,pr],i)=>{
        const v=placeCar(vehicles[i%vehicles.length],px,pz,pr);
        // Physics-enabled: velocity, angular velocity, crash timer
        v.userData._vel=new THREE.Vector3();v.userData._angVel=0;v.userData._crashed=0;
        registerDestroyable(v,30,"car");
        npcCars.push(v);});
    // Driving cars follow actual road waypoint routes
    const routes=[
        // Route 0: N-S main road loop (drive north on right, south on left)
        {pts:[[4,-55],[4,65],[-4,65],[-4,-55]],speed:6},
        // Route 1: E-W main road loop
        {pts:[[-75,4],[75,4],[75,-4],[-75,-4]],speed:7},
        // Route 2: Port road loop
        {pts:[[-50,-38],[50,-38],[50,-42],[-50,-42]],speed:5},
        // Route 3: Creative road loop
        {pts:[[-45,48],[45,48],[45,52],[-45,52]],speed:5},
    ];
    const driveCars=[];
    routes.forEach((route,ri)=>{
        const v=placeCar(vehicles[(ri+3)%vehicles.length],route.pts[0][0],route.pts[0][1],0);
        v.userData.route=route;v.userData.wpIdx=0;
        v.userData.wpT=Math.random(); // start at random point along first segment
        // Physics-enabled
        v.userData._vel=new THREE.Vector3();v.userData._angVel=0;v.userData._crashed=0;
        registerDestroyable(v,30,"car");
        driveCars.push(v);npcCars.push(v);});
    // NPC tick: waypoint-following + crash physics
    window._npcTick=function(t,dt){
        driveCars.forEach(c=>{
            // Skip destroyed cars
            if(!c.visible)return;
            // If crashed, apply physics instead of route-following
            if(c.userData._crashed>0){
                c.userData._crashed-=dt;
                // Apply crash velocity
                const v=c.userData._vel;
                if(v.lengthSq()>.01){
                    c.position.addScaledVector(v,dt);
                    v.y-=15*dt; // gravity
                    const gy=Math.max(terrainHeight(c.position.x,c.position.z),ROAD_Y);
                    if(c.position.y<gy){c.position.y=gy;v.y=Math.abs(v.y)*.2;v.x*=.88;v.z*=.88;}
                    v.multiplyScalar(.94);
                    c.rotation.y+=c.userData._angVel*dt;
                    c.userData._angVel*=.94;
                }
                // Once crash timer expires, snap back onto nearest route point
                if(c.userData._crashed<=0){
                    c.userData._vel.set(0,0,0);c.userData._angVel=0;
                    // Find nearest waypoint to resume
                    const r=c.userData.route,pts=r.pts;
                    let bestD=Infinity,bestI=0;
                    pts.forEach(([px,pz],i)=>{const d=Math.hypot(c.position.x-px,c.position.z-pz);if(d<bestD){bestD=d;bestI=i;}});
                    c.userData.wpIdx=bestI;c.userData.wpT=0;
                }
                return;
            }
            const r=c.userData.route,pts=r.pts;
            c.userData.wpT+=dt*r.speed*.02;
            if(c.userData.wpT>=1){c.userData.wpT-=1;c.userData.wpIdx=(c.userData.wpIdx+1)%pts.length;}
            const i0=c.userData.wpIdx,i1=(i0+1)%pts.length;
            const t2=c.userData.wpT;
            const x=pts[i0][0]+(pts[i1][0]-pts[i0][0])*t2;
            const z=pts[i0][1]+(pts[i1][1]-pts[i0][1])*t2;
            const dx=pts[i1][0]-pts[i0][0],dz=pts[i1][1]-pts[i0][1];
            const facing=Math.atan2(-dx,-dz); // face direction of travel
            const gy=Math.max(terrainHeight(x,z),ROAD_Y);
            c.position.set(x,gy,z);
            c.rotation.y=facing+MODEL_ROT;
        });};
    console.log(`Cars pack: ${vehicles.length} types, ${parkSpots.length} parked, ${driveCars.length} driving`);
},undefined,e=>console.warn('Cars GLB failed:',e));

// ---- TREES ‚Äî realistic collection ----
if(PERF.extraGltf)glbLoader.load('models/trees/realistic_trees_collection.glb',gltf=>{
    const root=gltf.scene;root.updateMatrixWorld(true);
    // Extract individual tree types
    const treeTypes=[];
    const treeNames=['Tree EZTree0.Large','Tree EZTree0.Medium010','Tree EZTree0.Medium011',
        'Tree EZTree1.Bush006','Tree EZTree1.Large001','Tree EZTree1.Large009','Tree EZTree1.Medium002'];
    treeNames.forEach(n=>{const c=extractChild(root,n);if(c)treeTypes.push(c);});
    if(!treeTypes.length){console.warn('No trees found in pack');return;}
    // Scatter realistic trees ‚Äî replace some procedural ones
    let placed=0;const maxTrees=52;
    while(placed<maxTrees){
        const x=(Math.random()-.5)*300,z=(Math.random()-.5)*280;
        if(roadDist(x,z)<5||z<-50)continue;
        const y=terrainHeight(x,z);if(y<-.3)continue;
        const tIdx=Math.floor(Math.random()*treeTypes.length);
        const isBush=treeTypes[tIdx].name.includes('Bush');
        const targetH=isBush?1.5+Math.random()*2:5+Math.random()*6;
        placeGLB(treeTypes[tIdx],x,z,targetH,Math.random()*Math.PI*2);
        placed++;}
    // Line trees along road edges for avenues ‚Äî skip any spot ON a crossing road
    for(let z2=-55;z2<70;z2+=12){
        if(Math.abs(z2)<10)continue; // skip main intersection
        if(roadDist(10,z2)>=1) placeGLB(treeTypes[0%treeTypes.length],10,z2,7+Math.random()*3,Math.random()*6);
        if(roadDist(-10,z2)>=1) placeGLB(treeTypes[1%treeTypes.length],-10,z2,7+Math.random()*3,Math.random()*6);}
    for(let x2=-55;x2<55;x2+=12){
        if(Math.abs(x2)<10)continue;
        if(roadDist(x2,10)>=1) placeGLB(treeTypes[2%treeTypes.length],x2,10,6+Math.random()*3,Math.random()*6);
        if(roadDist(x2,-10)>=1) placeGLB(treeTypes[3%treeTypes.length],x2,-10,6+Math.random()*3,Math.random()*6);}
    console.log(`Trees: ${treeTypes.length} types, ${placed} scattered + avenue trees`);
},undefined,e=>console.warn('Trees GLB failed:',e));

/* ====== GAME LOOP ====== */
const clock=new THREE.Clock();
setTimeout(()=>{const ld=document.getElementById("loading");ld.style.opacity="0";setTimeout(()=>ld.remove(),800);},800);
const CAR_R=1.0;const NPC_R=1.4;const AVATAR_R=0.4;
let _camShake=0;
const frameBudget=PERF.fpsCap>0?1/PERF.fpsCap:0;
let frameAccum=0;

function tick(){
    requestAnimationFrame(tick);
    try{
    const rawDt=clock.getDelta(),t=clock.getElapsedTime();
    if(frameBudget>0){frameAccum+=rawDt;if(frameAccum<frameBudget)return;}
    const dt=Math.min(frameBudget>0?frameAccum:rawDt,.033);
    if(frameBudget>0)frameAccum=0;
    const wF=pressed.has("f"),wB=pressed.has("b"),wL=pressed.has("l"),wR=pressed.has("r"),bst=pressed.has("x");

    // Dead state ‚Äî freeze and tick only combat visuals
    if(state.isDead){
        tickDebris(dt);tickFireball(dt);
        if(_muzzleLight.intensity>0)_muzzleLight.intensity=Math.max(0,_muzzleLight.intensity-dt*40);
        if(composer)composer.render();else renderer.render(scene,camera);
        return;
    }

    // ====== MODE: DRIVING ======
    if(state.mode==="driving"){
    const accel=bst?34:24,brake=38,revRate=14,drag=7,mxF=bst?45:32,mxR=-14;
    if(wF){if(state.speed<0){state.speed+=brake*dt;if(state.speed>0)state.speed=0;}else state.speed+=accel*dt;}
    if(wB){if(state.speed>.5){state.speed-=brake*dt;if(state.speed<0)state.speed=0;}else state.speed-=revRate*dt;}
    if(!wF&&!wB){if(Math.abs(state.speed)<.2)state.speed=0;else state.speed-=Math.sign(state.speed)*drag*dt;}
    state.speed=Math.max(mxR,Math.min(mxF,state.speed));
    if(Math.abs(state.speed)>.8)unlock("ignite");state.maxSpeed=Math.max(state.maxSpeed,Math.abs(state.speed));if(state.maxSpeed*4.2>120)unlock("speed");
    const si=(wL?1:0)-(wR?1:0);
    if(Math.abs(state.speed)>.3){const sn2=Math.min(Math.abs(state.speed)/mxF,1);const steer=si*(2+sn2*2.5)*dt;car.rotation.y+=steer*(state.speed<0?-.6:1);state.speed*=1-Math.min(Math.abs(steer)*2.2,.12);}
    const dir=new THREE.Vector3(-Math.sin(car.rotation.y),0,-Math.cos(car.rotation.y));
    car.position.addScaledVector(dir,state.speed*dt);
    car.position.x=THREE.MathUtils.clamp(car.position.x,-160,160);car.position.z=THREE.MathUtils.clamp(car.position.z,-68,160);
    const cp=car.position;
    // STATIC COLLISIONS
    for(const box of staticCol){
        const nx2=Math.max(box.min.x,Math.min(cp.x,box.max.x)),nz2=Math.max(box.min.z,Math.min(cp.z,box.max.z));
        const dx=cp.x-nx2,dz=cp.z-nz2,dist=Math.sqrt(dx*dx+dz*dz);
        if(dist<CAR_R&&dist>.01){const push=(CAR_R-dist)/dist;cp.x+=dx*push;cp.z+=dz*push;state.speed*=.5;}
        else if(dist<.01&&cp.x>=box.min.x&&cp.x<=box.max.x&&cp.z>=box.min.z&&cp.z<=box.max.z){
            const pushX=Math.min(cp.x-box.min.x,box.max.x-cp.x),pushZ=Math.min(cp.z-box.min.z,box.max.z-cp.z);
            if(pushX<pushZ)cp.x+=(cp.x-box.min.x<box.max.x-cp.x)?-pushX-CAR_R:pushX+CAR_R;
            else cp.z+=(cp.z-box.min.z<box.max.z-cp.z)?-pushZ-CAR_R:pushZ+CAR_R;
            state.speed*=.4;
        }
    }
    // DYNAMIC COLLISIONS
    for(const d of dynCol){const dp=d.mesh.position;const dx=dp.x-cp.x,dz=dp.z-cp.z;const dist=Math.sqrt(dx*dx+dz*dz);
        if(dist<CAR_R+.8&&Math.abs(state.speed)>.5){const imp=new THREE.Vector3(dx,.5,dz).normalize().multiplyScalar(Math.max(Math.abs(state.speed)*1.5,3));
        d.vel.add(imp);state.speed*=.92;state.crashes++;if(state.crashes>=10)unlock("crash");audio.chime(200,.08);}}
    for(const d of dynCol){if(d.vel.lengthSq()<.01)continue;d.mesh.position.addScaledVector(d.vel,dt);d.mesh.rotation.x+=d.vel.z*dt*2;d.mesh.rotation.z-=d.vel.x*dt*2;d.vel.y-=15*dt;d.vel.multiplyScalar(.96);
    const gy2=terrainHeight(d.mesh.position.x,d.mesh.position.z);if(d.mesh.position.y<gy2+.3){d.mesh.position.y=gy2+.3;d.vel.y=Math.abs(d.vel.y)*.3;d.vel.x*=.85;d.vel.z*=.85;}}
    // NPC CAR COLLISIONS
    const absSpd=Math.abs(state.speed);
    for(const npc of npcCars){
        const np=npc.position;
        const dx=cp.x-np.x,dz=cp.z-np.z;
        const dist=Math.sqrt(dx*dx+dz*dz);
        const minDist=CAR_R+NPC_R;
        if(dist>=minDist||dist<.01)continue;
        const nx3=dx/dist,nz3=dz/dist;
        const overlap=minDist-dist;
        cp.x+=nx3*overlap*.6;cp.z+=nz3*overlap*.6;
        np.x-=nx3*overlap*.4;np.z-=nz3*overlap*.4;
        const playerVn=state.speed*(dir.x*nx3+dir.z*nz3);
        let npcVn=0;
        if(npc.userData.route&&npc.userData._crashed<=0){
            const r=npc.userData.route,pts=r.pts;
            const i0=npc.userData.wpIdx,i1=(i0+1)%pts.length;
            const rdx=pts[i1][0]-pts[i0][0],rdz=pts[i1][1]-pts[i0][1];
            const rLen=Math.hypot(rdx,rdz);
            if(rLen>.01){npcVn=r.speed*((-rdx/rLen)*nx3+(-rdz/rLen)*nz3);}
        }
        const e2=0.55;
        const relVn=playerVn-npcVn;
        if(relVn>0)continue;
        const impulse=-(1+e2)*relVn*0.5;
        const impactForce=Math.abs(impulse);
        state.speed+=impulse*(dir.x*nx3+dir.z*nz3)*.8;
        state.speed=THREE.MathUtils.clamp(state.speed,-mxF*.6,mxF*.6);
        const npcImpulse=Math.max(impactForce*1.2,absSpd*.4);
        npc.userData._vel.x-=nx3*npcImpulse*.7;
        npc.userData._vel.z-=nz3*npcImpulse*.7;
        npc.userData._vel.y=Math.min(npcImpulse*.08,2);
        npc.userData._angVel=(Math.random()-.5)*npcImpulse*.5;
        npc.userData._crashed=Math.max(npc.userData._crashed,1.5+impactForce*.15);
        _camShake=Math.max(_camShake,Math.min(impactForce*.25,2.0));
        state.crashes++;if(state.crashes>=10)unlock("crash");
        audio.chime(80+impactForce*5,Math.min(impactForce*.04,.3));
    }
    // NPC car sliding physics
    for(const npc of npcCars){
        const v=npc.userData._vel;
        if(!v||v.lengthSq()<.005)continue;
        if(npc.userData.route&&npc.userData._crashed<=0)continue;
        npc.position.addScaledVector(v,dt);
        v.y-=15*dt;
        const gy2=Math.max(terrainHeight(npc.position.x,npc.position.z),ROAD_Y);
        if(npc.position.y<gy2){npc.position.y=gy2;v.y=Math.abs(v.y)*.15;v.x*=.88;v.z*=.88;}
        v.multiplyScalar(.94);
        if(npc.userData._angVel){npc.rotation.y+=npc.userData._angVel*dt;npc.userData._angVel*=.93;}
        if(v.lengthSq()<.005){v.set(0,0,0);npc.userData._angVel=0;}
    }
    // HOT LAP: Gate collision detection
    if(state.hotlapActive&&hotlapGates.length>0&&state.gatesHit<state.totalGates){
        const nextGate=hotlapGates[state.gatesHit];
        if(nextGate&&!nextGate.hit){
            const gd=cp.distanceTo(nextGate.pos);
            if(gd<5){
                nextGate.hit=true;
                state.gatesHit++;
                audio.chime(880,.1);setTimeout(()=>audio.chime(1100,.08),100);
                showToast(`Gate ${state.gatesHit} / ${state.totalGates}`);
                updateGateVisuals();
                updateQuestTracker();
                // Animate gate disappear
                nextGate.group.visible=false;
            }
        }
    }
    // Ground following
    const gy=terrainHeight(cp.x,cp.z);
    cp.y=THREE.MathUtils.lerp(cp.y,gy,.6);
    carShadow.position.set(cp.x,gy+.03,cp.z);
    carShadow.scale.set(carShadowW,carShadowD,1);
    const rv=new THREE.Vector3(dir.z,0,-dir.x);
    const hF=terrainHeight(cp.x+dir.x*1.6,cp.z+dir.z*1.6),hB=terrainHeight(cp.x-dir.x*1.6,cp.z-dir.z*1.6);
    const hL=terrainHeight(cp.x-rv.x*.9,cp.z-rv.z*.9),hR=terrainHeight(cp.x+rv.x*.9,cp.z+rv.z*.9);
    car.rotation.x=THREE.MathUtils.lerp(car.rotation.x,-Math.atan2(hF-hB,3.2),.2);
    car.rotation.z=THREE.MathUtils.lerp(car.rotation.z,Math.atan2(hR-hL,1.8),.2);
    car.userData.wheels.forEach((w,i)=>{w.rotation.x-=state.speed*dt*2;if(i<2)w.rotation.y=((wL?1:0)-(wR?1:0))*.22;});
    speedEl.textContent=`${Math.round(Math.abs(state.speed)*4.2)} km/h`;
    districtEl.textContent=getDistrict(cp.x,cp.z);
    audio.update(state.speed,wF?1:0);
    orbs.forEach(o=>{if(!o.visible)return;o.rotation.y+=.025;o.position.y+=Math.sin(t*3+o.position.x)*.004;if(cp.distanceTo(o.position)<2.2){o.visible=false;state.collectibles.add(o.userData.id);audio.chime(1100,.09);if(state.collectibles.size===orbs.length)unlock("collector");}});
    // Billboard proximity ‚Äî park in bay
    let nearBB=null,nearD=Infinity;billboards.forEach(b=>{const d2=cp.distanceTo(b.bayPos);if(d2<nearD){nearD=d2;nearBB=b;}});
    const parked=nearD<4&&Math.abs(state.speed)<.4&&nearBB;
    if(parked){
        state.canInteract=nearBB.project;const di=DISTRICTS[nearBB.project.district];
        promptEl.innerHTML=`<strong>${nearBB.project.t}</strong><span class="dt ${di.dtClass}">${di.label}</span><br><span style="font-size:.7rem;color:var(--s)">F to exit car ¬∑ E to open project</span>`;
        promptEl.classList.add("show");renderer.domElement.style.cursor="pointer";
    }else{state.canInteract=null;promptEl.classList.remove("show");renderer.domElement.style.cursor="default";}
    updateArcade(t,dt,parked,nearBB);
    // Driving camera
    const sn=Math.min(Math.abs(state.speed)/32,1);
    if(zoomFactor<.25){
        const fwd=dir.clone().multiplyScalar(.8);const up=new THREE.Vector3(0,1.8+(.25-zoomFactor)*4,0);
        const driverPos=cp.clone().add(fwd).add(up);
        camera.position.lerp(driverPos,1-Math.exp(-dt*8));
        const lookFwd=cp.clone().add(dir.clone().multiplyScalar(20)).add(new THREE.Vector3(0,1.5,0));
        camera.lookAt(lookFwd.x,lookFwd.y,lookFwd.z);
    }else{
        const baseDist=(14+sn*4)*zoomFactor,baseH=(7+sn*2)*zoomFactor;
        const dc=cp.clone().add(new THREE.Vector3(-dir.x*baseDist,baseH,-dir.z*baseDist));
        camera.position.lerp(dc,1-Math.exp(-dt*4.5));camera.lookAt(cp.x,cp.y+1.2,cp.z);
    }
    } // end driving mode

    // ====== MODE: WALKING ======
    else if(state.mode==="walking"){
    const WALK_SPEED=bst?8:5;
    // Always use the normal avatar ‚Äî gun is attached separately
    const activeAvatar=avatar;
    const ap=avatar.position;
    // Camera yaw defines the "forward" direction for movement
    const fwdX=-Math.sin(_camYaw),fwdZ=-Math.cos(_camYaw);
    const rightX=fwdZ,rightZ=-fwdX; // perpendicular (strafe)
    // W/S = forward/backward along camera yaw, A/D = strafe left/right
    const moveDir=new THREE.Vector3();
    if(wF){moveDir.x+=fwdX;moveDir.z+=fwdZ;}
    if(wB){moveDir.x-=fwdX;moveDir.z-=fwdZ;}
    if(wL){moveDir.x+=rightX;moveDir.z+=rightZ;} // strafe left
    if(wR){moveDir.x-=rightX;moveDir.z-=rightZ;} // strafe right
    const moving=moveDir.lengthSq()>0.01;
    if(moving){
        moveDir.normalize();
        ap.addScaledVector(moveDir,WALK_SPEED*dt);
        if(state.gunEquipped){
            // In gun mode: avatar faces camera direction
            state.avatarAngle=_camYaw;
            activeAvatar.rotation.y=_camYaw;
        }else{
            // Target angle: avatar always faces direction of travel
            const targetAngle=Math.atan2(-moveDir.x,-moveDir.z);
            let diff=targetAngle-state.avatarAngle;
            while(diff>Math.PI)diff-=Math.PI*2;
            while(diff<-Math.PI)diff+=Math.PI*2;
            state.avatarAngle+=diff*Math.min(dt*12,1);
            activeAvatar.rotation.y=state.avatarAngle;
        }
    }else if(state.gunEquipped){
        state.avatarAngle=_camYaw;
        activeAvatar.rotation.y=_camYaw;
    }
    // Clamp world bounds
    ap.x=THREE.MathUtils.clamp(ap.x,-160,160);ap.z=THREE.MathUtils.clamp(ap.z,-68,160);
    // Ground follow
    const agy=Math.max(terrainHeight(ap.x,ap.z),ROAD_Y);
    ap.y=THREE.MathUtils.lerp(ap.y,agy,.5);
    // Static collision for avatar
    for(const box of staticCol){
        const nx2=Math.max(box.min.x,Math.min(ap.x,box.max.x)),nz2=Math.max(box.min.z,Math.min(ap.z,box.max.z));
        const dx=ap.x-nx2,dz=ap.z-nz2,dist=Math.sqrt(dx*dx+dz*dz);
        if(dist<AVATAR_R&&dist>.01){const push=(AVATAR_R-dist)/dist;ap.x+=dx*push;ap.z+=dz*push;}
    }
    // Walking animation ‚Äî always runs on the normal avatar
    {
        const ud=avatar.userData;
        if(ud.mixer){
            ud.mixer.update(dt);
            if(ud.walkAction){
                if(moving){
                    if(ud.walkAction.paused){ud.walkAction.paused=false;}
                    if(!ud.walkAction.isRunning()){
                        if(ud.idleAction)ud.idleAction.fadeOut(.2);
                        ud.walkAction.reset().fadeIn(.2).play();
                    }
                }else{
                    if(ud.idleAction&&ud.walkAction.isRunning()){
                        ud.walkAction.fadeOut(.2);
                        ud.idleAction.reset().fadeIn(.2).play();
                    }else if(!ud.idleAction){
                        ud.walkAction.paused=true;
                    }
                }
            }
        }else if(ud._fallback){
            if(moving){
                ud.walkTime+=dt*8;
                const sw=Math.sin(ud.walkTime)*.4;
                if(ud.lLeg){ud.lLeg.rotation.x=sw;ud.rLeg.rotation.x=-sw;}
            }else{
                ud.walkTime=0;
                if(ud.lLeg){ud.lLeg.rotation.x=0;ud.rLeg.rotation.x=0;}
            }
        }
        // Subtle bob when walking
        if(moving){avatar.userData.walkTime=(avatar.userData.walkTime||0)+dt*8;ap.y+=Math.abs(Math.sin((avatar.userData.walkTime||0)*2))*.03;}
    }
    // Proximity checks ‚Äî NPC, billboards, car
    const npcDist=ap.distanceTo(npcGuide.position);
    // Check billboards on foot ‚Äî use billboard board position (not bay)
    let _walkBB=null,_walkBBd=Infinity;
    billboards.forEach(b=>{const d2=ap.distanceTo(b.group.position);if(d2<_walkBBd){_walkBBd=d2;_walkBB=b;}});
    const nearBBOnFoot=_walkBBd<5&&_walkBB;
    if(npcDist<4){
        promptEl.innerHTML=`<strong>${npcGuide.userData.name}</strong> ‚Äî Press <b>E</b> to talk`;
        promptEl.classList.add("show");
        state.nearNPC=true;
        state.canInteract=null;
    }else if(nearBBOnFoot){
        state.nearNPC=false;
        state.canInteract=_walkBB.project;
        const di=DISTRICTS[_walkBB.project.district];
        promptEl.innerHTML=`<strong>${_walkBB.project.t}</strong><span class="dt ${di.dtClass}">${di.label}</span><br><span style="font-size:.7rem;color:var(--s)">E to open project</span>`;
        promptEl.classList.add("show");
        renderer.domElement.style.cursor="pointer";
    }else{
        state.nearNPC=false;
        state.canInteract=null;
        // Car proximity ‚Äî show re-enter prompt
        if(state.carParkedAt&&ap.distanceTo(state.carParkedAt)<4){
            promptEl.innerHTML=`Press <b>F</b> to enter car`;
            promptEl.classList.add("show");
        }else{
            promptEl.classList.remove("show");
            renderer.domElement.style.cursor="default";
        }
    }
    // Activate arcade glow frame around billboard when on foot
    updateArcade(t,dt,nearBBOnFoot,_walkBB);
    districtEl.textContent=getDistrict(ap.x,ap.z);
    speedEl.textContent="On Foot";
    audio.update(0,0);
    // Walking camera
    if(state.gunEquipped){
        // TRUE FPS Over-The-Shoulder camera
        const cosPitch=Math.cos(_camPitch);
        const aimX=-Math.sin(_camYaw)*cosPitch;
        const aimY=-Math.sin(_camPitch);
        const aimZ=-Math.cos(_camYaw)*cosPitch;
        const aimRightX=Math.cos(_camYaw),aimRightZ=-Math.sin(_camYaw);
        // Camera positioned behind right shoulder
        const shoulderBack=3.0,shoulderRight=1.0,shoulderH=1.9;
        const camPos=new THREE.Vector3(
            ap.x-aimX*shoulderBack+aimRightX*shoulderRight,
            ap.y+shoulderH+aimY*0.5,
            ap.z-aimZ*shoulderBack+aimRightZ*shoulderRight
        );
        camera.position.lerp(camPos,1-Math.exp(-dt*14));
        // Camera looks where the crosshair points
        const lookTarget=new THREE.Vector3(
            camera.position.x+aimX*50,
            camera.position.y+aimY*50,
            camera.position.z+aimZ*50
        );
        camera.lookAt(lookTarget);

        // Position gun at avatar's right hand, raised and pointing at crosshair
        const gunOffRight=0.5,gunOffForward=0.35,gunOffUp=1.2;
        gunPivot.position.set(
            ap.x+aimRightX*gunOffRight-Math.sin(_camYaw)*gunOffForward,
            ap.y+gunOffUp,
            ap.z+aimRightZ*gunOffRight-Math.cos(_camYaw)*gunOffForward
        );
        // Gun yaw matches camera yaw, pitch tracks the crosshair target
        gunPivot.rotation.set(0,_camYaw,0);
        gunGroup.rotation.set(-_camPitch,0,0); // negative pitch = gun tilts up when looking up

        // Auto-fire when holding LMB
        if(_shooting){shootGun();}
    }else{
        // Normal walking camera ‚Äî orbits around avatar based on mouse yaw/pitch
        const camDist=6*zoomFactor;
        const camOX=Math.sin(_camYaw)*Math.cos(_camPitch)*camDist;
        const camOZ=Math.cos(_camYaw)*Math.cos(_camPitch)*camDist;
        const camOY=Math.sin(_camPitch)*camDist+1.2;
        const targetCam=new THREE.Vector3(ap.x+camOX,ap.y+camOY,ap.z+camOZ);
        camera.position.lerp(targetCam,1-Math.exp(-dt*8));
        camera.lookAt(ap.x,ap.y+1.2,ap.z);
    }
    } // end walking mode

    // ====== MODE: DIALOG ======
    // (No movement, camera stays put)

    // ====== SHARED: always runs ======
    // Combat systems tick
    if(_shootCooldown>0)_shootCooldown-=dt;
    if(_tracerTimer>0){_tracerTimer-=dt;if(_tracerTimer<=0)_tracerLine.visible=false;}
    if(_muzzleLight.intensity>0)_muzzleLight.intensity=Math.max(0,_muzzleLight.intensity-dt*40);
    tickDebris(dt);
    tickFireball(dt);
    // Gate pulse animation
    if(state.hotlapActive&&hotlapGates.length>0){
        const nextIdx=state.gatesHit;
        if(nextIdx<hotlapGates.length){
            const g=hotlapGates[nextIdx];
            if(g&&!g.hit&&g.group.visible){
                g.torus.material.opacity=0.6+Math.sin(t*4)*0.3;
                g.torus.rotation.x=Math.sin(t*2)*.1;
            }
        }
    }
    // Quest objective tracking
    const activeQ=QUESTS.find(q=>q.status==="active");
    if(activeQ&&activeQ.objective()&&activeQ.status==="active"){
        activeQ.status="complete";
        updateNPCIcon();updateQuestTracker();
        // Big celebration fanfare when objectives complete ‚Äî clearly tells player what to do
        showObjectiveCompleteFanfare(activeQ);
    }
    // NPC wander AI ‚Äî patrol waypoints, idle pauses, face player when near
    const npcD=npcGuide.userData;
    if(npcD.mixer)npcD.mixer.update(dt);
    // Determine player position for proximity
    const _playerPos=state.mode==="walking"?avatar.position:car.position;
    const _wizPlayerDist=npcGuide.position.distanceTo(_playerPos);
    const _wizNearPlayer=_wizPlayerDist<6&&state.mode==="walking";
    if(state.mode==="dialog"||_wizNearPlayer){
        // Freeze wizard: dialog or player is nearby ‚Äî face the player
        npcGuide.position.y=npcD.baseY+Math.sin(t*1.5)*.06;
        if(_wizNearPlayer||state.mode==="dialog"){
            const toPlayer=Math.atan2(_playerPos.x-npcGuide.position.x,-(_playerPos.z-npcGuide.position.z));
            npcGuide.rotation.y=toPlayer;
        }
        // Switch to idle if was walking
        if(!npcD.isIdle&&npcD.walkAction&&npcD.idleAction){
            npcD.idleAction.setEffectiveWeight(1);
            npcD.walkAction.setEffectiveWeight(0);
        }
    }else{
        if(npcD.isIdle){
            // Idle pause ‚Äî gentle bob
            npcGuide.position.y=npcD.baseY+Math.sin(t*1.5)*.06;
            npcD.idleTimer-=dt;
            if(npcD.idleTimer<=0){
                // Pick next waypoint
                npcD.wpIdx=(npcD.wpIdx+1)%_wizWaypoints.length;
                npcD.isIdle=false;
                // Cross-fade to walk animation
                if(npcD.walkAction&&npcD.idleAction){
                    npcD.walkAction.setEffectiveWeight(1);npcD.walkAction.time=0;
                    npcD.idleAction.setEffectiveWeight(0);
                }
            }
        }else{
            // Walking toward waypoint
            const wp=_wizWaypoints[npcD.wpIdx];
            const dx=wp[0]-npcGuide.position.x, dz=wp[1]-npcGuide.position.z;
            const dist=Math.sqrt(dx*dx+dz*dz);
            if(dist<2){
                // Arrived ‚Äî start idle pause
                npcD.isIdle=true;
                npcD.idleTimer=3+Math.random()*5;
                npcD.baseY=Math.max(terrainHeight(npcGuide.position.x,npcGuide.position.z),ROAD_Y);
                npcGuide.position.y=npcD.baseY;
                if(npcD.walkAction&&npcD.idleAction){
                    npcD.idleAction.setEffectiveWeight(1);
                    npcD.walkAction.setEffectiveWeight(0);
                }
            }else{
                let nx=dx/dist, nz=dz/dist;
                const spd=npcD.wanderSpeed*dt;
                const nextX=npcGuide.position.x+nx*spd;
                const nextZ=npcGuide.position.z+nz*spd;
                // Avoid roads ‚Äî if next step is on a road, steer perpendicular
                if(roadDist(nextX,nextZ)<3){
                    // Try perpendicular directions
                    const px=-nz, pz=nx; // rotate 90¬∞
                    if(roadDist(npcGuide.position.x+px*spd*3,npcGuide.position.z+pz*spd*3)>3){
                        nx=px;nz=pz;
                    }else{nx=-px;nz=-pz;}
                }
                // Avoid the car ‚Äî steer away if too close
                const carDx=npcGuide.position.x-car.position.x;
                const carDz=npcGuide.position.z-car.position.z;
                const carD=Math.sqrt(carDx*carDx+carDz*carDz);
                if(carD<8&&carD>0.1){
                    const pushStr=Math.max(0,(8-carD)/8)*.6;
                    nx+=carDx/carD*pushStr;
                    nz+=carDz/carD*pushStr;
                    const len=Math.sqrt(nx*nx+nz*nz);
                    if(len>0){nx/=len;nz/=len;}
                }
                npcGuide.position.x+=nx*spd;
                npcGuide.position.z+=nz*spd;
                // Clamp to world bounds
                npcGuide.position.x=THREE.MathUtils.clamp(npcGuide.position.x,-70,70);
                npcGuide.position.z=THREE.MathUtils.clamp(npcGuide.position.z,-65,70);
                npcD.baseY=Math.max(terrainHeight(npcGuide.position.x,npcGuide.position.z),ROAD_Y);
                npcGuide.position.y=npcD.baseY+Math.sin(t*3)*.03;
                npcGuide.rotation.y=Math.atan2(nx,-nz);
            }
        }
    }
    // Quest icon pulse ‚Äî large, no circle bg, bold text
    const iconS=1.6+Math.sin(t*3)*.25;
    npcD.iconGroup.children.forEach(sp=>{if(sp.visible)sp.scale.set(iconS,iconS,1);});
    npcD.iconGroup.rotation.y=t*.5;
    // NPC speech bubble
    updateSpeechBubble(t,dt);
    // Camera shake from crashes
    if(_camShake>.01){
        camera.position.x+=(Math.random()-.5)*_camShake*.35;
        camera.position.y+=(Math.random()-.5)*_camShake*.2;
        camera.position.z+=(Math.random()-.5)*_camShake*.35;
        _camShake*=.85;
    }
    // Season cycle
    const si3=Math.floor(t/50)%4;if(si3!==state.seasonIndex){state.seasonIndex=si3;applySeason();}seasonEl.textContent=["Spring","Summer","Autumn","Winter"][si3];
    // Sun, water, windmill, NPC cars, leaves
    const so=t*.04;sun.position.set(Math.cos(so)*100,80+Math.sin(so*.6)*20,Math.sin(so)*60);sunSphere.position.copy(sun.position.clone().setLength(170));
    waterMat.uniforms.uTime.value=t;bladeGroup.rotation.z+=dt*.5;
    if(window._npcTick)window._npcTick(t,dt);
    // Cam position for proximity checks
    const cpRef=state.mode==="driving"?car.position:avatar.position;
    for(let i=0;i<LEAF_N;i++){const i3=i*3;leafPos[i3]+=(Math.sin(t*.7+i*2.3)*.2+.03)*dt*12;leafPos[i3+1]-=(.6+Math.sin(t+i)*.15)*dt*2;leafPos[i3+2]+=Math.cos(t*.5+i*1.7)*.15*dt*12;if(leafPos[i3+1]<0){leafPos[i3+1]=22+Math.random()*12;leafPos[i3]=cpRef.x+(Math.random()-.5)*100;leafPos[i3+2]=cpRef.z+(Math.random()-.5)*100;}}leafGeo.attributes.position.needsUpdate=true;
    // GIF textures
    const gf=Math.floor(t*10);
    if(gf!==tick._lg){tick._lg=gf;
        const parked2=state.mode==="driving"&&state.canInteract;
        billboards.forEach(b=>{
            const gd=gifData[b.gifIdx];if(!gd.loaded||gd._failed)return;
            const d2=cpRef.distanceTo(b.group.position);
            const isParkedHere=parked2&&state.canInteract&&state.canInteract.t===b.project.t;
            if(isParkedHere){
                if(gd._dec&&gd._fCount>0&&!gd._busy){
                    gd._busy=true;
                    gd._dec.decode({frameIndex:gd._fIdx}).then(result=>{
                        const c=gd.ctx;
                        c.drawImage(result.image,0,0,512,256);
                        result.image.close();
                        c.fillStyle="rgba(0,0,0,.55)";c.fillRect(424,6,80,26);
                        c.fillStyle="#ff3344";c.beginPath();c.arc(438,19,5,0,Math.PI*2);c.fill();
                        c.fillStyle="#fff";c.font="bold 12px Segoe UI";c.fillText("LIVE",450,24);
                        const gr=c.createLinearGradient(0,200,0,256);gr.addColorStop(0,"rgba(0,0,0,0)");gr.addColorStop(.4,"rgba(0,0,0,.75)");gr.addColorStop(1,"rgba(0,0,0,.9)");
                        c.fillStyle=gr;c.fillRect(0,200,512,56);
                        const di=DISTRICTS[b.project.district];
                        c.fillStyle=di.color;c.font="600 11px Segoe UI";c.fillText(di.label.toUpperCase(),14,225);
                        c.fillStyle="#fff";c.font="700 16px Segoe UI";c.fillText(gd.title,14,245);
                        c.fillStyle="#00ff88";c.font="bold 10px Segoe UI";c.fillText("PRESS E TO OPEN",390,245);
                        gd.tex.needsUpdate=true;gd.playing=true;
                        gd._fIdx=(gd._fIdx+1)%gd._fCount;
                        gd._busy=false;
                    }).catch(()=>{gd._busy=false;gd._fIdx=0;});
                }else if(!gd._dec&&gd.img){
                    const c=gd.ctx;
                    c.drawImage(gd.img,0,0,512,256);
                    c.fillStyle="rgba(0,0,0,.55)";c.fillRect(424,6,80,26);
                    c.fillStyle="#ff3344";c.beginPath();c.arc(438,19,5,0,Math.PI*2);c.fill();
                    c.fillStyle="#fff";c.font="bold 12px Segoe UI";c.fillText("LIVE",450,24);
                    const gr=c.createLinearGradient(0,200,0,256);gr.addColorStop(0,"rgba(0,0,0,0)");gr.addColorStop(.4,"rgba(0,0,0,.75)");gr.addColorStop(1,"rgba(0,0,0,.9)");
                    c.fillStyle=gr;c.fillRect(0,200,512,56);
                    const di=DISTRICTS[b.project.district];
                    c.fillStyle=di.color;c.font="600 11px Segoe UI";c.fillText(di.label.toUpperCase(),14,225);
                    c.fillStyle="#fff";c.font="700 16px Segoe UI";c.fillText(gd.title,14,245);
                    c.fillStyle="#00ff88";c.font="bold 10px Segoe UI";c.fillText("PRESS E TO OPEN",390,245);
                    gd.tex.needsUpdate=true;gd.playing=true;
                }
            }else if(d2<55){
                if(gd.playing||!gd._hasStatic){
                    const c=gd.ctx;
                    if(gd.img&&gd.img.complete&&gd.img.naturalWidth>0)c.drawImage(gd.img,0,0,512,256);
                    else{c.fillStyle="#0a0a14";c.fillRect(0,0,512,256);}
                    c.fillStyle="rgba(0,0,10,.5)";c.fillRect(0,0,512,256);
                    const di=DISTRICTS[b.project.district];
                    c.fillStyle=di.color;c.font="bold 14px Segoe UI";c.fillText(di.label.toUpperCase(),20,30);
                    c.fillStyle="#fff";c.font="bold 22px Segoe UI";c.fillText(gd.title,20,65);
                    c.fillStyle="rgba(255,255,255,.5)";c.font="16px Segoe UI";c.fillText("\u25B6 Park to preview",20,100);
                    c.strokeStyle=di.color;c.lineWidth=2;c.strokeRect(2,2,508,252);
                    gd.tex.needsUpdate=true;gd.playing=false;gd._hasStatic=true;
                }
            }
        });}
    grassMat.uniforms.uTime.value=t;
    grassMat.uniforms.uCarPos.value.copy(cpRef);
    grassMat.uniforms.uCarSpeed.value=state.mode==="driving"?state.speed:0;
    grassMat.uniforms.uCamPos.value.copy(camera.position);
    if(composer)composer.render();else renderer.render(scene,camera);
    }catch(e){console.error("Loop:",e);}
}
tick();
window.addEventListener("resize",()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);renderer.setPixelRatio(Math.min(devicePixelRatio,PERF.pixelRatioCap));if(composer)composer.setSize(innerWidth,innerHeight);});
</script>
</body>
</html>
