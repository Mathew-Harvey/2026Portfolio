<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mat Harvey ‚Äî Portfolio World</title>
    <style>
        :root{--hud:rgba(10,18,12,.72);--hb:rgba(120,180,100,.22);--t:#e8f0e4;--s:#9ab892;--a:#6ec86e;--a2:#f0c060;--w:#5cc0b8}
        *{margin:0;padding:0;box-sizing:border-box}html,body{width:100%;height:100%;overflow:hidden;font-family:"Segoe UI",system-ui,sans-serif;color:var(--t);background:#1a2818;overscroll-behavior:none}
        #app{width:100%;height:100%;position:relative}canvas{display:block;width:100%;height:100%;touch-action:none}
        #loading{position:fixed;inset:0;background:linear-gradient(135deg,#1a2818,#0e180c);display:flex;align-items:center;justify-content:center;z-index:999;transition:opacity .8s}
        #loading h1{font-size:2rem;color:#8fcc6a;letter-spacing:.14em;text-transform:uppercase;font-weight:700}#loading p{margin-top:10px;color:#6a9a5c;font-size:.95rem}
        .panel{position:absolute;backdrop-filter:blur(10px);border:1px solid var(--hb);background:var(--hud);border-radius:12px;box-shadow:0 12px 28px rgba(0,0,0,.3)}
        .hud{top:14px;left:14px;width:min(360px,calc(100vw - 28px));padding:12px 14px;display:grid;gap:6px}.hud-title{font-size:.8rem;text-transform:uppercase;letter-spacing:.1em;color:var(--a);font-weight:700}
        .hud-row{display:flex;justify-content:space-between;gap:12px;font-size:.86rem}.hud-row .v{color:var(--a2);font-weight:600;text-align:right}.hint{color:var(--s);font-size:.76rem;line-height:1.4}
        .side-panel{top:14px;right:14px;width:min(300px,calc(100vw - 28px));padding:12px;display:grid;gap:7px;max-height:50vh;overflow-y:auto}
        .section-label{font-size:.72rem;text-transform:uppercase;letter-spacing:.08em;color:var(--s)}
        .badge{display:flex;align-items:center;gap:8px;font-size:.74rem;border:1px solid rgba(110,200,110,.12);border-radius:10px;color:var(--s);background:rgba(255,255,255,.02);padding:7px 10px;transition:all .25s;opacity:.45}
        .badge.on{color:#d4ffd4;border-color:rgba(110,200,110,.4);background:rgba(110,200,110,.08);opacity:1}
        .badge .badge-icon{font-size:1.3rem;flex-shrink:0;filter:grayscale(1);transition:filter .3s}
        .badge.on .badge-icon{filter:grayscale(0)}
        .badge .badge-info{display:flex;flex-direction:column;gap:1px}
        .badge .badge-title{font-weight:600;font-size:.76rem}
        .badge .badge-desc{font-size:.64rem;color:var(--s);opacity:.7}
        .badge.on .badge-desc{opacity:1}
        /* Steam-style achievement popup */
        .ach-popup{position:fixed;bottom:24px;right:24px;display:flex;align-items:center;gap:14px;padding:14px 20px 14px 16px;border-radius:12px;background:linear-gradient(135deg,rgba(20,30,18,.97),rgba(12,20,10,.98));border:1.5px solid rgba(110,200,110,.35);box-shadow:0 8px 32px rgba(0,0,0,.5),0 0 20px rgba(110,200,110,.08);z-index:58;transform:translateX(120%);transition:transform .45s cubic-bezier(.22,1,.36,1);max-width:340px}
        .ach-popup.show{transform:translateX(0)}
        .ach-popup .ach-icon{font-size:2.2rem;flex-shrink:0;animation:achBounce .5s ease-out}
        .ach-popup .ach-body{display:flex;flex-direction:column;gap:3px}
        .ach-popup .ach-label{font-size:.65rem;text-transform:uppercase;letter-spacing:.08em;color:var(--a);font-weight:600}
        .ach-popup .ach-name{font-size:.95rem;font-weight:700;color:#e0f0dc}
        .ach-popup .ach-desc{font-size:.72rem;color:var(--s)}
        .ach-popup .ach-bar{height:3px;border-radius:2px;background:rgba(110,200,110,.15);margin-top:6px;overflow:hidden}
        .ach-popup .ach-bar-fill{height:100%;width:0;background:var(--a);border-radius:2px;transition:width 3.5s linear}
        @keyframes achBounce{0%{transform:scale(0) rotate(-20deg)}50%{transform:scale(1.25) rotate(5deg)}100%{transform:scale(1) rotate(0)}}
        .prompt{position:absolute;left:50%;bottom:18px;transform:translateX(-50%);min-width:min(440px,calc(100vw - 32px));text-align:center;padding:10px 14px;font-size:.86rem;border:1px solid rgba(110,200,110,.4);background:rgba(14,22,14,.88);border-radius:12px;opacity:0;pointer-events:none;transition:opacity .2s}.prompt.show{opacity:1}
        .toast{position:absolute;left:50%;top:78px;transform:translateX(-50%) translateY(-16px);border:1px solid rgba(110,200,110,.4);background:rgba(10,24,16,.92);color:#b8ffd0;border-radius:12px;padding:9px 14px;font-size:.82rem;opacity:0;pointer-events:none;transition:all .2s}.toast.show{opacity:1;transform:translateX(-50%) translateY(0)}
        .links{position:absolute;left:14px;bottom:14px;display:flex;gap:8px}
        .btn{display:inline-flex;align-items:center;font-size:.76rem;color:#c8dcc4;border:1px solid rgba(200,220,196,.28);border-radius:8px;padding:6px 10px;text-decoration:none;background:rgba(14,22,14,.65);cursor:pointer}.btn:hover{border-color:var(--a);color:#fff}
        .dt{display:inline-block;font-size:.64rem;padding:2px 5px;border-radius:4px;margin-left:5px;font-weight:600}
        .dt-port{background:rgba(92,192,184,.15);color:var(--w)}.dt-sim{background:rgba(120,140,220,.15);color:#8898dd}.dt-tool{background:rgba(220,180,80,.15);color:var(--a2)}.dt-per{background:rgba(200,100,140,.15);color:#dd88aa}
        .dialog-overlay{position:fixed;inset:0;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:50;opacity:0;pointer-events:none;transition:opacity .25s}
        .dialog-overlay.show{opacity:1;pointer-events:auto}
        .dialog-box{width:min(520px,calc(100vw - 32px));background:linear-gradient(180deg,#e8d5a8,#d4be8a);border:3px solid #8b6914;border-radius:6px;padding:28px 32px 22px;box-shadow:0 16px 48px rgba(0,0,0,.5),inset 0 0 40px rgba(139,105,20,.1);position:relative;font-family:Georgia,"Times New Roman",serif;color:#3a2a10}
        .dialog-box::before{content:"";position:absolute;inset:6px;border:1px solid rgba(139,105,20,.25);border-radius:3px;pointer-events:none}
        .dialog-npc{font-size:.72rem;text-transform:uppercase;letter-spacing:.14em;color:#8b6914;margin-bottom:6px;font-weight:700}
        .dialog-title{font-size:1.35rem;font-weight:700;color:#2a1a05;margin-bottom:10px;border-bottom:1px solid rgba(139,105,20,.3);padding-bottom:8px}
        .dialog-text{font-size:1.02rem;color:#4a3618;line-height:1.6;margin-bottom:14px;white-space:pre-line}
        .dialog-progress{font-size:.92rem;color:#6b4e1e;margin-bottom:10px;font-style:italic}
        .dialog-btns{display:flex;gap:10px;justify-content:flex-end}
        .dialog-btn{padding:8px 20px;border:2px solid #8b6914;border-radius:4px;background:linear-gradient(180deg,#d4be8a,#c0a870);color:#3a2a10;font-size:.86rem;cursor:pointer;transition:all .15s;font-family:Georgia,serif;font-weight:600}
        .dialog-btn:hover{background:linear-gradient(180deg,#e8d5a8,#d4be8a);box-shadow:0 2px 8px rgba(139,105,20,.3)}
        .dialog-btn.primary{background:linear-gradient(180deg,#c8a030,#a08020);color:#fff;border-color:#7a5a10}
        .dialog-btn.primary:hover{background:linear-gradient(180deg,#d8b040,#b89030)}
        .garage-overlay{position:fixed;inset:0;background:rgba(0,0,0,.75);backdrop-filter:blur(6px);display:flex;align-items:center;justify-content:center;z-index:55;opacity:0;pointer-events:none;transition:opacity .35s}
        .garage-overlay.show{opacity:1;pointer-events:auto}
        .garage-modal{background:linear-gradient(160deg,rgba(14,26,12,.97),rgba(8,18,6,.98));border:1.5px solid rgba(110,200,110,.25);border-radius:20px;padding:32px 40px 28px;max-width:600px;width:92vw;box-shadow:0 20px 60px rgba(0,0,0,.6),0 0 40px rgba(110,200,110,.06);position:relative}
        .garage-close{position:absolute;top:14px;right:18px;background:none;border:none;color:#8a9a80;font-size:1.4rem;cursor:pointer;transition:color .2s;line-height:1}
        .garage-close:hover{color:#fff}
        .garage-header{text-align:center;margin-bottom:18px}
        .garage-title{font-family:Georgia,serif;font-size:1.6rem;font-weight:700;color:#ffd700;letter-spacing:.08em;text-transform:uppercase;text-shadow:0 0 18px rgba(255,215,0,.25)}
        .garage-subtitle{font-size:.8rem;color:#8a9a80;margin-top:4px;letter-spacing:.04em}
        .garage-carousel{display:flex;align-items:center;gap:14px}
        .garage-nav{width:44px;height:44px;border-radius:50%;border:2px solid rgba(110,200,110,.35);background:rgba(14,24,12,.85);color:var(--a);font-size:1.4rem;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .2s;flex-shrink:0}
        .garage-nav:hover{background:rgba(110,200,110,.18);border-color:var(--a);transform:scale(1.08)}
        .garage-stage{flex:1;display:flex;flex-direction:column;align-items:center}
        .garage-preview{width:100%;aspect-ratio:16/10;border-radius:14px;overflow:hidden;background:radial-gradient(ellipse at 50% 60%,rgba(30,50,25,.85),rgba(8,16,6,.98));border:1.5px solid rgba(110,200,110,.18);box-shadow:inset 0 -40px 50px -30px rgba(110,200,110,.04);position:relative}
        .garage-preview canvas{width:100%;height:100%;display:block}
        .garage-preview .locked-overlay{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(0,0,0,.55);font-size:2.4rem}
        .garage-preview .locked-text{font-size:.82rem;color:#776;margin-top:8px}
        .garage-info{margin-top:14px;text-align:center}
        .garage-car-name{font-family:Georgia,serif;font-size:1.3rem;font-weight:700;color:#e0f0dc;margin-bottom:3px}
        .garage-car-desc{font-size:.82rem;color:var(--s);max-width:380px}
        .garage-car-badge{display:inline-block;margin-top:8px;padding:3px 12px;border-radius:6px;font-size:.72rem;font-weight:700;letter-spacing:.06em;text-transform:uppercase}
        .garage-car-badge.current{background:rgba(110,200,110,.15);color:var(--a);border:1px solid rgba(110,200,110,.35)}
        .garage-car-badge.available{background:rgba(255,215,0,.12);color:#ffd700;border:1px solid rgba(255,215,0,.3)}
        .garage-car-badge.locked{background:rgba(80,80,60,.15);color:#665;border:1px solid rgba(80,80,60,.3)}
        .garage-select-btn{margin-top:14px;padding:10px 36px;border:2px solid rgba(110,200,110,.5);border-radius:10px;background:rgba(110,200,110,.1);color:var(--a);font-size:.95rem;font-weight:600;cursor:pointer;transition:all .2s;letter-spacing:.04em}
        .garage-select-btn:hover{background:rgba(110,200,110,.22);border-color:var(--a);box-shadow:0 0 14px rgba(110,200,110,.12)}
        .garage-select-btn:disabled{opacity:.35;cursor:default;box-shadow:none}
        .garage-dots{display:flex;gap:8px;margin-top:16px}
        .garage-dot{width:10px;height:10px;border-radius:50%;background:rgba(110,200,110,.18);border:1px solid rgba(110,200,110,.3);cursor:pointer;transition:all .2s}
        .garage-dot.active{background:var(--a);box-shadow:0 0 8px rgba(110,200,110,.4);transform:scale(1.15)}
        .garage-dot.locked{background:rgba(80,80,60,.25);border-color:rgba(80,80,60,.35)}
        .garage-counter{font-size:.72rem;color:#8a9a80;margin-top:8px;letter-spacing:.04em}
        .garage-hint{position:absolute;bottom:14px;left:0;right:0;text-align:center;font-size:.7rem;color:#666;letter-spacing:.03em}
        .mode-badge{position:absolute;top:14px;left:50%;transform:translateX(-50%);padding:5px 14px;border-radius:8px;font-size:.74rem;font-weight:600;letter-spacing:.08em;text-transform:uppercase;opacity:0;pointer-events:none;transition:opacity .3s;z-index:20}
        .mode-badge.show{opacity:1}
        .mode-badge.walk{background:rgba(110,200,110,.15);border:1px solid rgba(110,200,110,.4);color:var(--a)}
        .mode-badge.dialog{background:rgba(240,192,96,.15);border:1px solid rgba(240,192,96,.4);color:var(--a2)}
        .quest-tracker{position:absolute;bottom:60px;right:14px;width:min(300px,calc(100vw - 28px));padding:16px 18px 14px;border-radius:6px;border:2px solid #8b6914;background:linear-gradient(180deg,rgba(232,213,168,.94),rgba(212,190,138,.96));backdrop-filter:blur(6px);box-shadow:0 4px 16px rgba(0,0,0,.25);opacity:0;pointer-events:none;transition:opacity .3s;font-family:Georgia,serif;color:#3a2a10}
        .quest-tracker.show{opacity:1}
        .quest-tracker .qt{font-size:1rem;font-weight:700;color:#2a1a05;margin-bottom:8px;border-bottom:1px solid rgba(139,105,20,.25);padding-bottom:6px}
        .quest-tracker .qobj{font-size:.9rem;color:#5a4020;margin-bottom:10px;font-style:italic}
        .quest-tracker .checklist{display:grid;gap:5px}
        .quest-tracker .check-item{display:flex;align-items:center;gap:8px;font-size:.92rem;color:#4a3818;transition:all .3s}
        .quest-tracker .check-item.done{color:#2a6a10;text-decoration:line-through}
        .quest-tracker .check-item .ck{width:16px;height:16px;border:1.5px solid #8b6914;border-radius:3px;display:flex;align-items:center;justify-content:center;font-size:.7rem;color:#2a6a10;flex-shrink:0}
        .quest-tracker .check-item.done .ck{background:rgba(42,106,16,.15);border-color:#2a6a10}
        .quest-fanfare{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:60;opacity:0;pointer-events:none;transition:opacity .4s}
        .quest-fanfare.show{opacity:1;pointer-events:auto}
        .quest-fanfare .qf-bg{position:absolute;inset:0;background:radial-gradient(ellipse at center,rgba(255,215,0,.15),rgba(0,0,0,.7))}
        .quest-fanfare .qf-title{font-family:Georgia,serif;font-size:2.2rem;font-weight:700;color:#ffd700;text-shadow:0 0 30px rgba(255,215,0,.5),0 4px 12px rgba(0,0,0,.4);z-index:1;animation:qfBounce .6s ease-out}
        .quest-fanfare .qf-sub{font-family:Georgia,serif;font-size:1rem;color:#e8d5a8;margin-top:8px;z-index:1;animation:qfFade .8s ease-out}
        .quest-fanfare .qf-reward{font-size:.9rem;color:var(--a);margin-top:16px;z-index:1;padding:8px 16px;border:1px solid rgba(110,200,110,.4);border-radius:8px;background:rgba(14,24,12,.8);animation:qfFade 1s ease-out}
        .quest-fanfare .qf-particles{position:absolute;inset:0;overflow:hidden;z-index:0}
        .quest-fanfare .qf-particle{position:absolute;width:8px;height:8px;border-radius:50%;animation:qfParticle 2s ease-out forwards}
        @keyframes qfBounce{0%{transform:scale(0) translateY(30px);opacity:0}50%{transform:scale(1.15) translateY(-10px)}100%{transform:scale(1) translateY(0);opacity:1}}
        @keyframes qfFade{0%{opacity:0;transform:translateY(20px)}100%{opacity:1;transform:translateY(0)}}
        @keyframes qfParticle{0%{opacity:1;transform:translateY(0) scale(1)}100%{opacity:0;transform:translateY(-200px) scale(0)}}
        .obj-complete-banner{position:fixed;top:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:28px 20px 22px;z-index:55;opacity:0;pointer-events:none;transition:opacity .5s;background:linear-gradient(180deg,rgba(0,0,0,.85) 0%,rgba(0,0,0,.6) 70%,transparent 100%)}
        .obj-complete-banner.show{opacity:1;pointer-events:auto}
        .obj-complete-banner .ocb-icon{font-size:2.4rem;animation:qfBounce .6s ease-out}
        .obj-complete-banner .ocb-title{font-family:Georgia,serif;font-size:1.8rem;font-weight:700;color:#ffd700;text-shadow:0 0 20px rgba(255,215,0,.4);margin-top:6px;animation:qfBounce .7s ease-out}
        .obj-complete-banner .ocb-sub{font-family:Georgia,serif;font-size:1.1rem;color:#e8d5a8;margin-top:4px;animation:qfFade 1s ease-out}
        .obj-complete-banner .ocb-hint{font-size:.85rem;color:#bbb;margin-top:10px;animation:qfFade 1.2s ease-out}
        .speech-bubble{position:absolute;pointer-events:none;max-width:280px;padding:12px 16px;border-radius:14px 14px 14px 4px;background:rgba(255,255,245,.94);color:#3a2a10;font-family:Georgia,serif;font-size:.95rem;line-height:1.5;box-shadow:0 4px 16px rgba(0,0,0,.3);border:1.5px solid rgba(139,105,20,.3);opacity:0;transition:opacity .4s;z-index:15;transform:translateX(-50%)}
        .speech-bubble.show{opacity:1}
        .speech-bubble::after{content:"";position:absolute;bottom:-8px;left:16px;width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:8px solid rgba(255,255,245,.92)}
        .crosshair{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:25;pointer-events:none;opacity:0;transition:opacity .2s}
        .crosshair.show{opacity:1}
        .crosshair::before,.crosshair::after{content:"";position:absolute;background:#fff;box-shadow:0 0 4px rgba(0,255,136,.6)}
        .crosshair::before{width:2px;height:20px;left:50%;top:50%;transform:translate(-50%,-50%)}
        .crosshair::after{width:20px;height:2px;left:50%;top:50%;transform:translate(-50%,-50%)}
        .crosshair .dot{width:4px;height:4px;background:#ff3344;border-radius:50%;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%)}
        .gun-hud{position:absolute;bottom:14px;left:14px;padding:10px 16px;border-radius:8px;background:rgba(10,10,10,.8);border:1px solid rgba(255,60,60,.4);color:#ff6644;font-size:.85rem;font-weight:600;letter-spacing:.05em;opacity:0;pointer-events:none;transition:opacity .3s;z-index:20;display:flex;align-items:center;gap:10px}
        .gun-hud.show{opacity:1}
        .gun-hud .gun-icon{font-size:1.2rem}
        .death-screen{position:fixed;inset:0;background:rgba(180,0,0,.8);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:70;opacity:0;pointer-events:none;transition:opacity .5s}
        .death-screen.show{opacity:1;pointer-events:auto}
        .death-screen .death-title{font-family:Georgia,serif;font-size:2.4rem;color:#fff;text-shadow:0 0 30px rgba(255,0,0,.6)}
        .death-screen .death-sub{font-size:1rem;color:#ffaa88;margin-top:12px}
        .hp-bar{position:fixed;top:55%;left:50%;transform:translate(-50%,20px);width:120px;height:6px;background:rgba(0,0,0,.6);border-radius:3px;z-index:25;opacity:0;pointer-events:none;transition:opacity .2s}
        .hp-bar.show{opacity:1}
        .hp-bar .hp-fill{height:100%;background:linear-gradient(90deg,#ff3344,#ffaa44);border-radius:3px;transition:width .15s}
        .muzzle-flash{position:fixed;top:50%;left:50%;width:40px;height:40px;margin:-20px 0 0 -20px;background:radial-gradient(circle,rgba(255,200,60,.9),rgba(255,100,20,.4),transparent);border-radius:50%;z-index:24;pointer-events:none;opacity:0;transition:none}
        .scope-overlay{position:fixed;inset:0;z-index:23;pointer-events:none;opacity:0;transition:opacity .15s}
        .scope-overlay.show{opacity:1}
        .scope-vignette{position:absolute;inset:0;background:radial-gradient(circle at 50% 50%,transparent 28%,rgba(0,0,0,.85) 42%,#000 52%)}
        .scope-reticle{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:300px;height:300px}
        .scope-reticle::before,.scope-reticle::after{content:"";position:absolute;background:rgba(255,50,50,.7)}
        .scope-reticle::before{width:1px;height:100%;left:50%;top:0}
        .scope-reticle::after{width:100%;height:1px;top:50%;left:0}
        .scope-reticle .scope-dot{width:6px;height:6px;border-radius:50%;background:#ff3344;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);box-shadow:0 0 6px rgba(255,50,50,.8)}
        .scope-reticle .scope-ring{width:80px;height:80px;border:1px solid rgba(255,50,50,.4);border-radius:50%;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%)}
        .scope-reticle .scope-tick{position:absolute;background:rgba(255,50,50,.5)}
        .scope-reticle .scope-tick.h{width:12px;height:1px;top:50%}
        .scope-reticle .scope-tick.v{width:1px;height:12px;left:50%}
        .scope-reticle .scope-tick.t1{left:calc(50% - 60px);margin-top:-0.5px}
        .scope-reticle .scope-tick.t2{left:calc(50% + 48px);margin-top:-0.5px}
        .scope-reticle .scope-tick.t3{top:calc(50% - 60px);margin-left:-0.5px}
        .scope-reticle .scope-tick.t4{top:calc(50% + 48px);margin-left:-0.5px}
        .scope-zoom-label{position:fixed;bottom:50px;left:50%;transform:translateX(-50%);color:rgba(255,80,80,.6);font-size:.7rem;font-weight:600;letter-spacing:.1em;z-index:24;pointer-events:none;opacity:0;transition:opacity .15s}
        .scope-zoom-label.show{opacity:1}
        @media(max-width:860px){.side-panel{top:auto;bottom:60px;right:14px;max-height:32vh}.hud{width:min(280px,calc(100vw - 28px))}}
        /* ========================================
           MOBILE / TOUCH CONTROLS
           ======================================== */
        #mobile-controls{display:none;position:fixed;inset:0;z-index:30;pointer-events:none}
        #mobile-controls>*{pointer-events:auto}
        /* Virtual Joystick */
        #joystick-zone{position:absolute;left:10px;bottom:10px;width:160px;height:160px;touch-action:none;z-index:35}
        #joystick-base{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:124px;height:124px;border-radius:50%;background:rgba(255,255,255,.06);border:2px solid rgba(110,200,110,.22);backdrop-filter:blur(2px)}
        #joystick-stick{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:52px;height:52px;border-radius:50%;background:rgba(110,200,110,.28);border:2.5px solid rgba(110,200,110,.5)}
        /* Action Buttons ‚Äî bottom-right */
        #mobile-btns{position:absolute;right:14px;bottom:14px;display:flex;flex-direction:column;align-items:flex-end;gap:10px;z-index:35}
        #mobile-btns-row{display:flex;gap:10px;align-items:center}
        .mobile-btn{width:60px;height:60px;border-radius:50%;border:2px solid rgba(110,200,110,.35);background:rgba(14,22,14,.65);color:#8fc88f;font-family:inherit;font-size:.65rem;font-weight:700;text-transform:uppercase;letter-spacing:.03em;display:flex;align-items:center;justify-content:center;text-align:center;line-height:1.15;touch-action:none;-webkit-user-select:none;user-select:none;cursor:pointer;padding:4px;transition:opacity .15s,transform .15s}
        .mobile-btn:active,.mobile-btn.pressed{background:rgba(110,200,110,.25);border-color:#6ec86e;color:#d4ffd4}
        .mobile-btn.ctx-hidden{opacity:0;pointer-events:none;transform:scale(.8)}
        .mobile-btn-lg{width:66px;height:66px;font-size:.72rem;border-color:rgba(110,200,110,.45);background:rgba(110,200,110,.06)}
        .mobile-btn-sprint{border-color:rgba(240,192,96,.35);color:#d0a040;background:rgba(40,30,10,.55)}
        .mobile-btn-sprint:active,.mobile-btn-sprint.pressed{background:rgba(240,192,96,.22);border-color:#f0c060;color:#ffe090}
        /* Camera touch zone ‚Äî right portion of screen */
        #cam-touch-zone{position:absolute;top:0;right:0;bottom:0;left:38%;touch-action:none;z-index:29}
        /* Top nav buttons for mobile */
        #mobile-top{position:absolute;top:10px;right:10px;display:flex;gap:6px;z-index:31}
        .mob-top-btn{height:34px;border-radius:8px;border:1px solid rgba(200,220,196,.25);background:rgba(14,22,14,.7);color:#c8dcc4;font-size:.68rem;font-weight:600;display:flex;align-items:center;justify-content:center;gap:4px;padding:0 10px;touch-action:none;-webkit-user-select:none;user-select:none;cursor:pointer;text-decoration:none;font-family:inherit}
        .mob-top-btn:active{border-color:#6ec86e;color:#fff}
        /* Layout adjustments when mobile controls active */
        body.mobile-active{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;touch-action:none;overscroll-behavior:none;position:fixed;width:100%;height:100%}
        body.mobile-active .hud{width:min(200px,calc(100vw - 80px));padding:6px 8px;gap:3px;border-radius:8px}
        body.mobile-active .hud .hint{display:none}
        body.mobile-active .hud-title{font-size:.64rem}
        body.mobile-active .hud-row{font-size:.7rem;gap:4px}
        body.mobile-active .side-panel{display:none}
        body.mobile-active .links{display:none}
        body.mobile-active .ach-popup{bottom:180px;right:14px;max-width:250px;font-size:.78rem;padding:10px 14px 10px 12px}
        body.mobile-active .ach-popup .ach-icon{font-size:1.6rem}
        body.mobile-active .ach-popup .ach-name{font-size:.82rem}
        body.mobile-active .quest-tracker{bottom:180px;right:14px;width:min(210px,calc(100vw - 28px));padding:10px 12px 8px}
        body.mobile-active .quest-tracker .qt{font-size:.85rem}
        body.mobile-active .quest-tracker .qobj{font-size:.76rem}
        body.mobile-active .quest-tracker .check-item{font-size:.78rem}
        body.mobile-active .prompt{bottom:180px;min-width:min(280px,calc(100vw - 200px));font-size:.76rem;padding:7px 10px}
        body.mobile-active .dialog-box{padding:16px 18px 14px;width:min(400px,calc(100vw - 20px))}
        body.mobile-active .dialog-title{font-size:1.1rem}
        body.mobile-active .dialog-text{font-size:.88rem}
        body.mobile-active .dialog-btns{flex-wrap:wrap}
        body.mobile-active .garage-modal{padding:16px 18px 14px;max-width:94vw;width:94vw}
        body.mobile-active .garage-title{font-size:1.2rem}
        body.mobile-active .garage-hint{display:none}
        body.mobile-active .garage-nav{width:36px;height:36px;font-size:1rem}
        body.mobile-active .mode-badge{top:auto;bottom:182px;font-size:.62rem;padding:3px 10px}
        body.mobile-active .speech-bubble{max-width:180px;font-size:.78rem;padding:7px 10px}
        body.mobile-active .toast{font-size:.72rem;top:52px;padding:6px 10px}
        body.mobile-active .crosshair,body.mobile-active .scope-overlay,body.mobile-active .scope-zoom-label{display:none}
        body.mobile-active .gun-hud{display:none}
        body.mobile-active .hp-bar{display:none}
        body.mobile-active .death-screen .death-title{font-size:1.6rem}
        body.mobile-active .death-screen .death-sub{font-size:.85rem}
        body.mobile-active .obj-complete-banner{padding:18px 14px 16px}
        body.mobile-active .obj-complete-banner .ocb-title{font-size:1.3rem}
        body.mobile-active .obj-complete-banner .ocb-sub{font-size:.9rem}
        body.mobile-active .quest-fanfare .qf-title{font-size:1.6rem}
    </style>
</head>
<body>
<div id="app">
    <div id="loading"><div style="text-align:center"><h1>Portfolio World</h1><p>Building world‚Ä¶ 45 projects across 4 districts</p></div></div>
    <div class="panel hud">
        <div class="hud-title">Mat Harvey ‚Äî Portfolio World</div>
        <div class="hud-row"><span>District</span><span class="v" id="district">Town Center</span></div>
        <div class="hud-row"><span>Speed</span><span class="v" id="speed">0 km/h</span></div>
        <div class="hud-row"><span>Discovered</span><span class="v" id="visited">0 / 45</span></div>
        <div class="hud-row"><span>Season</span><span class="v" id="season">Spring</span></div>
        <div class="hint">Driving: W/S forward/brake ¬∑ A/D steer ¬∑ Shift boost ¬∑ E interact ¬∑ F exit car ¬∑ G garage ¬∑ M mute</div>
        <div class="hint">Walking: W/S move ¬∑ A/D strafe ¬∑ Space jump ¬∑ Hold LMB look ¬∑ E talk ¬∑ F car ¬∑ G garage ¬∑ 1 equip SMG ¬∑ Scroll zoom</div>
        <div class="hint">Diving: WASD swim ¬∑ Space up ¬∑ Shift down ¬∑ Mouse look ¬∑ E exit near dock/ship</div>
    </div>
    <div class="panel side-panel"><div class="section-label">Achievements <span id="ach-count" style="float:right;color:var(--a);font-weight:600"></span></div><div id="badges"></div></div>
    <div class="ach-popup" id="ach-popup"><div class="ach-icon" id="ach-popup-icon"></div><div class="ach-body"><div class="ach-label">Achievement Unlocked</div><div class="ach-name" id="ach-popup-name"></div><div class="ach-desc" id="ach-popup-desc"></div><div class="ach-bar"><div class="ach-bar-fill" id="ach-popup-bar"></div></div></div></div>
    <div class="prompt" id="prompt"></div><div class="toast" id="toast"></div>
    <div id="dive-mask" style="position:fixed;inset:0;pointer-events:none;z-index:5;opacity:0;transition:opacity .4s">
        <svg width="100%" height="100%" viewBox="0 0 1920 1080" preserveAspectRatio="xMidYMid slice" style="position:absolute;inset:0">
            <defs>
                <radialGradient id="maskGrad" cx="50%" cy="50%" r="52%"><stop offset="70%" stop-color="transparent"/><stop offset="88%" stop-color="rgba(0,0,0,.5)"/><stop offset="100%" stop-color="rgba(0,0,0,.95)"/></radialGradient>
            </defs>
            <rect width="1920" height="1080" fill="url(#maskGrad)"/>
            <ellipse cx="960" cy="540" rx="820" ry="460" fill="none" stroke="rgba(40,40,50,.85)" stroke-width="6"/>
            <ellipse cx="960" cy="540" rx="830" ry="470" fill="none" stroke="rgba(60,60,70,.4)" stroke-width="2"/>
        </svg>
        <div style="position:absolute;inset:0;background:radial-gradient(ellipse at center,rgba(15,60,90,.2) 0%,rgba(5,25,45,.45) 100%)"></div>
        <div style="position:absolute;top:16px;left:50%;transform:translateX(-50%);color:rgba(120,220,255,.7);font:600 13px/1 'Segoe UI',sans-serif;letter-spacing:2px;text-transform:uppercase;text-shadow:0 0 8px rgba(0,100,180,.5)">Diving ‚Äî WASD swim ¬∑ Space up ¬∑ Shift down ¬∑ Mouse look ¬∑ E exit</div>
    </div>
    <div class="dialog-overlay" id="dialog"><div class="dialog-box"><div class="dialog-npc" id="dialog-npc">Wizard</div><div class="dialog-title" id="dialog-title"></div><div class="dialog-text" id="dialog-text"></div><div class="dialog-progress" id="dialog-progress"></div><div class="dialog-btns" id="dialog-btns"></div></div></div>
    <div class="garage-overlay" id="garage-overlay">
        <div class="garage-modal">
            <button class="garage-close" onclick="window._garageClose()" title="Close (Esc)">&#10005;</button>
            <div class="garage-header">
                <div class="garage-title">My Garage</div>
                <div class="garage-subtitle">Your car collection</div>
            </div>
            <div class="garage-carousel">
                <button class="garage-nav" onclick="window._garagePrev()">&#9664;</button>
                <div class="garage-stage">
                    <div class="garage-preview" id="garage-preview"></div>
                    <div class="garage-info">
                        <div class="garage-car-name" id="garage-car-name"></div>
                        <div class="garage-car-desc" id="garage-car-desc"></div>
                        <div class="garage-car-badge" id="garage-car-badge"></div>
                        <br>
                        <button class="garage-select-btn" id="garage-select-btn" onclick="window._garageSelect()">Spawn This Car</button>
                    </div>
                    <div class="garage-dots" id="garage-dots"></div>
                    <div class="garage-counter" id="garage-counter"></div>
                </div>
                <button class="garage-nav" onclick="window._garageNext()">&#9654;</button>
            </div>
            <div class="garage-hint">Press G anytime to open &middot; &#9664; &#9654; or click dots to browse &middot; Esc to close</div>
        </div>
    </div>
    <div class="mode-badge" id="mode-badge"></div>
    <div class="quest-tracker" id="quest-tracker"><div class="qt" id="qt-title"></div><div class="qobj" id="qt-obj"></div><div class="checklist" id="qt-checklist"></div></div>
    <div class="speech-bubble" id="speech-bubble"></div>
    <div class="quest-fanfare" id="quest-fanfare"><div class="qf-bg"></div><div class="qf-particles" id="qf-particles"></div><div class="qf-title">Quest Complete!</div><div class="qf-sub" id="qf-sub">Portfolio Scout</div><div class="qf-reward" id="qf-reward">New car unlocked: Sport Car</div></div>
    <div class="obj-complete-banner" id="obj-complete-banner"><div class="ocb-icon">&#9733;</div><div class="ocb-title" id="ocb-title">Objectives Complete!</div><div class="ocb-sub" id="ocb-sub">Return to The Wizard to claim your reward</div><div class="ocb-hint">Walk to the quest giver and press E</div></div>
    <div class="crosshair" id="crosshair"><div class="dot"></div></div>
    <div class="scope-overlay" id="scope-overlay"><div class="scope-vignette"></div><div class="scope-reticle"><div class="scope-dot"></div><div class="scope-ring"></div><div class="scope-tick h t1"></div><div class="scope-tick h t2"></div><div class="scope-tick v t3"></div><div class="scope-tick v t4"></div></div></div>
    <div class="scope-zoom-label" id="scope-zoom-label">4x SCOPE</div>
    <div class="gun-hud" id="gun-hud"><span class="gun-icon">üî´</span><span>SMG</span><span style="color:#aaa">| ‚àû</span></div>
    <div class="death-screen" id="death-screen"><div class="death-title" id="death-title">You Died</div><div class="death-sub" id="death-sub">The Wizard has struck you down!</div></div>
    <div id="matrix-screen" style="position:fixed;inset:0;z-index:200;opacity:0;pointer-events:none;transition:opacity 1.5s;background:#000"><canvas id="matrix-canvas" style="position:absolute;inset:0;width:100%;height:100%"></canvas><div id="matrix-text" style="position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;opacity:0;transition:opacity 3s;pointer-events:none;text-align:center;padding:20px"><div style="font-family:'Courier New',monospace;font-size:clamp(1.2rem,3vw,2.4rem);color:#00ff41;text-shadow:0 0 20px #00ff41,0 0 60px rgba(0,255,65,.4);line-height:1.8;max-width:700px">The wizard built the simulation,<br>and you killed him...</div><div style="font-family:'Courier New',monospace;font-size:clamp(.7rem,1.5vw,1rem);color:rgba(0,255,65,.5);margin-top:40px;letter-spacing:.2em">THERE IS NO GOING BACK</div><button id="matrix-return" style="margin-top:50px;padding:12px 32px;background:transparent;border:1px solid #00ff41;color:#00ff41;font-family:'Courier New',monospace;font-size:1rem;cursor:pointer;opacity:0;transition:opacity 2s;letter-spacing:.1em;pointer-events:auto;position:relative;z-index:10" onmouseover="this.style.background='rgba(0,255,65,.15)'" onmouseout="this.style.background='transparent'">WAKE UP</button></div></div>
    <div class="hp-bar" id="hp-bar"><div class="hp-fill" id="hp-fill" style="width:100%"></div></div>
    <div class="muzzle-flash" id="muzzle-flash"></div>
    <div class="links"><a class="btn" href="index.html">‚Üê Classic Portfolio</a><button class="btn" id="mute-btn" type="button">Audio: ON</button></div>
    <!-- ====== MOBILE TOUCH CONTROLS ====== -->
    <div id="mobile-controls">
        <div id="cam-touch-zone"></div>
        <div id="joystick-zone"><div id="joystick-base"><div id="joystick-stick"></div></div></div>
        <div id="mobile-btns">
            <button id="btn-car" class="mobile-btn ctx-hidden" data-label-drive="EXIT" data-label-walk="CAR">EXIT</button>
            <button id="btn-action" class="mobile-btn ctx-hidden">TALK</button>
            <div id="mobile-btns-row">
                <button id="btn-sprint" class="mobile-btn mobile-btn-sprint">‚ö°</button>
                <button id="btn-jump" class="mobile-btn mobile-btn-lg">JUMP</button>
            </div>
        </div>
        <div id="mobile-top">
            <a class="mob-top-btn" href="index.html">‚Üê Portfolio</a>
            <button class="mob-top-btn" id="btn-mob-garage" style="display:none">üèéÔ∏è</button>
            <button class="mob-top-btn" id="btn-mob-mute">üîä</button>
        </div>
    </div>
</div>
<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.161.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/" } }
</script>
<script type="module">
import * as THREE from "three";
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

/* ====== MOBILE DETECTION ====== */
const IS_MOBILE=(('ontouchstart' in window)||navigator.maxTouchPoints>0)&&window.innerWidth<1200;
if(IS_MOBILE)document.body.classList.add('mobile-active');

/* ====== PERFORMANCE PROFILE ====== */
const PERF=IS_MOBILE?{
    antialias:false,
    pixelRatioCap:Math.min(devicePixelRatio,1),
    postFx:false,
    terrainSegs:64,
    grassBlades:1500,
    pineCount:25,
    deciCount:18,
    leafCount:8,
    waterSegX:10,
    waterSegY:6,
    extraGltf:false,
    traffic:false,
    fpsCap:0,
}:{
    // Desktop ‚Äî full quality.
    antialias:true,
    pixelRatioCap:1.25,
    postFx:true,
    terrainSegs:165,
    grassBlades:18000,
    pineCount:180,
    deciCount:140,
    leafCount:120,
    waterSegX:34,
    waterSegY:16,
    extraGltf:true,
    traffic:true,
    fpsCap:0,
};

/* ====== SHADERS ====== */
const BOTW_VS=`
#ifdef USE_INSTANCING_COLOR
varying vec3 vIC;
#endif
varying vec3 vWN,vVD;varying float vFD;
void main(){
    #ifdef USE_INSTANCING_COLOR
    vIC=instanceColor;
    #endif
    vec4 wp;
    #ifdef USE_INSTANCING
    wp=modelMatrix*instanceMatrix*vec4(position,1.);vWN=normalize((modelMatrix*instanceMatrix*vec4(normal,0.)).xyz);
    #else
    wp=modelMatrix*vec4(position,1.);vWN=normalize((modelMatrix*vec4(normal,0.)).xyz);
    #endif
    vec4 mv=viewMatrix*wp;vVD=cameraPosition-wp.xyz;vFD=-mv.z;gl_Position=projectionMatrix*mv;}`;
const BOTW_FS=`
uniform vec3 uColor,uShadow,uSunDir,fogColor;uniform float fogNear,fogFar;
#ifdef USE_INSTANCING_COLOR
varying vec3 vIC;
#endif
varying vec3 vWN,vVD;varying float vFD;
void main(){vec3 base=uColor,sh=uShadow;
    #ifdef USE_INSTANCING_COLOR
    base*=vIC;sh*=vIC;
    #endif
    vec3 n=normalize(vWN);float NdL=dot(n,uSunDir)*.5+.5;NdL=floor(NdL*3.+.5)/3.;vec3 col=mix(sh,base,NdL);
    float rim=1.-max(dot(n,normalize(vVD)),0.);col+=vec3(1.,.95,.85)*smoothstep(.5,1.,rim)*.22;
    float ff=smoothstep(fogNear,fogFar,vFD);col=mix(col,fogColor,ff);gl_FragColor=vec4(col,1.);}`;
const WATER_VS=`uniform float uTime;varying vec2 vUv;varying float vFD;
void main(){vUv=uv;vec3 p=position;p.z-=sin(p.x*.15+uTime*1.5)*.2+cos(p.y*.12+uTime*1.2)*.15;
vec4 mv=modelViewMatrix*vec4(p,1.);vFD=-mv.z;gl_Position=projectionMatrix*mv;}`;
const WATER_FS=`uniform float uTime;uniform vec3 uShallow,uDeep,fogColor;uniform float fogNear,fogFar;
varying vec2 vUv;varying float vFD;
void main(){float w1=sin(vUv.x*28.+uTime*2.)*.5+.5;float w2=sin(vUv.y*20.+uTime*1.6+1.7)*.5+.5;
float w=w1*w2;vec3 col=mix(uDeep,uShallow,w*.35+.35);
col+=vec3(1.)*pow(w,6.)*.35+vec3(1.)*pow(max(sin(vUv.x*50.+uTime*3.)*sin(vUv.y*40.-uTime*2.5),0.),12.)*.2;
float ff=smoothstep(fogNear,fogFar,vFD);col=mix(col,fogColor,ff);gl_FragColor=vec4(col,.8);}`;

/* ====== MATCAP (car only) ====== */
function matcap(l,m,d){const s=256,cv=document.createElement("canvas");cv.width=s;cv.height=s;
const g=cv.getContext("2d"),gr=g.createRadialGradient(s*.38,s*.34,s*.05,s*.5,s*.52,s*.5);
gr.addColorStop(0,l);gr.addColorStop(.5,m);gr.addColorStop(1,d);g.fillStyle=gr;g.beginPath();g.arc(s/2,s/2,s/2,0,Math.PI*2);g.fill();
const t=new THREE.CanvasTexture(cv);t.colorSpace=THREE.SRGBColorSpace;return t;}
const MC={red:matcap("#ff9999","#cc2830","#601010"),dark:matcap("#606060","#1c1c20","#0a0a0a"),glass:matcap("#b0e8ff","#5898c8","#1c3860")};

/* ====== 45 PROJECTS ====== */
const DISTRICTS={
maritime:{label:"Port District",dtClass:"dt-port",color:"#3eaaa2",projects:[
    {t:"MarineStream Platform",u:"https://temp-msdt-for-review.onrender.com",g:"temp-msdt-for-review.gif"},
    {t:"Biofouling ID Guide",u:"https://mathew-harvey.github.io/BiofoulingIdGuide/",g:"BiofoulingIdGuide.gif"},
    {t:"Fouling Cost Calculator",u:"https://mathew-harvey.github.io/FoulingCostCalculator/",g:"FoulingCostCalculator.gif"},
    {t:"MarineStream Workspace",u:"https://MarineStream-Workspace.onrender.com",g:"MarineStream-Workspace.gif"},
    {t:"MarineStream Landing",u:"https://mathew-harvey.github.io/MarineStreamLandingPage/",g:"MarineStreamLandingPage.gif"},
    {t:"MarineStream App",u:"https://mathew-harvey.github.io/MarineStream/",g:"MarineStream.gif"},
    {t:"BFMP Doc Generator",u:"https://mathew-harvey.github.io/Document-Generator/",g:"Document-Generator.gif"},
    {t:"The Hull Truth",u:"https://mathew-harvey.github.io/TheHullTruth/",g:"TheHullTruth.gif"},
    {t:"Clean Hulls Clear Waters",u:"https://mathew-harvey.github.io/CleanHullsClearWaters/",g:"CleanHullsClearWaters.gif"},
]},
simulations:{label:"Science Park",dtClass:"dt-sim",color:"#6878cc",projects:[
    {t:"3D Ship Visualization",u:"https://mathew-harvey.github.io/3dShip/",g:"3dShip.gif",display:"hologram"},
    {t:"Agentic Bubble Sort",u:"https://mathew-harvey.github.io/AgenticBubbleSort/",g:"AgenticBubbleSort.gif",display:"hologram"},
    {t:"Ant Simulator",u:"https://mathew-harvey.github.io/AntSimulator/",g:"AntSimulator.gif",display:"portal"},
    {t:"Artificial Life",u:"https://mathew-harvey.github.io/Artificial-Life/",g:"Artificial-Life.gif",display:"portal"},
    {t:"Cancer Simulator",u:"https://mathew-harvey.github.io/CancerSimulator/",g:"CancerSimulator.gif",display:"hologram"},
    {t:"Game of Life",u:"https://mathew-harvey.github.io/GameOfLife/",g:"GameOfLife.gif",display:"portal"},
    {t:"One Human Life",u:"https://mathew-harvey.github.io/One-Human-Life-React/",g:"One-Human-Life-React.gif",display:"hologram"},
    {t:"Moltbook Throng",u:"https://mathew-harvey.github.io/Moltbook-Throng/",g:"Moltbook-Throng.gif",display:"portal"},
    {t:"Consciousness Framework",u:"https://mathew-harvey.github.io/A-New-Framework-for-Understanding-Consciousness/",g:"A-New-Framework-for-Understanding-Consciousness.gif",display:"hologram"},
    {t:"Stages of Mind",u:"https://mathew-harvey.github.io/StagesOfMind/",g:"StagesOfMind.gif",display:"hologram"},
]},
tools:{label:"Tech Hub",dtClass:"dt-tool",color:"#d0a030",projects:[
    {t:"Blurred Photos",u:"https://mathew-harvey.github.io/BlurredPhotos/",g:"BlurredPhotos.gif"},
    {t:"Image Compressor",u:"https://mathew-harvey.github.io/SimpleImageComression/",g:"SimpleImageComression.gif"},
    {t:"FormSync",u:"https://mathew-harvey.github.io/FormSync/",g:"FormSync.gif"},
    {t:"Net Connection Monitor",u:"https://mathew-harvey.github.io/NetConnectionMonitor/",g:"NetConnectionMonitor.gif"},
    {t:"VR Sim Racing Calc",u:"https://mathew-harvey.github.io/VrSimRacingCalc/",g:"VrSimRacingCalc.gif"},
    {t:"Web Disk Analyser",u:"https://mathew-harvey.github.io/WebDiskAnalyser/",g:"WebDiskAnalyser.gif"},
    {t:"Document Engine",u:"https://mathew-harvey.github.io/DocumentEngine/",g:"DocumentEngine.gif"},
]},
personal:{label:"Creative Village",dtClass:"dt-per",color:"#cc6088",projects:[
    {t:"FPV Track Planner",u:"https://mathew-harvey.github.io/FPVTrackPlanner/",g:"FPVTrackPlanner.gif",display:"arcade"},
    {t:"Cat Translator",u:"https://mathew-harvey.github.io/CatTranslator/",g:"CatTranslator.gif",display:"arcade"},
    {t:"Elodie Book One",u:"https://mathew-harvey.github.io/ElodieBook_One/",g:"ElodieBook_One.gif"},
    {t:"Elodie Book Two",u:"https://mathew-harvey.github.io/ElodieBook_Two/",g:"ElodieBook_Two.gif"},
    {t:"Extreme Limit Films",u:"https://mathew-harvey.github.io/ExtremeLimitFilms/",g:"ExtremeLimitFilms.gif"},
    {t:"Family Hiking",u:"https://mathew-harvey.github.io/FamilyHiking/",g:"FamilyHiking.gif"},
    {t:"Koi Runner",u:"https://mathew-harvey.github.io/KoiRunner/",g:"KoiRunner.gif",display:"arcade"},
    {t:"Japan Itinerary",u:"https://mathew-harvey.github.io/JapanItinery/",g:"JapanItinery.gif"},
    {t:"WC MultiRotor Club",u:"https://mathew-harvey.github.io/WestCoastMultiRotorClub/",g:"WestCoastMultiRotorClub.gif"},
    {t:"Virtual Property Tour",u:"https://mathew-harvey.github.io/VirtualPropertyTour/",g:"VirtualPropertyTour.gif",display:"portal"},
    {t:"Portfolio 2025",u:"https://mathew-harvey.github.io/Mat-Portfolio-2025/",g:"Mat-Portfolio-2025.gif",display:"hologram"},
    {t:"House Sitter Guide",u:"https://mathew-harvey.github.io/HouseSitter/",g:"HouseSitter.gif"},
    {t:"Skye Portfolio",u:"https://mathew-harvey.github.io/SkyePortfolio/",g:"SkyePortfolio.gif",display:"arcade"},
    {t:"My Stuff",u:"https://mathew-harvey.github.io/MyStuffHere/",g:"MyStuffHere.gif"},
    {t:"Only Prints",u:"https://mathew-harvey.github.io/OnlyPrints/",g:"OnlyPrints.gif"},
]},
};
/* ====== COMPUTE BILLBOARD POSITIONS ====== */
/* Map layout ‚Äî all buildings/billboards verified clear of road surfaces:
   Ocean z<-65 ‚Üí Port z=-50 to -30 (road z=-40, edges z=-46..-34)
   Tech Hub x=-75 to -35 (road x=-50) ‚Üê Town Center x=-20..+20 ‚Üí Science Park x=35 to 75 (road x=50)
   Creative Village z=34 to 68 (road z=50, edges z=44..56)
   Main roads: x=0 N-S (hw=8), z=0 E-W (hw=8), connectors x=¬±38 (hw=4), entries x=¬±50 (hw=5) */
const ALL_PROJECTS=[];
function addRow(arr,sx,sz,n,dx,dz,dist){arr.forEach((p,i)=>{if(i>=n)return;p.district=dist;p.wx=sx+i*dx;p.wz=sz+i*dz;ALL_PROJECTS.push(p);});}
// Port: road z=-40 (z=-46..-34), avoid N-S road (x=-8..8), W-conn (x=-42..-34 at z>-40)
const portRow1=[[-50,-30],[-30,-30],[-22,-30],[-14,-30],[14,-30],[22,-30],[50,-30]];
const portRow2=[[-48,-50],[-34,-50],[-18,-50],[18,-50],[34,-50],[48,-50]];
DISTRICTS.maritime.projects.forEach((p,i)=>{const pos=i<7?portRow1[i]:portRow2[i-7];if(!pos)return;p.district="maritime";p.wx=pos[0];p.wz=pos[1];ALL_PROJECTS.push(p);});
// Science: N-S road at x=50 (x=45..55), also avoid E-W road (z=-8..8)
// East col (x=60) safe z: skip z=-8..8 ‚Üí z=-18,-12,12,18,24
// Moved (72,16) to (66,12) to avoid building at (74,18)
const sciCol1=[[60,-18],[60,-14],[60,14],[66,14],[60,28]];
const sciCol2=[[58,-26],[58,26],[32,-18],[32,-14],[32,14]];
DISTRICTS.simulations.projects.forEach((p,i)=>{const pos=i<5?sciCol1[i]:sciCol2[i-5];if(!pos)return;p.district="simulations";p.wx=pos[0];p.wz=pos[1];ALL_PROJECTS.push(p);});
// Tech: N-S road at x=-50 (x=-55..-45), avoid E-W road (z=-8..8)
const techCol1=[[-58,-26],[-58,26],[-60,14],[-74,28]];
const techCol2=[[-32,-18],[-32,-14],[-32,14]];
DISTRICTS.tools.projects.forEach((p,i)=>{const pos=i<4?techCol1[i]:techCol2[i-4];if(!pos)return;p.district="tools";p.wx=pos[0];p.wz=pos[1];ALL_PROJECTS.push(p);});
// Creative: road z=50 (z=44..56), also avoid N-S road (x=-8..8), connectors (x=-42..-34, x=34..42 at z<50)
// Row 1 z=38: manually skip road bands
const creRow1=[[-50,38],[-28,38],[-20,38],[-14,38],[14,38],[20,38],[28,38],[50,38]];
const creRow2=[[-48,62],[-34,62],[-18,62],[14,62],[28,62],[42,62],[52,62]];
DISTRICTS.personal.projects.forEach((p,i)=>{const pos=i<8?creRow1[i]:creRow2[i-8];if(!pos)return;p.district="personal";p.wx=pos[0];p.wz=pos[1];ALL_PROJECTS.push(p);});

/* Billboard rotation: face toward the nearest road */
function bbRot(p){
    if(p.district==="maritime"||p.district==="personal"){
        const rz=p.district==="maritime"?-40:50;
        return p.wz<rz?0:Math.PI; // face +z or -z toward road
    }else{
        const rx=p.district==="simulations"?50:-50;
        return p.wx>rx?-Math.PI/2:Math.PI/2; // face toward road
    }
}

const ACHIEVEMENTS=[
    // ‚îÄ‚îÄ Driving & Exploration ‚îÄ‚îÄ
    {id:"ignite",title:"Ignition",desc:"Start the engine.",icon:"\u{1F525}"},
    {id:"first",title:"Explorer",desc:"Visit your first project.",icon:"\u{1F9ED}"},
    {id:"port",title:"Harbor Master",desc:"All maritime projects.",icon:"\u{2693}"},
    {id:"science",title:"Scientist",desc:"All simulation projects.",icon:"\u{1F52C}"},
    {id:"all",title:"Portfolio Complete",desc:"Visit every project.",icon:"\u{1F3C6}"},
    {id:"speed",title:"JDM Spirit",desc:"Hit 120 km/h.",icon:"\u{1F3CE}"},
    {id:"speed2",title:"Speed Demon",desc:"Hit 180 km/h.",icon:"\u{26A1}"},
    {id:"collector",title:"Treasure Hunter",desc:"Collect all orbs.",icon:"\u{1F48E}"},
    {id:"crash",title:"Demolition Derby",desc:"Send 10 objects flying.",icon:"\u{1F4A5}"},
    {id:"hotlap",title:"Track Star",desc:"Complete the City Circuit.",icon:"\u{1F3C1}"},
    {id:"two_wheels",title:"Garage Collector",desc:"Unlock a second car.",icon:"\u{1F697}"},
    {id:"all_cars",title:"Car Enthusiast",desc:"Unlock all vehicles.",icon:"\u{1F3CE}"},
    {id:"walker",title:"On Foot",desc:"Exit the car for the first time.",icon:"\u{1F6B6}"},
    {id:"districts",title:"Sightseer",desc:"Visit all 5 districts.",icon:"\u{1F30D}"},
    {id:"quest1",title:"Helpful Citizen",desc:"Complete your first quest.",icon:"\u{2705}"},
    {id:"quests_all",title:"Quest Master",desc:"Complete every quest.",icon:"\u{1F451}"},
    {id:"distance",title:"Road Warrior",desc:"Drive 10 km total.",icon:"\u{1F6E3}"},
    {id:"drift",title:"Drift King",desc:"Slide sideways for 3 seconds.",icon:"\u{1F4A8}"},
    // ‚îÄ‚îÄ Combat & Destruction ‚îÄ‚îÄ
    {id:"armed",title:"Locked & Loaded",desc:"Equip the SMG.",icon:"\u{1F52B}"},
    {id:"first_kill",title:"First Blood",desc:"Destroy your first object.",icon:"\u{1F4A2}"},
    {id:"build5",title:"Wrecking Ball",desc:"Destroy 5 buildings.",icon:"\u{1F3DA}"},
    {id:"build_all",title:"Urban Renewal",desc:"Destroy every building.",icon:"\u{1F3D7}"},
    {id:"car5",title:"Car Crusher",desc:"Destroy 5 cars.",icon:"\u{1F698}"},
    {id:"bb5",title:"Ad Blocker",desc:"Destroy 5 billboards.",icon:"\u{1F4FA}"},
    {id:"ship",title:"Ship Sinker",desc:"Sink the frigate.",icon:"\u{1F6A2}"},
    {id:"destroy10",title:"Mayhem",desc:"Destroy 10 things.",icon:"\u{1F525}"},
    {id:"destroy25",title:"Rampage",desc:"Destroy 25 things.",icon:"\u{1F4A5}"},
    {id:"destroy_all",title:"Total Annihilation",desc:"Destroy EVERYTHING.",icon:"\u{2622}"},
    {id:"rampage5",title:"Unstoppable",desc:"Destroy 5 objects within 30 seconds.",icon:"\u{26A1}"},
    {id:"wizard_warn",title:"Playing With Fire",desc:"Get warned by the Wizard.",icon:"\u{26A0}"},
    {id:"died",title:"Oops",desc:"Die to the Wizard's fireball.",icon:"\u{1F480}"},
    {id:"phoenix",title:"Phoenix",desc:"Die and respawn 3 times.",icon:"\u{1F426}"},
    {id:"pacifist",title:"Pacifist",desc:"Complete all quests without destroying anything.",icon:"\u{262E}"},
    {id:"dodge5",title:"Dodge Master",desc:"Dodge 5 of the Wizard's fireballs.",icon:"\u{1F4A8}"},
    {id:"wizard_kill",title:"Simulation Breaker",desc:"Defeat the Wizard. What have you done?",icon:"\u{1F300}"},
    // ‚îÄ‚îÄ Hidden / Fun ‚îÄ‚îÄ
    {id:"orbhalf",title:"Halfway There",desc:"Collect half the orbs.",icon:"\u{2728}"},
    {id:"night",title:"Night Owl",desc:"Drive for 5 real minutes.",icon:"\u{1F319}"},
    {id:"crash50",title:"Chaos Agent",desc:"Send 50 objects flying.",icon:"\u{1F32A}"},
    {id:"mountain",title:"Mountaineer",desc:"Reach the highest terrain point.",icon:"\u{26F0}"},
    {id:"swimmer",title:"Sea Legs",desc:"Jump into the ocean and swim.",icon:"\u{1F3CA}"},
    {id:"diver",title:"Deep Diver",desc:"Dive underwater near the ship.",icon:"\u{1F9BF}"},
    {id:"hull_inspect",title:"Hull Inspector",desc:"Swim under the ship's hull.",icon:"\u{1F6A2}"},
    {id:"aboard",title:"All Aboard!",desc:"Board the frigate.",icon:"\u{2693}"},
];

/* ====== STATE ====== */
// Load persisted garage data from localStorage
const _savedGarage=JSON.parse(localStorage.getItem("portfolioGarage")||"null");
// Load persisted achievements from localStorage
const _savedAch=JSON.parse(localStorage.getItem("portfolioAchievements")||"[]");
const state={speed:0,maxSpeed:0,canInteract:null,visited:new Set(),achievements:new Set(_savedAch),collectibles:new Set(),muted:false,seasonIndex:0,crashes:0,
    mode:"driving",questLog:[],
    unlockedCars:_savedGarage?.unlockedCars||["mazda"],
    activeCar:_savedGarage?.activeCar||"mazda",
    carParkedAt:null,nearNPC:false,avatarAngle:0,
    // Hot Lap quest
    gatesHit:0,totalGates:12,hotlapActive:false,
    // Gun & combat
    hasGun:false,gunEquipped:false,
    // Wizard protection
    wizardWarnings:0,isDead:false,wizardDead:false,fireballsDodged:0,
    // Swimming & jumping
    swimming:false,underwater:false,swimVelY:0,onShip:false,
    jumpVelY:0,isJumping:false,avatarY:0,swimTime:0,
    // Diving mode (FPS underwater)
    diving:false,divePos:null,diveCamYaw:0,diveCamPitch:0,
    // Destruction tracking (non-persistent ‚Äî resets on refresh)
    destroyCount:0,destroyBuildings:0,destroyCars:0,destroyBillboards:0,destroyShips:0,
    destroyTimestamps:[], // for rampage detection
    // Driving tracking
    totalDistance:0,driftTime:0,playTime:0,
    // Death tracking
    deathCount:0,
    // Districts visited
    visitedDistricts:new Set()};
function _saveGarage(){localStorage.setItem("portfolioGarage",JSON.stringify({unlockedCars:state.unlockedCars,activeCar:state.activeCar}));}
const QUESTS=[{
    id:"scout",title:"Portfolio Scout",giver:"guide",
    desc:"Drive around the city and check out 5 project billboards.\nPark in the yellow bay and press E to visit each one.",
    objectiveText:"Visit 5 billboards",
    objective:()=>state.visited.size>=5,
    rewardText:"A new ride! The Pixelated Sport Car is now available in your garage!",
    reward:()=>{if(!state.unlockedCars.includes("sport")){state.unlockedCars.push("sport");_saveGarage();}},
    status:state.unlockedCars.includes("sport")?"done":"available"
},{
    id:"hotlap",title:"City Circuit",giver:"guide",
    desc:"Think you can handle speed? Complete a hot lap of the city ‚Äî drive through every checkpoint gate in order!\nYour reward will be... powerful.",
    objectiveText:"Drive through all 12 gates",
    objective:()=>state.gatesHit>=state.totalGates,
    rewardText:"The Wizard grants you an SMG! Press 1 while on foot to equip it.",
    reward:()=>{state.hasGun=true;},
    status:"locked", // unlocked when scout is done
    prerequisite:"scout"
}];
const districtEl=document.getElementById("district"),speedEl=document.getElementById("speed"),visitedEl=document.getElementById("visited"),seasonEl=document.getElementById("season"),badgesEl=document.getElementById("badges"),promptEl=document.getElementById("prompt"),toastEl=document.getElementById("toast"),muteBtn=document.getElementById("mute-btn");
function showToast(t){toastEl.textContent=t;toastEl.classList.add("show");clearTimeout(showToast._t);showToast._t=setTimeout(()=>toastEl.classList.remove("show"),2200);}
const achCountEl=document.getElementById("ach-count"),
      achPopup=document.getElementById("ach-popup"),
      achPopupIcon=document.getElementById("ach-popup-icon"),
      achPopupName=document.getElementById("ach-popup-name"),
      achPopupDesc=document.getElementById("ach-popup-desc"),
      achPopupBar=document.getElementById("ach-popup-bar");
function _saveAchievements(){localStorage.setItem("portfolioAchievements",JSON.stringify([...state.achievements]));}
function renderBadges(){
    badgesEl.innerHTML="";
    const earned=state.achievements.size;
    achCountEl.textContent=`${earned} / ${ACHIEVEMENTS.length}`;
    ACHIEVEMENTS.forEach(a=>{
        const on=state.achievements.has(a.id);
        const e=document.createElement("div");e.className="badge"+(on?" on":"");
        e.innerHTML=`<span class="badge-icon">${a.icon}</span><div class="badge-info"><span class="badge-title">${a.title}</span><span class="badge-desc">${on?a.desc:"???"}</span></div>`;
        badgesEl.appendChild(e);
    });
}
let _achPopupTimer=null;
function _showAchPopup(a){
    achPopupIcon.textContent=a.icon;
    achPopupName.textContent=a.title;
    achPopupDesc.textContent=a.desc;
    achPopupBar.style.transition="none";achPopupBar.style.width="0";
    achPopup.classList.add("show");
    // Audio fanfare ‚Äî ascending chime
    audio.chime(523,.1);setTimeout(()=>audio.chime(659,.1),120);
    setTimeout(()=>audio.chime(784,.12),240);setTimeout(()=>audio.chime(1047,.15),400);
    // Animate progress bar across the popup lifetime
    requestAnimationFrame(()=>{achPopupBar.style.transition="width 3.5s linear";achPopupBar.style.width="100%";});
    // Auto-dismiss
    clearTimeout(_achPopupTimer);
    _achPopupTimer=setTimeout(()=>{achPopup.classList.remove("show");},4500);
}
function unlock(id){
    if(state.achievements.has(id))return;
    state.achievements.add(id);
    _saveAchievements();
    renderBadges();
    const a=ACHIEVEMENTS.find(x=>x.id===id);
    if(a)_showAchPopup(a);
}
renderBadges();
function getDistrict(x,z){if(z<-65)return"Open Ocean";if(z<-28)return"Port District";if(z>30)return"Creative Village";if(x>28)return"Science Park";if(x<-28)return"Tech Hub";return"Town Center";}

/* ====== SCENE ====== */
const scene=new THREE.Scene();scene.background=new THREE.Color("#78b8e6");scene.fog=new THREE.Fog("#a8d4ec",IS_MOBILE?30:70,IS_MOBILE?120:240);
const camera=new THREE.PerspectiveCamera(55,innerWidth/innerHeight,.1,IS_MOBILE?180:500);camera.position.set(0,10,18);
const renderer=new THREE.WebGLRenderer({antialias:PERF.antialias,powerPreference:"high-performance",precision:IS_MOBILE?"mediump":"highp"});
renderer.setSize(innerWidth,innerHeight);renderer.setPixelRatio(Math.min(devicePixelRatio,PERF.pixelRatioCap));
renderer.outputColorSpace=THREE.SRGBColorSpace;renderer.toneMapping=IS_MOBILE?THREE.NoToneMapping:THREE.ACESFilmicToneMapping;renderer.toneMappingExposure=1.15;
document.getElementById("app").appendChild(renderer.domElement);
let composer=null;
if(PERF.postFx){
    composer=new EffectComposer(renderer);composer.addPass(new RenderPass(scene,camera));
    composer.addPass(new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight),.24,.55,.85));composer.addPass(new OutputPass());
}
const hemi=new THREE.HemisphereLight("#b4d8f0","#5a8040",.9);scene.add(hemi);
const sun=new THREE.DirectionalLight("#fff0c8",1.1);sun.position.set(60,90,40);scene.add(sun);
const sunSphere=new THREE.Mesh(new THREE.SphereGeometry(5,16,16),new THREE.MeshBasicMaterial({color:"#ffe8a0"}));scene.add(sunSphere);

/* ====== MATERIALS ====== */
const sunDir=new THREE.Vector3(.5,.86,.3).normalize();
function botw(c,s,o){const cc=new THREE.Color(c),ss=s?new THREE.Color(s):cc.clone().multiplyScalar(.35);
return new THREE.ShaderMaterial({uniforms:{uColor:{value:cc},uShadow:{value:ss},uSunDir:{value:sunDir},fogColor:{value:scene.fog.color},fogNear:{value:scene.fog.near},fogFar:{value:scene.fog.far}},vertexShader:BOTW_VS,fragmentShader:BOTW_FS,side:(o&&o.side)||THREE.FrontSide});}
const waterMat=new THREE.ShaderMaterial({uniforms:{uTime:{value:0},uShallow:{value:new THREE.Color("#60d8c8")},uDeep:{value:new THREE.Color("#2888a0")},fogColor:{value:scene.fog.color},fogNear:{value:scene.fog.near},fogFar:{value:scene.fog.far}},vertexShader:WATER_VS,fragmentShader:WATER_FS,transparent:true,side:THREE.DoubleSide});

/* ====== TERRAIN ====== */
function hash2(a,b){const s=Math.sin(a*127.1+b*311.7)*43758.5453;return s-Math.floor(s);}
function ss(t){return t*t*(3-2*t);}function vn(x,z){const x0=Math.floor(x),z0=Math.floor(z),tx=ss(x-x0),tz=ss(z-z0);const a=hash2(x0,z0)+(hash2(x0+1,z0)-hash2(x0,z0))*tx;const b=hash2(x0,z0+1)+(hash2(x0+1,z0+1)-hash2(x0,z0+1))*tx;return a+(b-a)*tz;}
function fbm(x,z){let a=1,f=1,s=0,n=0;for(let i=0;i<5;i++){s+=vn(x*f,z*f)*a;n+=a;a*=.5;f*=2.1;}return s/n;}
const ROAD_SEGS=[
    {x1:0,z1:-43,x2:0,z2:75,hw:8},{x1:-75,z1:0,x2:75,z2:0,hw:8},        // Main boulevards 16 wide
    {x1:-55,z1:-40,x2:55,z2:-40,hw:6},{x1:-48,z1:50,x2:48,z2:50,hw:6},   // Port & Creative roads 12 wide
    {x1:-50,z1:-22,x2:-50,z2:22,hw:5},{x1:50,z1:-22,x2:50,z2:22,hw:5},   // Tech & Science entries 10 wide
    {x1:-38,z1:-40,x2:-38,z2:50,hw:4},{x1:38,z1:-40,x2:38,z2:50,hw:4},   // Side connectors 8 wide
];
function ptSeg(px,pz,x1,z1,x2,z2){const dx=x2-x1,dz=z2-z1,l2=dx*dx+dz*dz;if(l2<.01)return Math.hypot(px-x1,pz-z1);const t=Math.max(0,Math.min(1,((px-x1)*dx+(pz-z1)*dz)/l2));return Math.hypot(px-(x1+t*dx),pz-(z1+t*dz));}
function roadDist(x,z){let m=999;for(const r of ROAD_SEGS)m=Math.min(m,ptSeg(x,z,r.x1,r.z1,r.x2,r.z2)-r.hw);return m;}
const ROAD_Y=.25;
const WATER_LEVEL=-0.8;
function terrainHeight(x,z){
    let h=(fbm(x*.02,z*.02)-.5)*9;h+=Math.sin(x*.04)*.6+Math.cos(z*.04)*.6;
    h*=Math.min(1,Math.max(.2,Math.hypot(x,z)/60));
    const rd=roadDist(x,z);if(rd<=0)h=ROAD_Y;else if(rd<8)h=ROAD_Y+(h-ROAD_Y)*ss(rd/8);
    // Ocean floor: steep drop from shore (-44) to deep seabed
    // -44 to -55: coastal shelf, drops to -2
    // -55 to -65: dock zone, ~-2 to -4
    // -65+: deep ocean, drops to -12 under ship and beyond
    if(z<-44){
        const d=-z-44; // distance south of shore
        if(d<11){const p=d/11;h=h*(1-p)+(-2)*p;} // shelf: smooth to -2
        else if(d<21){const p=(d-11)/10;h=-2+(-2)*p;} // dock->deep: -2 to -4
        else{const p=Math.min(1,(d-21)/15);h=-4+(-8)*p;} // deep ocean: -4 to -12
    }return h;}
const WORLD=400,SEGS=PERF.terrainSegs;
const tGeo=new THREE.PlaneGeometry(WORLD,WORLD,SEGS,SEGS);tGeo.rotateX(-Math.PI/2);
const tPos=tGeo.attributes.position,tColors=new Float32Array(tPos.count*3);
for(let i=0;i<tPos.count;i++)tPos.setY(i,terrainHeight(tPos.getX(i),tPos.getZ(i)));
tGeo.computeVertexNormals();
const terrain=new THREE.Mesh(tGeo,new THREE.MeshStandardMaterial({vertexColors:true,roughness:.92,metalness:.02}));scene.add(terrain);

/* ====== ROADS ====== */
const roadMat=new THREE.MeshStandardMaterial({color:"#5a6050",roughness:.92}),lineMat=new THREE.MeshBasicMaterial({color:"#e8d89c"});
function addRoad(cx,cz,w,d){const m=new THREE.Mesh(new THREE.PlaneGeometry(w,d),roadMat);m.rotation.x=-Math.PI/2;m.position.set(cx,ROAD_Y+.02,cz);scene.add(m);
const hz=w>d,len=hz?w:d;for(let i=-len/2+3;i<len/2;i+=6){const mk=new THREE.Mesh(new THREE.PlaneGeometry(1.6,.22),lineMat);mk.rotation.x=-Math.PI/2;
if(hz)mk.position.set(cx-len/2+i+3,ROAD_Y+.04,cz);else{mk.rotation.z=Math.PI/2;mk.position.set(cx,ROAD_Y+.04,cz-len/2+i+3);}scene.add(mk);}}
addRoad(0,16,16,118);addRoad(0,0,150,16);addRoad(0,-40,110,12);addRoad(0,50,96,12);
addRoad(-50,0,10,44);addRoad(50,0,10,44);addRoad(-38,5,8,90);addRoad(38,5,8,90);
// Road-end roundabouts ‚Äî small circular pads where roads terminate
function addRoundabout(x,z,r){const m=new THREE.Mesh(new THREE.CircleGeometry(r||5,24),roadMat);m.rotation.x=-Math.PI/2;m.position.set(x,ROAD_Y+.02,z);scene.add(m);}
addRoundabout(-75,0,7);addRoundabout(75,0,7); // E-W endpoints
addRoundabout(0,75,8);addRoundabout(0,-68,8); // N-S endpoints
addRoundabout(-48,50,5);addRoundabout(48,50,5); // Creative road endpoints
addRoundabout(-55,-40,5);addRoundabout(55,-40,5); // Port road endpoints

/* ====== GRASS ‚Äî always visible, reacts to car + wind ====== */
const GRASS_N=PERF.grassBlades;
const bVerts=new Float32Array([-.05,0,0,.05,0,0,-.035,.35,0,.035,.35,0,-.02,.7,0,.02,.7,0,0,1,0]);
const bGeo2=new THREE.BufferGeometry();bGeo2.setAttribute("position",new THREE.BufferAttribute(bVerts,3));bGeo2.setIndex([0,1,2,2,1,3,2,3,4,4,3,5,4,5,6]);
const grassGeo=new THREE.InstancedBufferGeometry();grassGeo.index=bGeo2.index;grassGeo.setAttribute("position",bGeo2.getAttribute("position"));
const gO=new Float32Array(GRASS_N*3),gS=new Float32Array(GRASS_N),gA2=new Float32Array(GRASS_N);
let gi=0;while(gi<GRASS_N){const x=(Math.random()-.5)*320,z=(Math.random()-.5)*300;if(roadDist(x,z)<2||z<-48)continue;const y=terrainHeight(x,z);if(y<-.4)continue;gO[gi*3]=x;gO[gi*3+1]=y;gO[gi*3+2]=z;gS[gi]=.3+Math.random()*1.0;gA2[gi]=Math.random()*Math.PI*2;gi++;}
grassGeo.setAttribute("aO",new THREE.InstancedBufferAttribute(gO,3));grassGeo.setAttribute("aS",new THREE.InstancedBufferAttribute(gS,1));grassGeo.setAttribute("aA",new THREE.InstancedBufferAttribute(gA2,1));
const GRASS_DIST=IS_MOBILE?40:80; // render distance for grass (units from camera)
const grassMat=new THREE.ShaderMaterial({uniforms:{
    uTime:{value:0},uCarPos:{value:new THREE.Vector3()},uCarSpeed:{value:0},
    uCamPos:{value:new THREE.Vector3()},uRenderDist:{value:GRASS_DIST},
    uBase:{value:new THREE.Color("#3d8a2e")},uTip:{value:new THREE.Color("#a8d44e")},
    fogColor:{value:scene.fog.color},fogNear:{value:60},fogFar:{value:GRASS_DIST*0.95}},
vertexShader:`
attribute vec3 aO; attribute float aS, aA;
uniform float uTime, uCarSpeed, uRenderDist;
uniform vec3 uCarPos, uCamPos;
varying float vH, vFD;
void main(){
    // --- Render distance cull: scale to zero beyond range ---
    float dCam = distance(aO.xz, uCamPos.xz);
    float fade = 1.0 - smoothstep(uRenderDist * 0.75, uRenderDist, dCam);
    if(fade < 0.01){ gl_Position = vec4(0.0); return; } // GPU skips zero-area triangles

    vH = position.y;
    float c = cos(aA), s = sin(aA);
    float scaledH = position.y * aS * fade; // fade shrinks blade height
    vec3 p = vec3(position.x*c - position.z*s, scaledH, position.x*s + position.z*c);
    // --- Multi-layer wind ---
    float ph = uTime*1.8 + aO.x*.12 + aO.z*.1;
    float windMain = sin(ph) + 0.5*sin(ph*2.3 + 1.5) + 0.25*sin(ph*4.7 + 3.0);
    float windGust = 0.3*sin(uTime*0.4 + aO.x*0.03)*sin(uTime*0.7 + aO.z*0.05);
    float h2 = position.y * position.y;
    p.x += h2 * 0.2 * (windMain + windGust) * fade;
    p.z += (h2 * 0.12 * cos(ph*0.7 + 1.3) + h2 * 0.08 * windGust) * fade;
    // --- Car interaction: blades bend away from car ---
    vec3 wPos = p + aO;
    vec2 toCar = wPos.xz - uCarPos.xz;
    float carDist = length(toCar);
    float pushR = 2.5 + abs(uCarSpeed) * 0.3;
    if(carDist < pushR && carDist > 0.01){
        float pushStr = (1.0 - carDist/pushR) * position.y * (0.8 + abs(uCarSpeed)*0.15);
        pushStr = pushStr * pushStr;
        vec2 pushDir = toCar / carDist;
        p.x += pushDir.x * pushStr;
        p.z += pushDir.y * pushStr;
        p.y -= pushStr * 0.25;
    }
    vec4 mv = modelViewMatrix * vec4(p + aO, 1.0);
    vFD = -mv.z;
    gl_Position = projectionMatrix * mv;
}`,
fragmentShader:`
uniform vec3 uBase, uTip, fogColor;
uniform float fogNear, fogFar;
varying float vH, vFD;
void main(){
    vec3 col = mix(uBase, uTip, smoothstep(0.0, 1.0, vH)) * (0.8 + vH*0.2);
    float ff = smoothstep(fogNear, fogFar, vFD);
    col = mix(col, fogColor, ff);
    gl_FragColor = vec4(col, 1.0);
}`,side:THREE.DoubleSide});
const grassMesh=new THREE.Mesh(grassGeo,grassMat);
grassMesh.frustumCulled=false; // ALWAYS render grass ‚Äî no popping
scene.add(grassMesh);

/* ====== TREES ‚Äî pine + deciduous ====== */
const PINE_N=PERF.pineCount,DECI_N=PERF.deciCount;const dm=new THREE.Object3D();
const trunkIM=new THREE.InstancedMesh(new THREE.CylinderGeometry(.14,.24,2.6,8),botw("#7d5a38","#3a2818"),PINE_N);
const c1IM=new THREE.InstancedMesh(new THREE.ConeGeometry(1.6,2.6,7),botw("#3a8a3a","#1a4a1a"),PINE_N);
const c2IM=new THREE.InstancedMesh(new THREE.ConeGeometry(1.2,2.2,7),botw("#48984a","#1a541a"),PINE_N);
const c3IM=new THREE.InstancedMesh(new THREE.ConeGeometry(.85,1.8,7),botw("#58aa48","#285a18"),PINE_N);
scene.add(trunkIM,c1IM,c2IM,c3IM);
let tp=0;while(tp<PINE_N){const x=(Math.random()-.5)*320,z=(Math.random()-.5)*300;if(roadDist(x,z)<6||z<-50)continue;const y=terrainHeight(x,z);if(y<-.3)continue;const s=.7+Math.random();dm.position.set(x,y+1.2,z);dm.scale.set(1,s,1);dm.updateMatrix();trunkIM.setMatrixAt(tp,dm.matrix);dm.position.y=y+2.4*s;dm.scale.setScalar(s);dm.updateMatrix();c1IM.setMatrixAt(tp,dm.matrix);dm.position.y=y+3.4*s;dm.scale.setScalar(s*.88);dm.updateMatrix();c2IM.setMatrixAt(tp,dm.matrix);dm.position.y=y+4.2*s;dm.scale.setScalar(s*.72);dm.updateMatrix();c3IM.setMatrixAt(tp,dm.matrix);tp++;}
[trunkIM,c1IM,c2IM,c3IM].forEach(m=>m.instanceMatrix.needsUpdate=true);
// Round deciduous trees
const dTrunkIM=new THREE.InstancedMesh(new THREE.CylinderGeometry(.18,.28,3,8),botw("#7d5a38","#3a2818"),DECI_N);
const dCanopyIM=new THREE.InstancedMesh(new THREE.IcosahedronGeometry(2,2),botw("#4aa040","#1a5a1a"),DECI_N);
scene.add(dTrunkIM,dCanopyIM);
let dp=0;while(dp<DECI_N){const x=(Math.random()-.5)*280,z=(Math.random()-.5)*260;if(roadDist(x,z)<6||z<-46)continue;const y=terrainHeight(x,z);if(y<-.2)continue;const s=.6+Math.random()*.7;dm.position.set(x,y+1.4,z);dm.scale.set(1,s,1);dm.updateMatrix();dTrunkIM.setMatrixAt(dp,dm.matrix);dm.position.y=y+3.2*s;dm.scale.set(s*.9,s*.7,s*.9);dm.updateMatrix();dCanopyIM.setMatrixAt(dp,dm.matrix);dp++;}
dm.scale.set(1,1,1);[dTrunkIM,dCanopyIM].forEach(m=>m.instanceMatrix.needsUpdate=true);

/* ====== SCATTER ====== */
const _flowerN=IS_MOBILE?100:500,_rockN=IS_MOBILE?50:200,_bushN=IS_MOBILE?60:300;
const flowerIM=new THREE.InstancedMesh(new THREE.SphereGeometry(.14,IS_MOBILE?4:6,IS_MOBILE?4:6),botw("#e0e0e0","#606060"),_flowerN);
const rockIM=new THREE.InstancedMesh(new THREE.DodecahedronGeometry(.35,0),botw("#888890","#404048"),_rockN);
const bushIM=new THREE.InstancedMesh(new THREE.IcosahedronGeometry(.55,IS_MOBILE?0:1),botw("#4a9a3a","#1a4a1a"),_bushN);
scene.add(flowerIM,rockIM,bushIM);
let fi=0;while(fi<_flowerN){const x=(Math.random()-.5)*260,z=(Math.random()-.5)*260;if(roadDist(x,z)<2||z<-46)continue;const y=terrainHeight(x,z);if(y<-.2)continue;dm.position.set(x,y+.12,z);dm.scale.setScalar(.5+Math.random()*.8);dm.rotation.set(0,0,0);dm.updateMatrix();flowerIM.setMatrixAt(fi,dm.matrix);flowerIM.setColorAt(fi,new THREE.Color().setHSL(Math.random()*.15+.85,.7,.65));fi++;}
let ri=0;while(ri<_rockN){const x=(Math.random()-.5)*300,z=(Math.random()-.5)*300;if(roadDist(x,z)<4)continue;const y=terrainHeight(x,z);dm.position.set(x,y+.1,z);dm.scale.set(.5+Math.random(),.4+Math.random()*.6,.5+Math.random());dm.rotation.set(Math.random(),Math.random(),0);dm.updateMatrix();rockIM.setMatrixAt(ri,dm.matrix);ri++;}
let bi=0;while(bi<_bushN){const x=(Math.random()-.5)*280,z=(Math.random()-.5)*260;if(roadDist(x,z)<4||z<-46)continue;const y=terrainHeight(x,z);if(y<-.2)continue;dm.position.set(x,y+.3,z);dm.scale.setScalar(.4+Math.random()*.7);dm.rotation.set(0,0,0);dm.updateMatrix();bushIM.setMatrixAt(bi,dm.matrix);bi++;}
dm.rotation.set(0,0,0);[flowerIM,rockIM,bushIM].forEach(m=>{m.instanceMatrix.needsUpdate=true;if(m.instanceColor)m.instanceColor.needsUpdate=true;});

/* ====== WATER ====== */
const water=new THREE.Mesh(new THREE.PlaneGeometry(300,120,PERF.waterSegX,PERF.waterSegY),waterMat);water.rotation.x=-Math.PI/2;water.position.set(0,-.8,-85);scene.add(water);

/* ====== COLLISION ====== */
const staticCol=[];const dynCol=[];
function addStatic(mesh,pad){const b=new THREE.Box3().setFromObject(mesh);b.expandByScalar(pad||.2);staticCol.push(b);return staticCol.length-1;}
function addDynamic(mesh){dynCol.push({mesh,vel:new THREE.Vector3()});}

/* ====== DESTROYABLE REGISTRY ====== */
const destroyables=[];
function registerDestroyable(mesh,health,type){
    const idx=destroyables.length;
    mesh.traverse(ch=>{if(ch.isMesh)ch.userData._destroyIdx=idx;});
    mesh.userData._destroyIdx=idx;
    destroyables.push({mesh,health,maxHealth:health,type,alive:true});
    return idx;
}

/* ====== HOT LAP GATE SYSTEM ====== */
const GATE_POSITIONS=[
    {x:4,z:-15,rotY:0},          // 1: South on main road
    {x:4,z:-36,rotY:0},          // 2: Approaching port
    {x:25,z:-40,rotY:Math.PI/2}, // 3: East on port road
    {x:50,z:-36,rotY:0},         // 4: Port meets science
    {x:50,z:-10,rotY:0},         // 5: Science entry heading north
    {x:50,z:12,rotY:0},          // 6: Through science
    {x:38,z:35,rotY:0},          // 7: East connector north
    {x:20,z:50,rotY:Math.PI/2},  // 8: Creative road east
    {x:-20,z:50,rotY:Math.PI/2}, // 9: Creative road west
    {x:-38,z:30,rotY:0},         // 10: West connector south
    {x:-50,z:0,rotY:0},          // 11: Tech hub
    {x:-15,z:0,rotY:Math.PI/2},  // 12: E-W road finish
];
const hotlapGates=[];
function spawnGates(){
    // Remove existing gates
    hotlapGates.forEach(g=>scene.remove(g.group));
    hotlapGates.length=0;
    state.gatesHit=0;
    GATE_POSITIONS.forEach((gp,i)=>{
        const group=new THREE.Group();
        // Gate arch ‚Äî torus ring
        const torus=new THREE.Mesh(
            new THREE.TorusGeometry(4,0.3,8,24),
            new THREE.MeshBasicMaterial({color:i===0?"#00ff88":"#334444",transparent:true,opacity:i===0?0.9:0.35})
        );
        torus.rotation.y=gp.rotY;
        group.add(torus);
        // Left pillar
        const pillarGeo=new THREE.CylinderGeometry(0.25,0.25,8,8);
        const pillarMat=new THREE.MeshStandardMaterial({color:i===0?"#00ff88":"#445555",emissive:i===0?"#00ff88":"#112222",emissiveIntensity:i===0?0.5:0.1});
        const lp=new THREE.Mesh(pillarGeo,pillarMat);
        const rp=new THREE.Mesh(pillarGeo,pillarMat.clone());
        // Position pillars based on gate rotation
        const offX=Math.cos(gp.rotY)*4, offZ=Math.sin(gp.rotY)*4;
        lp.position.set(-offX,4,offZ);
        rp.position.set(offX,4,-offZ);
        group.add(lp,rp);
        // Number label
        const cv=document.createElement("canvas");cv.width=64;cv.height=64;
        const ctx=cv.getContext("2d");
        ctx.fillStyle=i===0?"#00ff88":"#445555";ctx.font="bold 48px sans-serif";
        ctx.textAlign="center";ctx.textBaseline="middle";ctx.fillText(""+(i+1),32,32);
        const numTex=new THREE.CanvasTexture(cv);
        const numSprite=new THREE.Sprite(new THREE.SpriteMaterial({map:numTex,transparent:true,depthTest:false}));
        numSprite.scale.set(2,2,1);numSprite.position.y=8.5;
        group.add(numSprite);
        const gy=Math.max(terrainHeight(gp.x,gp.z),ROAD_Y);
        group.position.set(gp.x,gy,gp.z);
        scene.add(group);
        hotlapGates.push({group,pos:new THREE.Vector3(gp.x,gy,gp.z),hit:false,idx:i,torus,lPillar:lp,rPillar:rp,numSprite});
    });
}
function updateGateVisuals(){
    hotlapGates.forEach((g,i)=>{
        if(g.hit){g.group.visible=false;return;}
        g.group.visible=true;
        const isNext=i===state.gatesHit;
        const color=isNext?0x00ff88:0x334444;
        g.torus.material.color.setHex(color);
        g.torus.material.opacity=isNext?0.9:0.35;
        g.lPillar.material.color.setHex(color);
        g.lPillar.material.emissive.setHex(isNext?0x00ff88:0x112222);
        g.lPillar.material.emissiveIntensity=isNext?0.5:0.1;
        g.rPillar.material.color.setHex(color);
        g.rPillar.material.emissive.setHex(isNext?0x00ff88:0x112222);
        g.rPillar.material.emissiveIntensity=isNext?0.5:0.1;
    });
}
function removeGates(){
    hotlapGates.forEach(g=>scene.remove(g.group));
    hotlapGates.length=0;state.hotlapActive=false;
}

/* ====== TOWN CENTER ‚Äî Times Square ====== */
function mkTSBuilding(x,z,w,h,d,rotY,screenText,screenColor){
    const g=new THREE.Group();
    const body=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),botw("#4a4a58","#2a2a30"));body.position.y=h/2;g.add(body);
    // Windows grid
    const winMat=new THREE.MeshBasicMaterial({color:"#a0c8e0"});
    for(let fy=3;fy<h-1;fy+=2.5)for(let fx=-(w/2-1);fx<w/2;fx+=1.8){g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.9,1.4),winMat);m.position.set(fx,fy,d/2+.01);return m;})());g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.9,1.4),winMat);m.position.set(fx,fy,-d/2-.01);m.rotation.y=Math.PI;return m;})());}
    // Decorative screen
    const cv=document.createElement("canvas");cv.width=512;cv.height=256;const ct=cv.getContext("2d");
    ct.fillStyle="#0a0a14";ct.fillRect(0,0,512,256);ct.fillStyle=screenColor;ct.font="bold 32px Segoe UI";ct.textAlign="center";ct.fillText(screenText,256,100);
    ct.fillStyle="rgba(255,255,255,.3)";ct.font="18px Segoe UI";ct.fillText("DRIVE TO DISCOVER",256,160);
    for(let y=0;y<256;y+=3)ct.fillRect(0,y,512,1);ct.strokeStyle=screenColor;ct.lineWidth=4;ct.strokeRect(2,2,508,252);
    const tex=new THREE.CanvasTexture(cv);tex.colorSpace=THREE.SRGBColorSpace;
    const scr=new THREE.Mesh(new THREE.PlaneGeometry(w*.8,h*.3),new THREE.MeshStandardMaterial({map:tex,emissive:"#fff",emissiveMap:tex,emissiveIntensity:.5}));
    scr.position.set(0,h*.65,d/2+.03);g.add(scr);
    // Neon frame
    const nm=new THREE.MeshBasicMaterial({color:screenColor});
    const sw=w*.8,sh=h*.3,sy=h*.65;
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(sw+.3,.15,.15),nm);m.position.set(0,sy+sh/2+.1,d/2+.08);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(sw+.3,.15,.15),nm);m.position.set(0,sy-sh/2-.1,d/2+.08);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.15,sh+.3,.15),nm);m.position.set(-sw/2-.1,sy,d/2+.08);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.15,sh+.3,.15),nm);m.position.set(sw/2+.1,sy,d/2+.08);return m;})());
    g.position.set(x,terrainHeight(x,z),z);g.rotation.y=rotY||0;scene.add(g);addStatic(g,.3);registerDestroyable(g,100,"building");return g;
}
mkTSBuilding(-16,-16, 8,16,7, Math.PI/6,"M A T  H A R V E Y","#00ff88");
mkTSBuilding(16,-16, 7,18,6, -Math.PI/6,"4 5  P R O J E C T S","#ff6688");
mkTSBuilding(-16,16, 7,14,7, -Math.PI/6,"P O R T F O L I O  2 0 2 6","#66aaff");
mkTSBuilding(16,16, 8,15,6, Math.PI/6,"D R I V E  ¬∑  E X P L O R E","#ffcc44");
// Fountain ‚Äî small collider only
const fountain=new THREE.Group();
fountain.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(3.5,4,1,24),botw("#8899aa","#445566"));m.position.y=.5;return m;})());
fountain.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.55,.7,3.6,12),botw("#b0b8c0","#505860"));m.position.y=2.3;return m;})());
fountain.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(1.1,.5,.6,12),botw("#a0a8b0","#505860"));m.position.y=4.4;return m;})());
fountain.add((()=>{const m=new THREE.Mesh(new THREE.SphereGeometry(.4,12,12),new THREE.MeshBasicMaterial({color:"#88ddff"}));m.position.y=4.8;return m;})());
fountain.position.set(0,ROAD_Y,0);scene.add(fountain);
// Only a small sphere collider for fountain
staticCol.push(new THREE.Box3(new THREE.Vector3(-2,-.5,-2),new THREE.Vector3(2,6,2)));
registerDestroyable(fountain,50,"prop");
// District signs ‚Äî dynamic (breakable)
function mkSign(x,z,text,color){const g=new THREE.Group();g.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.06,.08,2.5,8),botw("#5a4a30","#2a2010"));m.position.y=1.25;return m;})());const cv=document.createElement("canvas");cv.width=256;cv.height=64;const ct=cv.getContext("2d");ct.fillStyle=color;ct.fillRect(0,0,256,64);ct.fillStyle="#fff";ct.font="bold 26px Segoe UI";ct.textAlign="center";ct.fillText(text,128,42);const tex=new THREE.CanvasTexture(cv);tex.colorSpace=THREE.SRGBColorSpace;g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(1.8,.45),new THREE.MeshStandardMaterial({map:tex,emissive:color,emissiveIntensity:.15}));m.position.y=2.6;return m;})());g.position.set(x,Math.max(terrainHeight(x,z),ROAD_Y),z);scene.add(g);addDynamic(g);registerDestroyable(g,10,"prop");return g;}
// District signs ‚Äî placed on sidewalks, not in road bands
mkSign(10,-25,"PORT DISTRICT","#2a6a66");mkSign(-10,26,"CREATIVE VILLAGE","#8a4060");
mkSign(24,10,"SCIENCE PARK","#3a4080");mkSign(-24,10,"TECH HUB","#8a6a20");
// Lamp posts ‚Äî NO collision, just decorative
function mkLamp(x,z){const g=new THREE.Group();g.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.06,.1,4.2,8),botw("#383840","#1a1a20"));m.position.y=2.1;return m;})());g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.06,.06,.8),botw("#383840","#1a1a20"));m.position.set(0,3.9,.35);return m;})());g.add((()=>{const m=new THREE.Mesh(new THREE.SphereGeometry(.22,8,8),new THREE.MeshBasicMaterial({color:"#ffe8a0"}));m.position.set(0,3.6,.65);return m;})());g.position.set(x,Math.max(terrainHeight(x,z),ROAD_Y),z);scene.add(g);registerDestroyable(g,15,"prop");return g;}
// Lamp posts at corners/edges of town center ‚Äî 4+ units outside road bands
[[14,14],[-14,14],[14,-14],[-14,-14],[20,14],[-20,14],[20,-14],[-20,-14],
 // Along connector road edges (connectors are x=-42..-34 and x=34..42)
 [-32,22],[-32,35],[-46,28],[-46,35],[32,22],[32,35],[46,28],[46,35]
].forEach(([x,z])=>mkLamp(x,z));
// Benches ‚Äî dynamic (breakable)
function mkBench(x,z,r){const g=new THREE.Group();g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(1.6,.08,.5),botw("#a08060","#504020"));m.position.y=.5;return m;})());g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(1.6,.5,.06),botw("#907050","#483828"));m.position.set(0,.75,-.2);return m;})());g.position.set(x,Math.max(terrainHeight(x,z),ROAD_Y),z);g.rotation.y=r||0;scene.add(g);addDynamic(g);registerDestroyable(g,12,"prop");return g;}
// Benches in town center quadrants ‚Äî outside road bands (x=-8..8, z=-8..8)
[[-12,10,0],[12,10,Math.PI],[-12,-10,0],[12,-10,Math.PI],[18,18,Math.PI/4],[-18,18,-Math.PI/4]].forEach(([x,z,r])=>mkBench(x,z,r));

/* ====== PORT ====== */
const dock=new THREE.Mesh(new THREE.BoxGeometry(120,.6,20),botw("#7d5a38","#3a2818"));dock.position.set(0,-.1,-55);scene.add(dock);
// Dock planking detail ‚Äî darker strips
for(let dz=-63;dz<=-47;dz+=2){
    const plank=new THREE.Mesh(new THREE.BoxGeometry(118,.02,.15),botw("#5a3a20","#3a2010"));
    plank.position.set(0,.21,dz);scene.add(plank);
}
// Dock support pilings (visible from water)
for(let x=-55;x<=55;x+=8){const p=new THREE.Mesh(new THREE.CylinderGeometry(.22,.3,4,8),botw("#6a4a28","#301a08"));p.position.set(x,-1.8,-64);scene.add(p);registerDestroyable(p,8,"prop");}
for(let x=-55;x<=55;x+=12){const p=new THREE.Mesh(new THREE.CylinderGeometry(.2,.28,4,8),botw("#6a4a28","#301a08"));p.position.set(x,-1.8,-46);scene.add(p);registerDestroyable(p,8,"prop");}
// ‚îÄ‚îÄ Dock railings ‚îÄ‚îÄ
const railMat=botw("#5a5a60","#2a2a30");
const railPostMat=botw("#4a4a50","#222228");
// South railing (water edge z=-65) ‚Äî this is what you jump over to swim
for(let x=-58;x<=58;x+=4){
    // Post
    const post=new THREE.Mesh(new THREE.CylinderGeometry(.06,.08,1.2,6),railPostMat);
    post.position.set(x,.8,-64.5);scene.add(post);registerDestroyable(post,5,"prop");
}
// South top rail
const sRail=new THREE.Mesh(new THREE.BoxGeometry(118,.08,.08),railMat);sRail.position.set(0,1.35,-64.5);scene.add(sRail);registerDestroyable(sRail,10,"prop");
// South mid rail
const sMidRail=new THREE.Mesh(new THREE.BoxGeometry(118,.06,.06),railMat);sMidRail.position.set(0,.85,-64.5);scene.add(sMidRail);registerDestroyable(sMidRail,10,"prop");
// East railing (x=60)
for(let z=-63;z<=-47;z+=4){
    const post=new THREE.Mesh(new THREE.CylinderGeometry(.06,.08,1.2,6),railPostMat);
    post.position.set(59.5,.8,z);scene.add(post);registerDestroyable(post,5,"prop");
}
const eRail=new THREE.Mesh(new THREE.BoxGeometry(.08,.08,18),railMat);eRail.position.set(59.5,1.35,-55);scene.add(eRail);registerDestroyable(eRail,10,"prop");
const eMidRail=new THREE.Mesh(new THREE.BoxGeometry(.06,.06,18),railMat);eMidRail.position.set(59.5,.85,-55);scene.add(eMidRail);registerDestroyable(eMidRail,10,"prop");
// West railing (x=-60)
for(let z=-63;z<=-47;z+=4){
    const post=new THREE.Mesh(new THREE.CylinderGeometry(.06,.08,1.2,6),railPostMat);
    post.position.set(-59.5,.8,z);scene.add(post);registerDestroyable(post,5,"prop");
}
const wRail=new THREE.Mesh(new THREE.BoxGeometry(.08,.08,18),railMat);wRail.position.set(-59.5,1.35,-55);scene.add(wRail);registerDestroyable(wRail,10,"prop");
const wMidRail=new THREE.Mesh(new THREE.BoxGeometry(.06,.06,18),railMat);wMidRail.position.set(-59.5,.85,-55);scene.add(wMidRail);registerDestroyable(wMidRail,10,"prop");
// Bollards (mooring posts) along dock
const bollardMat=botw("#4a4a50","#222228");
for(let x=-48;x<=48;x+=16){
    const boll=new THREE.Group();
    boll.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.18,.25,.7,8),bollardMat);m.position.y=.55;return m;})());
    boll.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.28,.28,.1,8),bollardMat);m.position.y=.9;return m;})());
    boll.position.set(x,.0,-63.5);scene.add(boll);registerDestroyable(boll,5,"prop");
}
const lh=new THREE.Group();lh.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(1.2,1.7,14,12),botw("#e0dcd0","#808078"));m.position.y=7;return m;})());lh.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(1.4,1.4,2.5,12),botw("#cc2830","#601010"));m.position.y=9;return m;})());lh.add((()=>{const m=new THREE.Mesh(new THREE.SphereGeometry(.5,12,12),new THREE.MeshBasicMaterial({color:"#ffee60"}));m.position.y=16;return m;})());lh.position.set(-62,terrainHeight(-62,-55),-55);scene.add(lh);addStatic(lh,.5);registerDestroyable(lh,80,"building");
const contC=["#c44030","#3060a0","#d08030","#309050","#a040a0","#c0a030"];
for(let i=0;i<12;i++){const c=new THREE.Mesh(new THREE.BoxGeometry(3.2,2,2),botw(contC[i%6]));c.position.set(48+(i%4)*4,.8,-55-Math.floor(i/4)*2.6);c.rotation.y=.08*(i%3);scene.add(c);addStatic(c);registerDestroyable(c,25,"prop");}
// Dynamic crates and barrels ‚Äî these fly when hit
const crateMat=botw("#8a7048","#4a3820"),barrelMat=botw("#6a5838","#3a2818");
[[-40,-52],[-37,-53],[-34,-51],[52,-48],[55,-49],[57,-47],[-42,-48],[-30,-50],[45,-52],[50,-46]].forEach(([x,z])=>{const cr=new THREE.Mesh(new THREE.BoxGeometry(1,1,1),crateMat);cr.position.set(x,.3+Math.max(terrainHeight(x,z),ROAD_Y),z);cr.rotation.y=Math.random()*.5;scene.add(cr);addDynamic(cr);registerDestroyable(cr,8,"prop");});
[[-38,-54],[54,-50],[58,-48],[-32,-52],[48,-47]].forEach(([x,z])=>{const br=new THREE.Mesh(new THREE.CylinderGeometry(.45,.45,1.1,10),barrelMat);br.position.set(x,.35+Math.max(terrainHeight(x,z),ROAD_Y),z);scene.add(br);addDynamic(br);registerDestroyable(br,8,"prop");});
// Crane
const crane=new THREE.Group();crane.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.8,16,.8),botw("#d08030","#704010"));m.position.y=8;return m;})());crane.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(12,.6,.6),botw("#d08030","#704010"));m.position.set(4,15.5,0);return m;})());crane.position.set(62,terrainHeight(62,-55),-55);scene.add(crane);addStatic(crane,.3);registerDestroyable(crane,60,"building");

// Kotor-class frigate docked at port (GLB model)
new GLTFLoader().load('models/ship/kotor-class_frigate.glb',gltf=>{
    const m=gltf.scene;
    m.updateMatrixWorld(true);
    // Measure raw bounds for scaling
    const b=realBounds(m);
    const rawLen=Math.max(b.max.x-b.min.x,b.max.z-b.min.z);
    // Scale so ship is ~55 units long (imposing compared to person)
    const sc=55/rawLen;m.scale.setScalar(sc);
    m.updateMatrixWorld(true);
    const b2=realBounds(m);
    // Create group, ground the model so bottom sits at water level
    const shipGroup=new THREE.Group();shipGroup.add(m);
    m.position.y=-b2.min.y-1.0; // sink slightly into water
    m.position.x-=(b2.min.x+b2.max.x)/2; // center X
    m.position.z-=(b2.min.z+b2.max.z)/2; // center Z
    // Fix materials ‚Äî ensure everything renders solid
    m.traverse(ch=>{if(ch.isMesh&&ch.material){
        const mats=Array.isArray(ch.material)?ch.material:[ch.material];
        mats.forEach(mt=>{mt.depthWrite=true;mt.side=THREE.FrontSide;});}});
    // Position alongside the dock ‚Äî bow parallel to shore, hull in deep water
    shipGroup.position.set(5,-0.3,-75);
    shipGroup.rotation.y=Math.PI/2+0.05;
    scene.add(shipGroup);
    // No addStatic ‚Äî player can walk on deck
    window._shipGroup=shipGroup;
    // Deck level: the walkable deck sits low on the model (masts/antennas are above)
    // Model bottom is offset by (-b2.min.y - 1.0) from group origin
    // Group is at y=-0.3. Main deck is roughly 18% of total model height.
    const modelHeight=b2.max.y-b2.min.y;
    const modelBottomOffset=-b2.min.y-1.0;
    window._shipDeckY=shipGroup.position.y+modelBottomOffset+modelHeight*.18;
    console.log('Ship: deckY='+window._shipDeckY.toFixed(2)+' modelH='+modelHeight.toFixed(1)+' botOff='+modelBottomOffset.toFixed(1)+' groupY='+shipGroup.position.y);
    registerDestroyable(shipGroup,200,"ship");
    // ‚îÄ‚îÄ Gangplank from dock to ship ‚îÄ‚îÄ
    const deckY=window._shipDeckY;
    const dockY=0.2;
    const gpLen=12; // length of gangplank
    const gpAngle=Math.atan2(deckY-dockY,gpLen); // slope angle
    const gangplank=new THREE.Group();
    // Main plank
    gangplank.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(2,0.12,gpLen),botw("#8a7048","#5a4028"));m.position.z=-gpLen/2;return m;})());
    // Side rails
    gangplank.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.06,1,gpLen),botw("#5a5a60","#2a2a30"));m.position.set(-1,.5,-gpLen/2);return m;})());
    gangplank.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.06,1,gpLen),botw("#5a5a60","#2a2a30"));m.position.set(1,.5,-gpLen/2);return m;})());
    // Cross slats for grip
    for(let gi=1;gi<gpLen;gi+=1.2){
        gangplank.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(2,.04,.15),botw("#6a5030","#3a2818"));m.position.set(0,.07,-gi);return m;})());
    }
    gangplank.position.set(5,dockY,-65);
    gangplank.rotation.x=-gpAngle;
    scene.add(gangplank);
    window._gangplank={z1:-65,z2:-65-gpLen,x:5,w:1.5,y1:dockY,y2:deckY};
    console.log('Ship loaded: length='+(b2.max.x-b2.min.x).toFixed(1)+' scaled='+sc.toFixed(3));
},undefined,e=>{
    console.warn('Ship GLB failed, placing fallback:',e);
    // Fallback: simple hull shape
    const fb=new THREE.Group();
    fb.add(new THREE.Mesh(new THREE.BoxGeometry(32,4.5,10),botw("#2a3a4a","#101820")));
    fb.children[0].position.y=2.25;
    fb.add(new THREE.Mesh(new THREE.BoxGeometry(8,6,7),botw("#e0dcd0","#808078")));
    fb.children[1].position.set(-8,7,0);
    fb.position.set(10,-1.5,-70);fb.rotation.y=.08;scene.add(fb);addStatic(fb,.3);
});

/* ====== SCIENCE PARK ====== */
function mkModern(x,z,h,w,d,color){const g=new THREE.Group();g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),botw(color));m.position.y=h/2;return m;})());
const wm=new THREE.MeshBasicMaterial({color:"#88b8dd",transparent:true,opacity:.6});
for(let fy=2;fy<h-1;fy+=2.2)for(let fx=-(w/2-.8);fx<w/2;fx+=1.6){g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.9,1.3),wm);m.position.set(fx,fy,d/2+.01);return m;})());g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.9,1.3),wm);m.position.set(fx,fy,-d/2-.01);m.rotation.y=Math.PI;return m;})());}
g.position.set(x,terrainHeight(x,z),z);scene.add(g);addStatic(g,.3);registerDestroyable(g,80,"building");return g;}
mkModern(62,20,10,5,4,"#9098b0");mkModern(68,-18,8,4,4,"#8090a8");mkModern(74,18,12,5,4,"#a0a8c0");mkModern(66,-20,7,4,3,"#8898b0");

/* ====== TECH HUB ====== */
function mkWarehouse(x,z,w,d,color){const g=new THREE.Group();g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(w,5,d),botw(color));m.position.y=2.5;return m;})());
g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(w*.35,3,.1),new THREE.MeshBasicMaterial({color:"#88aacc",transparent:true,opacity:.5}));m.position.set(0,2.5,d/2+.05);return m;})());
g.position.set(x,terrainHeight(x,z),z);scene.add(g);addStatic(g,.3);registerDestroyable(g,60,"building");return g;}
mkWarehouse(-64,18,8,6,"#a09888");mkWarehouse(-75,-14,6,5,"#90a090");mkWarehouse(-72,16,7,5,"#a0a898");mkWarehouse(-62,-16,7,5,"#988880");

/* ====== CREATIVE VILLAGE ====== */
function mkHouse(x,z,wallColor,sc){const g=new THREE.Group(),s=sc||1;
g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(3.8*s,3*s,3.2*s),botw(wallColor));m.position.y=1.5*s;return m;})());
g.add((()=>{const m=new THREE.Mesh(new THREE.ConeGeometry(3.2*s,2*s,4),botw("#8a5030","#4a2818"));m.position.y=4*s;m.rotation.y=Math.PI/4;return m;})());
g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.7*s,1.3*s,.1),botw("#5a3a20","#2a1a08"));m.position.set(0,.65*s,1.61*s);return m;})());
g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.4*s,1.2*s,.4*s),botw("#707078","#383840"));m.position.set(.8*s,4.6*s,-.5*s);return m;})());
for(const wx of[-.8,.8])for(const wy of[1.5,2.3])g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.4*s,.45*s),new THREE.MeshBasicMaterial({color:"#d8e0ff"}));m.position.set(wx*s,wy*s,1.61*s);return m;})());
g.position.set(x,terrainHeight(x,z),z);scene.add(g);addStatic(g,.2);registerDestroyable(g,40,"building");return g;}
const hCols=["#e8d8c0","#f0e8e0","#d0e0d0","#e0d0c0","#e8e0d8","#d8e0d8","#e0e0d0","#d8d0c0"];
// Houses placed clear of all roads: N-S(x=-8..8), W-conn(x=-42..-34), E-conn(x=34..42), Creative(z=44..56)
[[-52,34],[-28,34],[-16,34],[14,34],[26,34],[50,34],[-48,66],[-30,66],[-16,66],[16,66],[30,66],[48,66]].forEach(([x,z],i)=>mkHouse(x,z,hCols[i%hCols.length],.85+Math.random()*.3));
// Windmill
const windmill=new THREE.Group();windmill.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.9,1.3,8,10),botw("#d8d0c0","#8a8070"));m.position.y=4;return m;})());windmill.add((()=>{const m=new THREE.Mesh(new THREE.ConeGeometry(1.3,2.2,10),botw("#8a5030","#4a2818"));m.position.y=9.1;return m;})());
const bladeGroup=new THREE.Group();for(let i=0;i<4;i++){const bl=new THREE.Mesh(new THREE.BoxGeometry(.3,3.5,.05),botw("#d0c8b0","#706850"));bl.position.set(0,1.75,0);const pv=new THREE.Group();pv.add(bl);pv.rotation.z=i*Math.PI/2;bladeGroup.add(pv);}
bladeGroup.position.set(0,8,1.2);windmill.add(bladeGroup);windmill.position.set(42,terrainHeight(42,72),72);scene.add(windmill);addStatic(windmill,.5);registerDestroyable(windmill,50,"building");
// Garden props clear of roads
[[-24,36],[16,36],[28,36],[-18,66],[18,66],[44,66]].forEach(([x,z])=>{const cr=new THREE.Mesh(new THREE.BoxGeometry(.8,.8,.8),botw("#7a6040","#3a2818"));cr.position.set(x,.2+Math.max(terrainHeight(x,z),ROAD_Y),z);scene.add(cr);addDynamic(cr);registerDestroyable(cr,8,"prop");});

/* ====== MOUNTAINS ====== */
const mtMats=[botw("#707078","#383840"),botw("#7a7a82","#404048"),botw("#686870","#303038")];
const _mtCount=IS_MOBILE?12:30;for(let i=0;i<_mtCount;i++){const a=(i/_mtCount)*Math.PI*2,r=150+Math.random()*35;const mt=new THREE.Mesh(new THREE.ConeGeometry(14+Math.random()*12,26+Math.random()*20,IS_MOBILE?4:6),mtMats[i%3]);mt.position.set(Math.cos(a)*r,6,Math.sin(a)*r);mt.rotation.y=Math.random()*Math.PI;scene.add(mt);}

/* ====== GIF BILLBOARDS + PARKING BAYS ====== */
const interactables=[],billboards=[];
// GIF host: images at 0,0 in viewport (behind canvas) so browsers keep animating them
const gifHost=IS_MOBILE?null:(()=>{const d=document.createElement("div");d.style.cssText="position:fixed;left:0;top:0;width:100vw;height:100vh;z-index:-100;pointer-events:none;opacity:0.01;overflow:hidden;";document.body.appendChild(d);return d;})();
const pCv=document.createElement("canvas");pCv.width=64;pCv.height=64;const pCtx=pCv.getContext("2d");pCtx.fillStyle="#e8d060";pCtx.font="bold 48px sans-serif";pCtx.textAlign="center";pCtx.fillText("P",32,48);const pTex=new THREE.CanvasTexture(pCv);
const bayMat=new THREE.MeshBasicMaterial({color:"#e8d060"});const frameMat=botw("#1a1a20","#0a0a10");
const HAS_IMG_DEC='ImageDecoder' in window;
const _GIF_W=IS_MOBILE?256:512,_GIF_H=IS_MOBILE?128:256;
const gifData=ALL_PROJECTS.map(pr=>{
const cv=document.createElement("canvas");cv.width=_GIF_W;cv.height=_GIF_H;const ctx=cv.getContext("2d");
// Draw initial static poster
ctx.fillStyle="#0a0a14";ctx.fillRect(0,0,_GIF_W,_GIF_H);
const di=DISTRICTS[pr.district]||{color:"#888",label:"Project"};
const _s=IS_MOBILE?.5:1;
ctx.fillStyle=di.color;ctx.font=`bold ${14*_s}px Segoe UI`;ctx.fillText(di.label.toUpperCase(),20*_s,30*_s);
ctx.fillStyle="#fff";ctx.font=`bold ${22*_s}px Segoe UI`;ctx.fillText(pr.t,20*_s,65*_s);
ctx.fillStyle="rgba(255,255,255,.4)";ctx.font=`${16*_s}px Segoe UI`;ctx.fillText("\u25B6 Park to preview",20*_s,100*_s);
ctx.strokeStyle=di.color;ctx.lineWidth=IS_MOBILE?1.5:3;ctx.strokeRect(1,1,_GIF_W-2,_GIF_H-2);
const tex=new THREE.CanvasTexture(cv);tex.colorSpace=THREE.SRGBColorSpace;
const url=`gifs/${pr.g}`;
const d={cv,ctx,tex,title:pr.t,district:pr.district,url,
    loaded:false,playing:false,_hasStatic:false,_failed:false,
    img:null,_dec:null,_fCount:0,_fIdx:0,_busy:false};
if(IS_MOBILE){
    // On mobile: skip all GIF fetching/decoding ‚Äî use static posters only to save CPU/bandwidth
    d.loaded=true;d._failed=false;
    return d;
}
// 1) Fallback: <img> in viewport for browsers that animate visible GIFs
const img=new Image();img.crossOrigin="anonymous";img.src=url;
img.style.cssText="width:4px;height:2px;display:inline-block;";
gifHost.appendChild(img);d.img=img;
img.onload=()=>{if(!d.loaded){d.loaded=true;}};
img.onerror=()=>{d._failed=true;d.loaded=true;};
// 2) Primary: ImageDecoder API (Chrome/Edge) ‚Äî decodes GIF frames reliably
if(HAS_IMG_DEC){
    fetch(url).then(r=>{if(!r.ok)throw new Error(r.status);
        const dec=new ImageDecoder({data:r.body,type:'image/gif'});
        d._dec=dec;return dec.completed;
    }).then(()=>{
        d._fCount=d._dec.tracks.selectedTrack.frameCount;
        d.loaded=true;
    }).catch(()=>{d._dec=null;});}
return d;});

// ‚îÄ‚îÄ Display type builders ‚îÄ‚îÄ
// BILLBOARD: classic roadside sign with parking bay
function buildBillboard(pr,idx,g,bm){
    const pm=botw("#707078","#383840");
    const pl=new THREE.Mesh(new THREE.CylinderGeometry(.1,.14,5,8),pm);const pr2=pl.clone();
    pl.position.set(-1.8,2.5,0);pr2.position.set(1.8,2.5,0);g.add(pl,pr2);
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(5,2.2,.14),frameMat);m.position.y=4;return m;})());
    const bd=new THREE.Mesh(new THREE.BoxGeometry(4.8,2,.2),bm);bd.position.set(0,4,.02);bd.userData.project=pr;g.add(bd);
    const tr=new THREE.Mesh(new THREE.PlaneGeometry(5.2,2.3),new THREE.MeshBasicMaterial({transparent:true,opacity:0,depthWrite:false}));
    tr.position.set(0,4,.25);tr.userData.project=pr;g.add(tr);
    const nc=DISTRICTS[pr.district].color;const nm=new THREE.MeshBasicMaterial({color:nc});
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(5.2,.12,.12),nm);m.position.set(0,5.05,.05);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(5.2,.12,.12),nm);m.position.set(0,2.95,.05);return m;})());
    const bay=new THREE.Group();
    bay.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.14,4),bayMat);m.rotation.x=-Math.PI/2;m.position.set(-1.6,.03,3);return m;})());
    bay.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.14,4),bayMat);m.rotation.x=-Math.PI/2;m.position.set(1.6,.03,3);return m;})());
    bay.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(3.2,.14),bayMat);m.rotation.x=-Math.PI/2;m.position.set(0,.03,1);return m;})());
    bay.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.8,.8),new THREE.MeshBasicMaterial({map:pTex,transparent:true}));m.rotation.x=-Math.PI/2;m.position.set(0,.04,3);return m;})());
    g.add(bay);
    interactables.push(bd,tr);
    return 3; // bay offset
}

// HOLOGRAM PEDESTAL: floating translucent screen above a glowing pedestal
function buildHologram(pr,idx,g,bm){
    const nc=DISTRICTS[pr.district].color;
    // Pedestal base ‚Äî octagonal
    const baseMat=botw("#2a2a38","#14141c");
    g.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.9,1.1,.6,8),baseMat);m.position.y=.3;return m;})());
    // Glowing ring on top of pedestal
    const ringMat=new THREE.MeshBasicMaterial({color:nc,transparent:true,opacity:.7});
    g.add((()=>{const m=new THREE.Mesh(new THREE.TorusGeometry(.85,.06,8,24),ringMat);m.rotation.x=-Math.PI/2;m.position.y=.62;return m;})());
    // Vertical light beam
    const beamMat=new THREE.MeshBasicMaterial({color:nc,transparent:true,opacity:.12,side:THREE.DoubleSide});
    g.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.3,.7,3,12,1,true),beamMat);m.position.y=2.1;return m;})());
    // Floating screen ‚Äî holographic look (translucent, emissive)
    const holoBm=bm.clone();holoBm.transparent=true;holoBm.opacity=.85;holoBm.emissiveIntensity=.6;
    const screen=new THREE.Mesh(new THREE.PlaneGeometry(3.2,1.8),holoBm);
    screen.position.y=3.2;screen.userData.project=pr;screen.userData._holoFloat=true;
    g.add(screen);
    // Back face
    const screenBack=screen.clone();screenBack.rotation.y=Math.PI;screenBack.position.z=-0.02;
    screenBack.userData.project=pr;g.add(screenBack);
    // Title label below screen
    const labelCv=document.createElement("canvas");labelCv.width=512;labelCv.height=64;
    const lctx=labelCv.getContext("2d");lctx.fillStyle=nc;lctx.font="bold 24px Segoe UI";
    lctx.textAlign="center";lctx.fillText(pr.t,256,40);
    const labelTex=new THREE.CanvasTexture(labelCv);labelTex.colorSpace=THREE.SRGBColorSpace;
    const label=new THREE.Mesh(new THREE.PlaneGeometry(2.8,.35),new THREE.MeshBasicMaterial({map:labelTex,transparent:true}));
    label.position.y=2.1;g.add(label);
    // Click target
    const tr=new THREE.Mesh(new THREE.PlaneGeometry(3.4,2),new THREE.MeshBasicMaterial({transparent:true,opacity:0,depthWrite:false}));
    tr.position.set(0,3.2,.15);tr.userData.project=pr;g.add(tr);
    interactables.push(screen,screenBack,tr);
    return 2.5;
}

// ARCADE CABINET: retro game-machine shape with GIF as screen
function buildArcade(pr,idx,g,bm){
    const nc=DISTRICTS[pr.district].color;
    const cabinetMat=botw("#1a1a28","#0a0a14");
    const sideMat=botw("#222230","#10101c");
    const trimMat=new THREE.MeshBasicMaterial({color:nc});
    // Main body
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(1.6,3.2,.8),cabinetMat);m.position.set(0,1.6,0);return m;})());
    // Header/marquee
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(1.7,.4,.85),sideMat);m.position.set(0,3.4,0);return m;})());
    // Marquee light strip
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(1.5,.1,.1),trimMat);m.position.set(0,3.55,.4);return m;})());
    // Marquee title
    const mqCv=document.createElement("canvas");mqCv.width=256;mqCv.height=64;
    const mqCtx=mqCv.getContext("2d");mqCtx.fillStyle="#0a0a14";mqCtx.fillRect(0,0,256,64);
    mqCtx.fillStyle=nc;mqCtx.font="bold 22px Segoe UI";mqCtx.textAlign="center";mqCtx.fillText(pr.t,128,42);
    const mqTex=new THREE.CanvasTexture(mqCv);mqTex.colorSpace=THREE.SRGBColorSpace;
    g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(1.4,.3),new THREE.MeshStandardMaterial({map:mqTex,emissive:"#fff",emissiveMap:mqTex,emissiveIntensity:.4}));m.position.set(0,3.3,.43);return m;})());
    // Screen (angled back slightly)
    const screenBm=bm.clone();screenBm.emissiveIntensity=.5;
    const screen=new THREE.Mesh(new THREE.PlaneGeometry(1.3,1),screenBm);
    screen.position.set(0,2.6,.42);screen.rotation.x=-.15;screen.userData.project=pr;g.add(screen);
    // Control panel (angled deck)
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(1.5,.1,.5),sideMat);m.position.set(0,1.7,.55);m.rotation.x=-.4;return m;})());
    // Joystick
    g.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.04,.04,.25,6),trimMat);m.position.set(-.2,1.85,.55);return m;})());
    // Buttons (2)
    g.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.06,.06,.04,8),new THREE.MeshBasicMaterial({color:"#ff3344"}));m.rotation.x=-Math.PI/2;m.position.set(.15,1.82,.55);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.06,.06,.04,8),new THREE.MeshBasicMaterial({color:"#44aaff"}));m.rotation.x=-Math.PI/2;m.position.set(.35,1.82,.55);return m;})());
    // Coin slot
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.15,.02,.06),new THREE.MeshBasicMaterial({color:"#888888"}));m.position.set(0,1,.43);return m;})());
    // Click target
    const tr=new THREE.Mesh(new THREE.PlaneGeometry(1.8,3.5),new THREE.MeshBasicMaterial({transparent:true,opacity:0,depthWrite:false}));
    tr.position.set(0,1.8,.5);tr.userData.project=pr;g.add(tr);
    interactables.push(screen,tr);
    return 2.5;
}

// PORTAL FRAME: glowing energy doorway showing the project GIF inside
function buildPortal(pr,idx,g,bm){
    const nc=DISTRICTS[pr.district].color;
    const frameMat2=new THREE.MeshStandardMaterial({color:"#1a1a28",roughness:.5,metalness:.6});
    const glowMat=new THREE.MeshBasicMaterial({color:nc,transparent:true,opacity:.8});
    // ‚îÄ‚îÄ Heavy base platform ‚Äî the "device" that generates the portal ‚îÄ‚îÄ
    g.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(1.8,2,0.4,12),botw("#1a1a28","#0a0a10"));m.position.y=.2;return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(1.5,1.6,0.15,12),frameMat2);m.position.y=.48;return m;})());
    // Glowing ring on device top
    g.add((()=>{const m=new THREE.Mesh(new THREE.TorusGeometry(1.4,.06,8,32),glowMat);m.rotation.x=-Math.PI/2;m.position.y=.56;return m;})());
    // ‚îÄ‚îÄ Twin emitter pylons on left and right ‚îÄ‚îÄ
    const pylonMat=botw("#2a2a38","#14141c");
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.35,4,.35),pylonMat);m.position.set(-1.7,2.5,0);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.35,4,.35),pylonMat);m.position.set(1.7,2.5,0);return m;})());
    // Pylon caps
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.45,.2,.45),frameMat2);m.position.set(-1.7,4.55,0);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.45,.2,.45),frameMat2);m.position.set(1.7,4.55,0);return m;})());
    // Pylon glow emitters (the "projectors")
    g.add((()=>{const m=new THREE.Mesh(new THREE.SphereGeometry(.15,8,8),glowMat);m.position.set(-1.7,4.7,0);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.SphereGeometry(.15,8,8),glowMat);m.position.set(1.7,4.7,0);return m;})());
    // Energy beams from pylons toward screen center
    const beamMat=new THREE.MeshBasicMaterial({color:nc,transparent:true,opacity:.1,side:THREE.DoubleSide});
    g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.1,2),beamMat);m.position.set(-1.2,3.8,0);m.rotation.z=.5;return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(.1,2),beamMat);m.position.set(1.2,3.8,0);m.rotation.z=-.5;return m;})());
    // ‚îÄ‚îÄ Top crossbar connecting pylons ‚îÄ‚îÄ
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(3.8,.2,.2),frameMat2);m.position.set(0,4.65,0);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(3.4,.06,.06),glowMat);m.position.set(0,4.78,0);return m;})());
    // ‚îÄ‚îÄ Large projected screen ‚Äî fills the space between pylons ‚îÄ‚îÄ
    const portalBm=bm.clone();portalBm.emissiveIntensity=.55;
    const scrW=2.6,scrH=1.7; // screen fits inside pylons (pylons at ¬±1.7)
    const screen=new THREE.Mesh(new THREE.PlaneGeometry(scrW,scrH),portalBm);
    screen.position.set(0,3,.01);screen.userData.project=pr;
    g.add(screen);
    // Back-face
    const screenBack=screen.clone();screenBack.rotation.y=Math.PI;screenBack.position.z=-0.02;
    screenBack.userData.project=pr;g.add(screenBack);
    // Translucent energy fill behind screen
    const swirlMat=new THREE.MeshBasicMaterial({color:nc,transparent:true,opacity:.08,side:THREE.DoubleSide});
    g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(scrW+.2,scrH+.4),swirlMat);m.position.set(0,3,-.04);return m;})());
    // Glowing border around screen
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(scrW+.15,.06,.06),glowMat);m.position.set(0,3+scrH/2+.05,0);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(scrW+.15,.06,.06),glowMat);m.position.set(0,3-scrH/2-.05,0);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.06,scrH+.15,.06),glowMat);m.position.set(-scrW/2-.05,3,0);return m;})());
    g.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.06,scrH+.15,.06),glowMat);m.position.set(scrW/2+.05,3,0);return m;})());
    // Ground rune circle
    const runeMat=new THREE.MeshBasicMaterial({color:nc,transparent:true,opacity:.25});
    g.add((()=>{const m=new THREE.Mesh(new THREE.RingGeometry(1.5,1.8,24),runeMat);m.rotation.x=-Math.PI/2;m.position.y=.05;return m;})());
    // Title plate on base front
    const labelCv=document.createElement("canvas");labelCv.width=512;labelCv.height=64;
    const lctx=labelCv.getContext("2d");lctx.fillStyle=nc;lctx.font="bold 24px Segoe UI";
    lctx.textAlign="center";lctx.fillText(pr.t,256,42);
    const labelTex=new THREE.CanvasTexture(labelCv);labelTex.colorSpace=THREE.SRGBColorSpace;
    g.add((()=>{const m=new THREE.Mesh(new THREE.PlaneGeometry(2.8,.35),new THREE.MeshBasicMaterial({map:labelTex,transparent:true}));m.position.set(0,.7,.9);return m;})());
    // Click target
    const tr=new THREE.Mesh(new THREE.PlaneGeometry(3.4,4),new THREE.MeshBasicMaterial({transparent:true,opacity:0,depthWrite:false}));
    tr.position.set(0,2.5,.2);tr.userData.project=pr;g.add(tr);
    interactables.push(screen,screenBack,tr);
    return 3;
}

// ‚îÄ‚îÄ Build all projects using the appropriate display type ‚îÄ‚îÄ
ALL_PROJECTS.forEach((pr,idx)=>{
    const g=new THREE.Group();const y=Math.max(terrainHeight(pr.wx,pr.wz),ROAD_Y)+.1;
    g.position.set(pr.wx,y,pr.wz);
    const bm=new THREE.MeshStandardMaterial({map:gifData[idx].tex,roughness:.3,metalness:.05,emissive:"#fff",emissiveMap:gifData[idx].tex,emissiveIntensity:.35});
    // Build the right display type
    let bayOff;
    const dtype=pr.display||"billboard";
    if(dtype==="hologram")bayOff=buildHologram(pr,idx,g,bm);
    else if(dtype==="arcade")bayOff=buildArcade(pr,idx,g,bm);
    else if(dtype==="portal")bayOff=buildPortal(pr,idx,g,bm);
    else bayOff=buildBillboard(pr,idx,g,bm);
    // Rotation
    g.rotation.y=bbRot(pr);
    scene.add(g);
    // Compute interaction position
    const bayLocal=new THREE.Vector3(0,0,bayOff);
    bayLocal.applyAxisAngle(new THREE.Vector3(0,1,0),g.rotation.y);
    const bayPos=g.position.clone().add(bayLocal);
    billboards.push({group:g,project:pr,boardMat:bm,bayPos,gifIdx:idx,displayType:dtype});
    registerDestroyable(g,20,"billboard");
});

/* ====== ARCADE INTERACTION FRAME ====== */
// Retro arcade-style indicator when parked near a billboard
const arcadeFrame=new THREE.Group();
// Glowing animated border
const arcGlowMat=new THREE.MeshBasicMaterial({color:"#00ff88",transparent:true,opacity:.8,side:THREE.DoubleSide});
const arcBars=[];
[{s:[5.6,.12,.06],p:[0,5.15,0]},{s:[5.6,.12,.06],p:[0,2.85,0]},{s:[.12,2.42,.06],p:[-2.8,4,0]},{s:[.12,2.42,.06],p:[2.8,4,0]}].forEach(({s,p})=>{
    const b=new THREE.Mesh(new THREE.BoxGeometry(...s),arcGlowMat.clone());b.position.set(...p);arcadeFrame.add(b);arcBars.push(b);});
// Corner chevrons
const chevGeo=new THREE.BufferGeometry();chevGeo.setAttribute("position",new THREE.BufferAttribute(new Float32Array([0,0,0,.4,0,0,0,.4,0]),3));chevGeo.setIndex([0,1,2]);
const chevMat=new THREE.MeshBasicMaterial({color:"#ffcc00",transparent:true,opacity:.9,side:THREE.DoubleSide});
[[-2.9,5.25,1,1],[-2.9,2.75,1,-1],[2.9,5.25,-1,1],[2.9,2.75,-1,-1]].forEach(([x,y,sx,sy])=>{
    const c=new THREE.Mesh(chevGeo,chevMat.clone());c.position.set(x,y,.08);c.scale.set(sx,sy,1);arcadeFrame.add(c);});
// "PRESS E" floating text
const pressCv=document.createElement("canvas");pressCv.width=256;pressCv.height=64;
const pressCtx=pressCv.getContext("2d");
const pressTex=new THREE.CanvasTexture(pressCv);pressTex.colorSpace=THREE.SRGBColorSpace;
const pressPlane=new THREE.Mesh(new THREE.PlaneGeometry(2.8,.7),new THREE.MeshBasicMaterial({map:pressTex,transparent:true,depthWrite:false,side:THREE.DoubleSide}));
pressPlane.position.set(0,6,.1);arcadeFrame.add(pressPlane);
// Coin-slot arrows pointing down at billboard
const coinArrowGeo=new THREE.ConeGeometry(.18,.5,4);
const coinMat=new THREE.MeshBasicMaterial({color:"#ffcc00",transparent:true,opacity:.85});
const coinArr=[];
for(let i=-1;i<=1;i++){const a=new THREE.Mesh(coinArrowGeo,coinMat.clone());a.position.set(i*1.8,5.8,.1);a.rotation.z=Math.PI;arcadeFrame.add(a);coinArr.push(a);}
arcadeFrame.visible=false;scene.add(arcadeFrame);
// Arcade frame update function (called in game loop)
let arcadeBB=null,arcadeT=0;
function updateArcade(t,dt,active,bb){
    if(!active){arcadeFrame.visible=false;arcadeBB=null;return;}
    if(bb!==arcadeBB){arcadeBB=bb;arcadeT=t;audio.chime(660,.06);setTimeout(()=>audio.chime(880,.05),80);}
    arcadeFrame.visible=true;
    arcadeFrame.position.copy(bb.group.position);arcadeFrame.rotation.y=bb.group.rotation.y;
    const elapsed=t-arcadeT,pulse=Math.sin(t*8)*.5+.5,slowP=Math.sin(t*3)*.5+.5;
    // Pulsing glow border
    arcBars.forEach(b=>{b.material.opacity=.4+pulse*.6;b.material.color.setHSL(.38-pulse*.06,1,.55+pulse*.15);});
    // Bouncing coin arrows
    coinArr.forEach((a,i)=>{a.position.y=5.6+Math.sin(t*6+i*1.2)*.25;a.material.opacity=.5+slowP*.5;});
    // Animated "PRESS E" text
    const pc=pressCtx;pc.clearRect(0,0,256,64);
    if(IS_MOBILE){
        // Simplified arcade text on mobile (no scanlines/glitch for perf)
        pc.fillStyle="rgba(0,50,25,.85)";pc.fillRect(0,0,256,64);
        pc.fillStyle="#ffcc00";pc.font="bold 28px 'Courier New',monospace";pc.textAlign="center";pc.textBaseline="middle";
        pc.fillText("INSERT COIN",128,28);
        pc.fillStyle="rgba(0,255,136,.8)";pc.font="bold 16px 'Courier New',monospace";
        pc.fillText("[ TAP OPEN ]",128,52);
    }else{
        // Scanline background
        pc.fillStyle=`rgba(0,${Math.floor(40+pulse*30)},${Math.floor(20+pulse*15)},.85)`;
        pc.fillRect(0,0,256,64);
        for(let y=0;y<64;y+=3){pc.fillStyle=`rgba(0,0,0,${.15+Math.sin(y*.5+t*12)*.05})`;pc.fillRect(0,y,256,1);}
        // Border
        pc.strokeStyle=`hsl(${140+pulse*20},100%,${55+pulse*15}%)`;pc.lineWidth=3;pc.strokeRect(2,2,252,60);
        // Text
        const blink=Math.sin(t*4)>.1;
        if(blink||elapsed<1){
            pc.fillStyle="#ffcc00";pc.font="bold 28px 'Courier New',monospace";pc.textAlign="center";pc.textBaseline="middle";
            const gx=Math.sin(t*47)*.8,gy=Math.cos(t*31)*.4;
            pc.fillText("INSERT COIN",128+gx,28+gy);
            pc.fillStyle=`rgba(0,255,136,${.6+slowP*.4})`;pc.font="bold 16px 'Courier New',monospace";
            pc.fillText("[ PRESS E ]",128,52);
        }
    }
    pressTex.needsUpdate=true;
}

/* ====== COLLECTIBLES ====== */
const orbs=[];const _orbCount=IS_MOBILE?6:15;const _orbMat=IS_MOBILE?new THREE.MeshBasicMaterial({color:"#60ffc0"}):new THREE.MeshStandardMaterial({color:"#60ffc0",emissive:"#1a6a50",emissiveIntensity:1.2});
for(let i=0;i<_orbCount;i++){let ox,oz;do{ox=(Math.random()-.5)*260;oz=(Math.random()-.5)*260;}while(roadDist(ox,oz)<3||oz<-48);const oy=terrainHeight(ox,oz);if(oy<-.3){i--;continue;}const o=new THREE.Mesh(new THREE.IcosahedronGeometry(.5,IS_MOBILE?0:1),_orbMat);o.position.set(ox,oy+1.8,oz);o.userData.id=`o${i}`;scene.add(o);orbs.push(o);}
// Direction arrow removed (user request) ‚Äî minimap compass replaces it

/* ====== CAR ====== */
// Procedural fallback while GLB loads
function createFallbackCar(){const body=new THREE.Group();const p=new THREE.MeshMatcapMaterial({matcap:MC.red}),tr=new THREE.MeshMatcapMaterial({matcap:MC.dark}),gl=new THREE.MeshMatcapMaterial({matcap:MC.glass});
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(3.6,.55,1.8),p);m.position.y=.68;return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(1.3,.18,1.76),p);m.position.set(1.05,.98,0);return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(1.48,.5,1.4),gl);m.position.set(-.28,1.2,0);return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(1.1,.36,1.66),p);m.position.set(-1.28,1,0);return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(3.7,.1,1.92),tr);m.position.y=.42;return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.12,.14,.48),new THREE.MeshBasicMaterial({color:"#fff8e0"}));m.position.set(1.84,.87,.54);return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.12,.14,.48),new THREE.MeshBasicMaterial({color:"#fff8e0"}));m.position.set(1.84,.87,-.54);return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.1,.16,.38),new THREE.MeshBasicMaterial({color:"#ff5050"}));m.position.set(-1.84,.85,.5);return m;})());
body.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.1,.16,.38),new THREE.MeshBasicMaterial({color:"#ff5050"}));m.position.set(-1.84,.85,-.5);return m;})());
const wG=new THREE.CylinderGeometry(.35,.35,.3,18),wM=new THREE.MeshMatcapMaterial({matcap:MC.dark}),wheels=[];
[[1.08,.35,.84],[1.08,.35,-.84],[-1.06,.35,.84],[-1.06,.35,-.84]].forEach(([x,y,z])=>{const wh=new THREE.Mesh(wG,wM);wh.rotation.z=Math.PI/2;wh.position.set(x,y,z);body.add(wh);wheels.push(wh);});
body.rotation.y=Math.PI/2;return{group:body,wheels};}
const car=new THREE.Group();car.position.set(0,ROAD_Y,18);scene.add(car); // start on N-S road, north of fountain
const fb=createFallbackCar();car.add(fb.group);car.userData.wheels=fb.wheels;
// Shared vertex-accurate bounds helper
const _bv=new THREE.Vector3();
function realBounds(root,visibleOnly){root.updateMatrixWorld(true);const mn=new THREE.Vector3(1e9,1e9,1e9),mx=new THREE.Vector3(-1e9,-1e9,-1e9);
root.traverse(c=>{if(!c.isMesh||!c.geometry)return;if(visibleOnly&&!c.visible)return;const p=c.geometry.attributes.position;
    for(let i=0;i<p.count;i++){_bv.fromBufferAttribute(p,i).applyMatrix4(c.matrixWorld);mn.min(_bv);mx.max(_bv);}});return{min:mn,max:mx};}

let carShadowW=3.8,carShadowD=1.8;
const carShadow=new THREE.Mesh(new THREE.PlaneGeometry(1,1),new THREE.MeshBasicMaterial({color:"#000",transparent:true,opacity:.22,depthWrite:false}));carShadow.rotation.x=-Math.PI/2;carShadow.scale.set(carShadowW,carShadowD,1);scene.add(carShadow);
// Car models registry (used for initial load + garage swap)
const CAR_MODELS={
    mazda:{path:"models/mazda_rx-7_fd.glb",name:"Mazda RX-7 FD",desc:"Classic JDM icon",rotY:Math.PI,targetSize:4.0},
    sport:{path:"models/cars2/low-poly_pixelated_sport_car.glb",name:"Sport Car",desc:"Pixelated speed demon",rotY:Math.PI,targetSize:5.5}
};
// Load initial car from saved activeCar (or default mazda)
{const _initCar=CAR_MODELS[state.activeCar]||CAR_MODELS.mazda;
const _initRotY=_initCar.rotY;
new GLTFLoader().load(_initCar.path,gltf=>{
    const m=gltf.scene;
    let b=realBounds(m);
    const rawW=b.max.x-b.min.x,rawD=b.max.z-b.min.z;
    const sc=(_initCar.targetSize||4.0)/Math.max(rawW,rawD);
    m.scale.setScalar(sc);
    m.updateMatrixWorld(true);
    m.traverse(ch=>{
        if(!ch.isMesh)return;
        const chn=ch.name.toLowerCase();
        // Hide colliders, ground planes, shadow planes, and environment meshes by name
        if(chn.includes('collider')||chn.includes('ground')||chn.includes('floor')||chn.includes('shadow_plane')||chn.includes('road')||chn.includes('asphalt')||chn.includes('parking')){ch.visible=false;return;}
        // Detect ground planes in WORLD space: flat in Y but large in XZ
        const wb=new THREE.Box3().setFromObject(ch);
        const wh=wb.max.y-wb.min.y, ww=wb.max.x-wb.min.x, wd=wb.max.z-wb.min.z;
        const area=ww*wd;
        if(wh<0.05&&area>4){ch.visible=false;return;} // world-flat + large area = ground
        const mats=Array.isArray(ch.material)?ch.material:[ch.material];
        mats.forEach(mt=>{
            mt.depthWrite=true;
            const nm=(mt.name||'').toLowerCase()+chn;
            if(nm.includes('glass')||nm.includes('window')||nm.includes('transparent')){
                mt.transparent=true;mt.opacity=0.3;mt.side=THREE.FrontSide;
            }else{
                mt.transparent=false;mt.opacity=1;mt.side=THREE.FrontSide;
            }});});
    const wrap=new THREE.Group();wrap.add(m);
    wrap.rotation.y=_initRotY;
    car.remove(fb.group);car.add(wrap);
    // Reset car to origin, measure, center the model, then restore
    const savedPos=car.position.clone();
    const savedRot=car.rotation.y;
    car.position.set(0,0,0);car.rotation.y=0;
    wrap.position.set(0,0,0);
    car.updateMatrixWorld(true);
    b=realBounds(car);
    const cxW=(b.min.x+b.max.x)/2, czW=(b.min.z+b.max.z)/2;
    wrap.position.y=-b.min.y;
    wrap.position.x=-cxW;
    wrap.position.z=-czW;
    // Shadow sized from visible-only bounds
    const vb=realBounds(car,true);
    carShadowW=Math.min((vb.max.x-vb.min.x)*1.05,6);carShadowD=Math.min((vb.max.z-vb.min.z)*1.05,3);
    // Restore car position/rotation
    car.position.copy(savedPos);car.rotation.y=savedRot;
    const wh=[];m.traverse(c=>{if(c.isMesh){const n=c.name.toLowerCase();if(n.includes('wheel')||n.includes('tire')||n.includes('rim'))wh.push(c);}});
    car.userData.wheels=wh;
    console.log(`Initial car (${state.activeCar}) loaded`);
},undefined,e=>{console.warn('Initial car GLB load failed, using fallback:',e);});
}

/* ====== AVATAR (GLB: low_poly_man) ====== */
const avatar=new THREE.Group();
avatar.visible=false;
avatar.userData={walkTime:0,mixer:null,idleAction:null,walkAction:null};
scene.add(avatar);
// Load avatar GLB/GLTF ‚Äî use Box3 for reliable sizing
new GLTFLoader().load('models/person1/scene.gltf',gltf=>{
    const m=gltf.scene;
    // Reset root transform
    m.position.set(0,0,0);m.rotation.set(0,0,0);m.scale.set(1,1,1);
    m.updateMatrixWorld(true);
    // Measure with Box3
    const box=new THREE.Box3().setFromObject(m);
    const size=new THREE.Vector3();box.getSize(size);
    console.log('Avatar raw size:',size.x.toFixed(2),size.y.toFixed(2),size.z.toFixed(2));
    // Scale so height = 1.7 units (human-sized)
    const TARGET_H=1.7;
    const sc=TARGET_H/Math.max(size.y,.01);
    m.scale.setScalar(sc);
    m.updateMatrixWorld(true);
    const box2=new THREE.Box3().setFromObject(m);
    const center2=new THREE.Vector3();box2.getCenter(center2);
    // Center horizontally and ground vertically
    m.position.x-=center2.x;
    m.position.z-=center2.z;
    m.position.y-=box2.min.y; // feet on ground
    // Wrap in sub-group rotated 180¬∞ so model faces -Z (Three.js forward)
    const avatarWrap=new THREE.Group();
    avatarWrap.rotation.y=Math.PI;
    avatarWrap.add(m);
    m.traverse(ch=>{if(ch.isMesh){const mats=Array.isArray(ch.material)?ch.material:[ch.material];mats.forEach(mt=>{mt.side=THREE.FrontSide;});}});
    avatar.add(avatarWrap);
    console.log('Avatar scaled: height='+TARGET_H+' sc='+sc.toFixed(4));
    // Animation mixer ‚Äî this model has "Take 001" which is the walking animation
    if(gltf.animations&&gltf.animations.length){
        avatar.userData.mixer=new THREE.AnimationMixer(m);
        const clips=gltf.animations;
        console.log('Avatar animations:',clips.map(a=>a.name));
        // Find walk animation ‚Äî could be named "Take 001", "walk", "run", or just the first clip
        const walkClip=clips.find(a=>/walk|run/i.test(a.name))||clips[0];
        const idleClip=clips.find(a=>/idle|stand/i.test(a.name));
        if(walkClip){
            avatar.userData.walkAction=avatar.userData.mixer.clipAction(walkClip);
            // Start with walk paused at frame 0 (acts as idle pose)
            avatar.userData.walkAction.play();
            avatar.userData.walkAction.paused=true;
        }
        if(idleClip){
            avatar.userData.idleAction=avatar.userData.mixer.clipAction(idleClip);
            avatar.userData.idleAction.play();
        }
    }
},undefined,e=>{
    console.warn('Avatar GLB failed, using fallback:',e);
    const skinMat=botw("#e8c8a0","#b09070"),shirtMat=botw("#4080b0","#284060"),pantsMat=botw("#384858","#1a2830");
    const torso=new THREE.Mesh(new THREE.BoxGeometry(.48,.55,.28),shirtMat);torso.position.y=1.05;avatar.add(torso);
    const head=new THREE.Mesh(new THREE.SphereGeometry(.18,8,6),skinMat);head.position.y=1.55;avatar.add(head);
    const legGeo=new THREE.BoxGeometry(.14,.46,.14);
    const lLeg=new THREE.Mesh(legGeo,pantsMat);lLeg.position.set(.11,.36,0);avatar.add(lLeg);
    const rLeg=new THREE.Mesh(legGeo,pantsMat);rLeg.position.set(-.11,.36,0);avatar.add(rLeg);
    const armGeo=new THREE.BoxGeometry(.12,.44,.12);
    const lArm=new THREE.Mesh(armGeo,shirtMat);lArm.position.set(.34,1.0,0);avatar.add(lArm);
    const rArm=new THREE.Mesh(armGeo,shirtMat);rArm.position.set(-.34,1.0,0);avatar.add(rArm);
    avatar.userData._fallback=true;avatar.userData.lLeg=lLeg;avatar.userData.rLeg=rLeg;avatar.userData.lArm=lArm;avatar.userData.rArm=rArm;
});

/* ====== NPC QUEST GIVER (GLB: wizard) ====== */
function makeIconSprite(text,color){
    const cv=document.createElement("canvas");cv.width=128;cv.height=128;
    const c=cv.getContext("2d");
    c.clearRect(0,0,128,128);
    // Drop shadow
    c.shadowColor="rgba(0,0,0,.6)";c.shadowBlur=8;c.shadowOffsetY=3;
    // Bold text only ‚Äî no circle background
    c.fillStyle=color;
    c.font="bold 100px sans-serif";
    c.textAlign="center";c.textBaseline="middle";
    c.fillText(text,64,58);
    // White outline for readability
    c.shadowColor="transparent";
    c.strokeStyle="#fff";c.lineWidth=4;
    c.strokeText(text,64,58);
    const tex=new THREE.CanvasTexture(cv);tex.premultiplyAlpha=true;
    const mat=new THREE.SpriteMaterial({map:tex,transparent:true,depthTest:false,sizeAttenuation:true});
    const sp=new THREE.Sprite(mat);sp.scale.set(1.6,1.6,1);
    return sp;
}
const npcGuide=new THREE.Group();
const _npcIconGroup=new THREE.Group();_npcIconGroup.position.y=3.2;
const _iconExclaim=makeIconSprite("!","#ffd700");
const _iconQReady=makeIconSprite("?","#ffd700");
const _iconQActive=makeIconSprite("?","#999999");
_npcIconGroup.add(_iconExclaim,_iconQReady,_iconQActive);
_iconQReady.visible=false;_iconQActive.visible=false;
npcGuide.add(_npcIconGroup);
const _npcNy=Math.max(terrainHeight(6,-5),ROAD_Y);
npcGuide.position.set(6,_npcNy,-5);
// Wizard wander waypoints ‚Äî roams across the entire map, staying off roads
// Town center, Port District (south), Science Park (east), Tech District (west), Creative (north)
const _wizWaypoints=[
    [6,-5],[15,10],[-12,8],               // town center area
    [25,20],[35,25],[50,15],[55,30],       // east (Science Park)
    [40,45],[20,50],[30,62],               // northeast (Creative)
    [-15,42],[-30,45],[-50,55],[-45,35],   // northwest (Creative)
    [-55,20],[-50,10],[-45,-15],[-55,-25], // west (Tech District)
    [-40,-35],[-25,-45],[-50,-48],         // southwest (Port)
    [-15,-55],[15,-50],[35,-45],[50,-35],   // south (Port)
    [45,-20],[30,-15],[15,-10],            // back toward center
];
npcGuide.userData={id:"guide",name:"The Wizard",iconGroup:_npcIconGroup,iconExclaim:_iconExclaim,iconQReady:_iconQReady,iconQActive:_iconQActive,baseY:_npcNy,mixer:null,
    // Wander state
    wpIdx:0,wpPause:2,wanderSpeed:2.5,isIdle:true,idleTimer:3+Math.random()*2,
    walkAction:null,idleAction:null};
scene.add(npcGuide);
// Don't add static collider ‚Äî wizard moves around now
// Load wizard GLB for NPC
new GLTFLoader().load('models/questGiver/low_poly_wizard_rigged.glb',gltf=>{
    const m=gltf.scene;
    m.position.set(0,0,0);m.rotation.set(0,0,0);m.scale.set(1,1,1);
    m.updateMatrixWorld(true);
    const box=new THREE.Box3().setFromObject(m);
    const size=new THREE.Vector3();box.getSize(size);
    const center=new THREE.Vector3();box.getCenter(center);
    console.log('NPC wizard raw size:',size.x.toFixed(2),size.y.toFixed(2),size.z.toFixed(2));
    const TARGET_H=2.0;
    const sc=TARGET_H/Math.max(size.y,.01);
    m.scale.setScalar(sc);
    m.updateMatrixWorld(true);
    const box2=new THREE.Box3().setFromObject(m);
    const center2=new THREE.Vector3();box2.getCenter(center2);
    m.position.x-=center2.x;
    m.position.z-=center2.z;
    m.position.y-=box2.min.y;
    m.traverse(ch=>{if(ch.isMesh){const mats=Array.isArray(ch.material)?ch.material:[ch.material];mats.forEach(mt=>{mt.side=THREE.FrontSide;});}});
    npcGuide.add(m);
    // Position icon clearly above the wizard's head
    const finalTop=(box2.max.y-box2.min.y)*sc; // scaled height
    _npcIconGroup.position.y=TARGET_H+0.8; // just above scaled wizard top
    console.log('NPC wizard loaded, finalTop='+finalTop.toFixed(2)+', icon at y='+_npcIconGroup.position.y.toFixed(2));
    // Animation mixer ‚Äî track idle & walk actions for wandering
    if(gltf.animations&&gltf.animations.length){
        npcGuide.userData.mixer=new THREE.AnimationMixer(m);
        const clips=gltf.animations;
        const idleClip=clips.find(a=>/idle/i.test(a.name))||clips[0];
        const walkClip=clips.find(a=>/walk|run|move/i.test(a.name));
        if(idleClip){
            npcGuide.userData.idleAction=npcGuide.userData.mixer.clipAction(idleClip);
            npcGuide.userData.idleAction.play();
        }
        if(walkClip){
            npcGuide.userData.walkAction=npcGuide.userData.mixer.clipAction(walkClip);
            npcGuide.userData.walkAction.setEffectiveWeight(0);
            npcGuide.userData.walkAction.play();
        }
    }
    console.log('NPC loaded: wizard, animations:',gltf.animations.map(a=>a.name));
},undefined,e=>{
    console.warn('NPC wizard GLB failed, using fallback:',e);
    const robeMat=botw("#c06830","#704018"),skinMat=botw("#e8c8a0","#b09070"),hatMat=botw("#a05828","#603010");
    const robe=new THREE.Mesh(new THREE.CylinderGeometry(.22,.32,.9,8),robeMat);robe.position.y=.65;npcGuide.add(robe);
    const npcHead=new THREE.Mesh(new THREE.SphereGeometry(.2,8,6),skinMat);npcHead.position.y=1.45;npcGuide.add(npcHead);
    const hat=new THREE.Mesh(new THREE.ConeGeometry(.25,.3,8),hatMat);hat.position.y=1.75;npcGuide.add(hat);
});

/* ====== DIALOG SYSTEM ====== */
const dialogEl=document.getElementById("dialog"),dialogNpc=document.getElementById("dialog-npc"),
      dialogTitle=document.getElementById("dialog-title"),dialogText=document.getElementById("dialog-text"),
      dialogProgress=document.getElementById("dialog-progress"),dialogBtns=document.getElementById("dialog-btns"),
      garageOverlay=document.getElementById("garage-overlay"),
      modeBadge=document.getElementById("mode-badge"),
      questTracker=document.getElementById("quest-tracker"),qtTitle=document.getElementById("qt-title"),
      qtObj=document.getElementById("qt-obj"),qtChecklist=document.getElementById("qt-checklist"),
      questFanfare=document.getElementById("quest-fanfare"),qfSub=document.getElementById("qf-sub"),
      qfReward=document.getElementById("qf-reward"),qfParticles=document.getElementById("qf-particles");

// Track which specific billboards have been visited for checklist
let _lastChecklistSize=0;

function showDialog(npc){
    if(state.gunEquipped)holsterGun();
    // Unlock prerequisite quests
    QUESTS.forEach(q=>{if(q.prerequisite&&q.status==="locked"){
        const pre=QUESTS.find(p=>p.id===q.prerequisite);
        if(pre&&pre.status==="done")q.status="available";
    }});
    const q=QUESTS.find(q=>q.giver===npc.userData.id&&(q.status==="available"||q.status==="active"||q.status==="complete"));
    state.mode="dialog";
    dialogNpc.textContent=npc.userData.name;
    if(!q){
        dialogTitle.textContent="Greetings, traveller!";
        dialogText.textContent="I have no more tasks for you. May your journey be filled with discovery!";
        dialogProgress.textContent="";
        dialogBtns.innerHTML=`<button class="dialog-btn" onclick="window._closeDialog()">Farewell</button>`;
    }else if(q.status==="available"){
        dialogTitle.textContent=q.title;
        dialogText.textContent=q.desc;
        dialogProgress.textContent="";
        dialogBtns.innerHTML=`<button class="dialog-btn primary" onclick="window._acceptQuest('${q.id}')">Accept Quest</button><button class="dialog-btn" onclick="window._closeDialog()">Not yet</button>`;
    }else if(q.status==="active"){
        dialogTitle.textContent=q.title;
        if(q.id==="hotlap"){
            dialogText.textContent="The checkpoint gates await! Get in your car and drive through them in order.";
            dialogProgress.textContent=`Progress: ${state.gatesHit} / ${state.totalGates} gates`;
        }else{
            dialogText.textContent="Your task remains unfinished. Continue exploring the city and visit the project billboards!";
            dialogProgress.textContent=`Progress: ${Math.min(state.visited.size,5)} / 5 billboards visited`;
        }
        dialogBtns.innerHTML=`<button class="dialog-btn" onclick="window._closeDialog()">I shall continue</button>`;
    }else if(q.status==="complete"){
        dialogTitle.textContent="Quest Complete!";
        if(q.id==="hotlap"){
            dialogText.textContent="Incredible driving! You've mastered every corner of this city. As promised, here's something... powerful. Use it wisely, mortal.";
        }else{
            dialogText.textContent="Excellent work, traveller! You've proven your dedication by exploring the city. Accept this reward ‚Äî a fine vehicle awaits you!";
        }
        dialogProgress.textContent="";
        dialogBtns.innerHTML=`<button class="dialog-btn primary" onclick="window._completeQuest('${q.id}')">Claim Reward</button>`;
    }
    dialogEl.classList.add("show");
    _mouseDragging=false;
    updateModeBadge();
}
window._closeDialog=function(){
    dialogEl.classList.remove("show");
    state.mode="walking";
    updateModeBadge();
};
window._acceptQuest=function(id){
    const q=QUESTS.find(q=>q.id===id);
    if(q){
        q.status="active";showToast("Quest accepted: "+q.title);
        if(id==="scout")_lastChecklistSize=state.visited.size;
        if(id==="hotlap"){spawnGates();state.hotlapActive=true;showToast("Drive through the gates in order! Get in your car.");}
    }
    dialogEl.classList.remove("show");
    state.mode="walking";
    updateModeBadge();updateQuestTracker();updateNPCIcon();
};
window._completeQuest=function(id){
    const q=QUESTS.find(q=>q.id===id);
    if(q){q.status="done";q.reward();}
    dialogEl.classList.remove("show");
    state.mode="walking";
    updateModeBadge();updateQuestTracker();updateNPCIcon();
    unlock("quest1");
    if(id==="hotlap")unlock("hotlap");
    if(QUESTS.every(q2=>q2.status==="done")){unlock("quests_all");
        // Pacifist: all quests done and nothing destroyed
        if(state.destroyCount===0)unlock("pacifist");
    }
    if(state.unlockedCars.length>=2)unlock("two_wheels");
    // Fanfare animation!
    showQuestFanfare(q);
    if(id==="hotlap"){
        removeGates();
        qfReward.textContent="SMG unlocked! Press 1 while on foot to equip it.";
        setTimeout(()=>showToast("SMG unlocked! Press 1 while on foot to equip."),5000);
    }else if(state.unlockedCars.length>1){
        setTimeout(()=>showToast("New car added to your garage! Press G to open it."),5000);
    }
};
function showQuestFanfare(q){
    qfSub.textContent=q?q.title:"Quest Complete";
    qfReward.textContent=q?q.rewardText:"Reward claimed!";
    // Spawn particles
    qfParticles.innerHTML="";
    const colors=["#ffd700","#ff6b35","#ff3366","#33ccff","#6eff6e","#cc66ff"];
    for(let i=0;i<40;i++){
        const p=document.createElement("div");p.className="qf-particle";
        p.style.left=Math.random()*100+"%";
        p.style.top=40+Math.random()*30+"%";
        p.style.background=colors[Math.floor(Math.random()*colors.length)];
        p.style.width=p.style.height=(4+Math.random()*8)+"px";
        p.style.animationDelay=Math.random()*.8+"s";
        p.style.animationDuration=(1.5+Math.random()*1)+"s";
        qfParticles.appendChild(p);
    }
    questFanfare.classList.add("show");
    // Fanfare audio
    audio.chime(523,.15);setTimeout(()=>audio.chime(659,.15),200);
    setTimeout(()=>audio.chime(784,.15),400);setTimeout(()=>audio.chime(1047,.25),600);
    // Auto-dismiss
    setTimeout(()=>{questFanfare.classList.remove("show");},4500);
}
const objBanner=document.getElementById("obj-complete-banner"),
      ocbTitle=document.getElementById("ocb-title"),
      ocbSub=document.getElementById("ocb-sub");
function showObjectiveCompleteFanfare(q){
    ocbTitle.textContent="Objectives Complete!";
    ocbSub.textContent="Return to "+npcGuide.userData.name+" to claim your reward";
    objBanner.classList.add("show");
    // Triumphant chime sequence
    audio.chime(440,.12);setTimeout(()=>audio.chime(554,.12),150);
    setTimeout(()=>audio.chime(659,.15),300);setTimeout(()=>audio.chime(880,.2),500);
    // Auto-dismiss after 6 seconds
    setTimeout(()=>{objBanner.classList.remove("show");},6000);
}
// Also show objective-complete reminder when user tabs back to the page
document.addEventListener("visibilitychange",()=>{
    if(!document.hidden){
        const cq=QUESTS.find(q=>q.status==="complete");
        if(cq){
            // Re-show the banner if quest objectives are done but reward not claimed
            showObjectiveCompleteFanfare(cq);
        }
    }
});
function updateModeBadge(){
    if(state.mode==="walking"&&state.gunEquipped){modeBadge.textContent="COMBAT ‚Äî LMB fire ¬∑ RMB scope ¬∑ 1 holster ¬∑ WASD move";modeBadge.className="mode-badge show walk";}
    else if(state.mode==="walking"){modeBadge.textContent="On Foot ‚Äî F enter car ¬∑ G garage ¬∑ Hold LMB to look ¬∑ E talk"+(state.hasGun?" ¬∑ 1 equip SMG":"");modeBadge.className="mode-badge show walk";}
    else if(state.mode==="dialog"){modeBadge.textContent="Talking";modeBadge.className="mode-badge show dialog";}
    else{modeBadge.className="mode-badge";}
}
function updateQuestTracker(){
    const q=QUESTS.find(q=>q.status==="active");
    if(!q){questTracker.classList.remove("show");return;}
    qtTitle.textContent=q.title;
    qtObj.textContent=q.objectiveText;
    qtChecklist.innerHTML="";
    if(q.id==="hotlap"){
        // Gate checklist for hot lap
        for(let i=0;i<state.totalGates;i++){
            const done=i<state.gatesHit;
            const item=document.createElement("div");
            item.className="check-item"+(done?" done":"");
            item.innerHTML=`<span class="ck">${done?"‚úì":""}</span><span>Gate ${i+1}</span>`;
            qtChecklist.appendChild(item);
        }
    }else{
        // Billboard checklist for scout
        const visited=Array.from(state.visited);
        const needed=5;
        for(let i=0;i<needed;i++){
            const done=i<visited.length;
            const item=document.createElement("div");
            item.className="check-item"+(done?" done":"");
            const name=done?visited[i]:"Billboard "+(i+1);
            item.innerHTML=`<span class="ck">${done?"‚úì":""}</span><span>${name}</span>`;
            qtChecklist.appendChild(item);
        }
        // Check if new billboard visited ‚Äî show feedback toast
        if(state.visited.size>_lastChecklistSize&&_lastChecklistSize>0){
            const ct=Math.min(state.visited.size,5);
            showToast(`‚úì Billboard visited! (${ct}/5)`);
            audio.chime(700,.06);
            _lastChecklistSize=state.visited.size;
        }
    }
    questTracker.classList.add("show");
}
function updateNPCIcon(){
    // Unlock prerequisite quests
    QUESTS.forEach(q=>{if(q.prerequisite&&q.status==="locked"){
        const pre=QUESTS.find(p=>p.id===q.prerequisite);
        if(pre&&pre.status==="done")q.status="available";
    }});
    const q=QUESTS.find(q=>q.giver==="guide"&&(q.status==="available"||q.status==="active"||q.status==="complete"));
    const d=npcGuide.userData;
    d.iconExclaim.visible=false;d.iconQReady.visible=false;d.iconQActive.visible=false;
    if(!q)return;
    if(q.status==="available")d.iconExclaim.visible=true;
    else if(q.status==="active")d.iconQActive.visible=true;
    else if(q.status==="complete")d.iconQReady.visible=true;
}
updateNPCIcon();

/* ====== NPC SPEECH BUBBLES ====== */
const speechBubble=document.getElementById("speech-bubble");
const NPC_JOKES=[
    "I used to be an adventurer like you... then I took a bug to the codebase.",
    "Why do programmers prefer dark mode? Because light attracts bugs!",
    "A wizard is never late. He deploys precisely when he means to.",
    "I put a spell on your portfolio... it's called CSS.",
    "How many wizards does it take to change a lightbulb? None ‚Äî we use dark mode.",
    "My other staff is a mechanical keyboard.",
    "I cast Fireball... at the production server. It was very effective.",
    "They say magic isn't real. They haven't seen a well-crafted regex.",
    "I once turned a developer into a frog. He said it was a better job.",
    "The secret to good code? A pinch of logic, a dash of coffee, and a wizard's hat.",
    "Fun fact: I've been standing here for 3000 frames. My feet hurt.",
    "Did you know? Every billboard you visit makes me slightly happier.",
    "The fountain? That was me. Accidentally cast Water Bolt indoors.",
    "Don't tell the NPCs, but I control the weather here. Sorry about winter.",
    "If you crash enough cars, I might promote you to chaos wizard.",
    "My robe is +5 to charisma. Can't you tell?",
    "I have a quest for you! ...Oh wait, you haven't talked to me yet.",
    "Between you and me, the Sport Car handles like a dream.",
    "I've been a quest giver for 47 years. The dental plan is terrible.",
    "Legend has it, if you visit all the billboards, something magical happens...",
    "Why did the variable go to therapy? It had too many issues.",
    "My wizard school was mostly git merge conflicts.",
    "They wanted me to be a final boss, but I negotiated down to quest giver.",
    "Is it just me, or does this city have a lot of parking bays?",
];
let _jokeIdx=Math.floor(Math.random()*NPC_JOKES.length);
let _jokeTimer=0,_jokeShow=0;
const JOKE_INTERVAL=8; // seconds between jokes
const JOKE_DISPLAY=5;  // how long each joke stays visible

function updateSpeechBubble(t,dt){
    if(state.mode==="dialog"){speechBubble.classList.remove("show");return;}
    _jokeTimer+=dt;
    if(_jokeTimer>=JOKE_INTERVAL){
        _jokeTimer=0;_jokeShow=JOKE_DISPLAY;
        speechBubble.textContent=NPC_JOKES[_jokeIdx];
        _jokeIdx=(_jokeIdx+1)%NPC_JOKES.length;
        speechBubble.classList.add("show");
    }
    if(_jokeShow>0){
        _jokeShow-=dt;
        // Project NPC head position to screen
        const headPos=npcGuide.position.clone();
        headPos.y+=2.6; // above head
        const screenPos=headPos.project(camera);
        const hw=window.innerWidth/2,hh=window.innerHeight/2;
        const sx=(screenPos.x*hw)+hw;
        const sy=-(screenPos.y*hh)+hh;
        // Only show if NPC is in front of camera and on screen
        if(screenPos.z>0&&screenPos.z<1&&sx>-50&&sx<window.innerWidth+50&&sy>-50&&sy<window.innerHeight+50){
            speechBubble.style.left=sx+"px";
            speechBubble.style.top=(sy-20)+"px";
        }else{
            speechBubble.classList.remove("show");
        }
        if(_jokeShow<=0)speechBubble.classList.remove("show");
    }
}

/* ====== SMG GUN + COMBAT SYSTEM ====== */
const crosshairEl=document.getElementById("crosshair"),
      gunHudEl=document.getElementById("gun-hud"),
      scopeOverlay=document.getElementById("scope-overlay"),
      scopeZoomLabel=document.getElementById("scope-zoom-label"),
      deathScreen=document.getElementById("death-screen"),
      deathTitle=document.getElementById("death-title"),
      deathSub=document.getElementById("death-sub"),
      hpBar=document.getElementById("hp-bar"),
      hpFill=document.getElementById("hp-fill"),
      muzzleFlashEl=document.getElementById("muzzle-flash");
let _scoped=false;
const SCOPE_FOV=18,NORMAL_FOV=55; // narrow FOV = zoom

// Build SMG mesh ‚Äî gun pivots for pitch aiming
const gunPivot=new THREE.Group(); // this group rotates for pitch (aims up/down)
const gunGroup=new THREE.Group(); // inner group holds the gun mesh
const _gunMats={body:new THREE.MeshStandardMaterial({color:"#2a2a30",roughness:.6,metalness:.7}),
    barrel:new THREE.MeshStandardMaterial({color:"#1a1a20",roughness:.4,metalness:.9}),
    mag:new THREE.MeshStandardMaterial({color:"#3a3020",roughness:.7,metalness:.4}),
    accent:new THREE.MeshStandardMaterial({color:"#884422",roughness:.5,metalness:.3})};
// Receiver body
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.08,.11,.5),_gunMats.body);return m;})());
// Barrel
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.CylinderGeometry(.02,.025,.4,8),_gunMats.barrel);m.rotation.x=Math.PI/2;m.position.set(0,.02,.44);return m;})());
// Barrel shroud
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.07,.07,.2),_gunMats.body);m.position.set(0,.01,.3);return m;})());
// Front sight
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.015,.04,.015),_gunMats.barrel);m.position.set(0,.06,.55);return m;})());
// Rear sight
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.04,.03,.015),_gunMats.barrel);m.position.set(0,.07,.1);return m;})());
// Stock
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.05,.09,.25),_gunMats.body);m.position.set(0,-.01,-.3);return m;})());
// Stock pad
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.06,.1,.03),_gunMats.accent);m.position.set(0,-.01,-.43);return m;})());
// Magazine
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.04,.2,.07),_gunMats.mag);m.position.set(0,-.16,.02);return m;})());
// Grip
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.04,.13,.06),_gunMats.accent);m.position.set(0,-.11,-.1);m.rotation.x=.2;return m;})());
// Trigger guard
gunGroup.add((()=>{const m=new THREE.Mesh(new THREE.BoxGeometry(.025,.02,.08),_gunMats.barrel);m.position.set(0,-.07,-.04);return m;})());
// Muzzle tip (for flash positioning)
const _gunMuzzleTip=new THREE.Object3D();_gunMuzzleTip.position.set(0,.02,.65);
gunGroup.add(_gunMuzzleTip);

gunPivot.add(gunGroup);
gunPivot.visible=false;
gunPivot.scale.setScalar(2.0);
scene.add(gunPivot);

// Muzzle flash light
const _muzzleLight=new THREE.PointLight(0xff8833,0,8);scene.add(_muzzleLight);

// Bullet tracer line
const _tracerGeo=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(),new THREE.Vector3()]);
const _tracerLine=new THREE.Line(_tracerGeo,new THREE.LineBasicMaterial({color:0xffdd44,transparent:true,opacity:0.8}));
_tracerLine.visible=false;scene.add(_tracerLine);
let _tracerTimer=0;

// ====== DESTRUCTION PARTICLE + ANIMATION SYSTEM ======
const _debrisPool=[];
const _dustPool=[];
const _destructAnims=[];

// Generic debris ‚Äî small chunks that fly out and tumble
function spawnDebris(pos,color,count){
    for(let i=0;i<count;i++){
        const size=.15+Math.random()*.35;
        const geo=Math.random()>.5?new THREE.BoxGeometry(size,size,size):new THREE.TetrahedronGeometry(size);
        const m=new THREE.Mesh(geo,new THREE.MeshStandardMaterial({color:color||"#888888"}));
        m.position.copy(pos);
        m.position.x+=(Math.random()-.5)*2;m.position.y+=Math.random()*3;m.position.z+=(Math.random()-.5)*2;
        const vel=new THREE.Vector3((Math.random()-.5)*8,3+Math.random()*6,(Math.random()-.5)*8);
        scene.add(m);
        _debrisPool.push({mesh:m,vel,life:2+Math.random()});
    }
}

// Dust/smoke cloud ‚Äî soft expanding spheres that fade out
function spawnDustCloud(pos,color,count,spread){
    for(let i=0;i<count;i++){
        const size=.8+Math.random()*1.5;
        const geo=new THREE.SphereGeometry(size,6,6);
        const mat=new THREE.MeshBasicMaterial({color:color||"#c0b8a0",transparent:true,opacity:.6,depthWrite:false});
        const m=new THREE.Mesh(geo,mat);
        m.position.copy(pos);
        m.position.x+=(Math.random()-.5)*(spread||3);
        m.position.y+=Math.random()*2;
        m.position.z+=(Math.random()-.5)*(spread||3);
        const vel=new THREE.Vector3((Math.random()-.5)*3,1.5+Math.random()*2,(Math.random()-.5)*3);
        scene.add(m);
        _dustPool.push({mesh:m,mat,vel,life:1.5+Math.random(),maxLife:1.5+Math.random(),growRate:.5+Math.random()*.5});
    }
}

// Fire particles ‚Äî bright orange/yellow sparks that rise and fade
function spawnFire(pos,count){
    const fireColors=["#ff6600","#ff9900","#ffcc00","#ff3300","#ffaa22"];
    for(let i=0;i<count;i++){
        const size=.2+Math.random()*.4;
        const geo=new THREE.SphereGeometry(size,5,5);
        const col=fireColors[Math.floor(Math.random()*fireColors.length)];
        const mat=new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:.9});
        const m=new THREE.Mesh(geo,mat);
        m.position.copy(pos);m.position.x+=(Math.random()-.5)*1.5;m.position.z+=(Math.random()-.5)*1.5;
        const vel=new THREE.Vector3((Math.random()-.5)*5,4+Math.random()*8,(Math.random()-.5)*5);
        scene.add(m);
        _debrisPool.push({mesh:m,vel,life:1+Math.random()*.8,isFire:true,mat});
    }
}

// Water splash ‚Äî blue/white particles that arc outward
function spawnSplash(pos,count){
    const splashColors=["#88bbee","#aaddff","#ffffff","#6699cc"];
    for(let i=0;i<count;i++){
        const size=.3+Math.random()*.5;
        const geo=new THREE.SphereGeometry(size,5,5);
        const col=splashColors[Math.floor(Math.random()*splashColors.length)];
        const mat=new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:.7});
        const m=new THREE.Mesh(geo,mat);
        m.position.copy(pos);m.position.x+=(Math.random()-.5)*4;m.position.z+=(Math.random()-.5)*4;m.position.y=ROAD_Y+.2;
        const vel=new THREE.Vector3((Math.random()-.5)*10,6+Math.random()*10,(Math.random()-.5)*10);
        scene.add(m);
        _debrisPool.push({mesh:m,vel,life:1.5+Math.random(),isSplash:true,mat});
    }
}

// Spark shower ‚Äî tiny bright yellow/white fragments
function spawnSparks(pos,count){
    for(let i=0;i<count;i++){
        const size=.05+Math.random()*.12;
        const geo=new THREE.BoxGeometry(size,size,size*3);
        const mat=new THREE.MeshBasicMaterial({color:Math.random()>.5?"#ffee88":"#ffffff",transparent:true,opacity:1});
        const m=new THREE.Mesh(geo,mat);
        m.position.copy(pos);m.position.x+=(Math.random()-.5);m.position.z+=(Math.random()-.5);
        const vel=new THREE.Vector3((Math.random()-.5)*12,2+Math.random()*6,(Math.random()-.5)*12);
        scene.add(m);
        _debrisPool.push({mesh:m,vel,life:.6+Math.random()*.5,isSpark:true,mat});
    }
}

// Building collapse ‚Äî large rectangular chunks that fall like rubble
function spawnBuildingRubble(pos,meshBox){
    const w=meshBox.max.x-meshBox.min.x,h=meshBox.max.y-meshBox.min.y,d=meshBox.max.z-meshBox.min.z;
    const rubbleColors=["#8a8a80","#706860","#9a9080","#605850","#b0a890"];
    const n=8+Math.floor(Math.random()*8);
    for(let i=0;i<n;i++){
        const sx=.3+Math.random()*Math.min(w*.3,2),sy=.3+Math.random()*Math.min(h*.2,1.5),sz=.3+Math.random()*Math.min(d*.3,2);
        const geo=new THREE.BoxGeometry(sx,sy,sz);
        const col=rubbleColors[Math.floor(Math.random()*rubbleColors.length)];
        const m=new THREE.Mesh(geo,new THREE.MeshStandardMaterial({color:col,roughness:.9}));
        m.position.set(
            meshBox.min.x+Math.random()*w,
            meshBox.min.y+Math.random()*h,
            meshBox.min.z+Math.random()*d
        );
        const vel=new THREE.Vector3((Math.random()-.5)*4,1+Math.random()*3,(Math.random()-.5)*4);
        const rotVel=new THREE.Vector3((Math.random()-.5)*3,(Math.random()-.5)*2,(Math.random()-.5)*3);
        scene.add(m);
        _debrisPool.push({mesh:m,vel,life:3+Math.random()*2,rotVel});
    }
}

// Car parts ‚Äî doors, wheels, hood pieces
function spawnCarParts(pos){
    const partDefs=[
        {geo:new THREE.BoxGeometry(.8,.6,.05),color:"#556677",offy:.5},  // door
        {geo:new THREE.BoxGeometry(.8,.05,.6),color:"#445566",offy:.8},  // hood
        {geo:new THREE.CylinderGeometry(.25,.25,.15,8),color:"#222222",offy:.2}, // wheel
        {geo:new THREE.CylinderGeometry(.25,.25,.15,8),color:"#222222",offy:.2}, // wheel
        {geo:new THREE.BoxGeometry(.4,.3,.05),color:"#aaccff",offy:.6}, // window shard
        {geo:new THREE.BoxGeometry(.3,.2,.05),color:"#ff2200",offy:.3}, // taillight
    ];
    for(const p of partDefs){
        const m=new THREE.Mesh(p.geo,new THREE.MeshStandardMaterial({color:p.color,roughness:.5}));
        m.position.copy(pos);m.position.y+=p.offy;
        m.position.x+=(Math.random()-.5)*1.5;m.position.z+=(Math.random()-.5)*1.5;
        const vel=new THREE.Vector3((Math.random()-.5)*10,5+Math.random()*8,(Math.random()-.5)*10);
        const rotVel=new THREE.Vector3((Math.random()-.5)*8,(Math.random()-.5)*8,(Math.random()-.5)*8);
        scene.add(m);
        _debrisPool.push({mesh:m,vel,life:3+Math.random(),rotVel});
    }
}

// Tick all debris (generic chunks, fire, sparks, splash, rubble)
function tickDebris(dt){
    for(let i=_debrisPool.length-1;i>=0;i--){
        const d=_debrisPool[i];
        d.vel.y-=15*dt;
        d.mesh.position.addScaledVector(d.vel,dt);
        if(d.rotVel){
            d.mesh.rotation.x+=d.rotVel.x*dt;
            d.mesh.rotation.y+=d.rotVel.y*dt;
            d.mesh.rotation.z+=d.rotVel.z*dt;
        }else{
            d.mesh.rotation.x+=dt*3;d.mesh.rotation.z+=dt*2;
        }
        d.life-=dt;
        // Fade out fire/spark/splash particles
        if(d.mat&&(d.isFire||d.isSpark||d.isSplash)){
            d.mat.opacity=Math.max(0,d.life/(d.isSpark?.4:1));
        }
        // Fire rises and shrinks
        if(d.isFire){d.vel.y+=20*dt;d.mesh.scale.multiplyScalar(1-dt*.8);}
        // Ground bounce
        const gy=Math.max(terrainHeight(d.mesh.position.x,d.mesh.position.z),ROAD_Y);
        if(d.mesh.position.y<gy){d.mesh.position.y=gy;d.vel.y*=-.3;d.vel.x*=.7;d.vel.z*=.7;}
        if(d.life<=0){scene.remove(d.mesh);d.mesh.geometry.dispose();_debrisPool.splice(i,1);}
    }
    // Tick dust/smoke clouds
    for(let i=_dustPool.length-1;i>=0;i--){
        const d=_dustPool[i];
        d.mesh.position.addScaledVector(d.vel,dt);
        d.vel.y*=.98;d.vel.x*=.96;d.vel.z*=.96;
        d.mesh.scale.addScalar(d.growRate*dt);
        d.life-=dt;
        d.mat.opacity=Math.max(0,.5*(d.life/d.maxLife));
        if(d.life<=0){scene.remove(d.mesh);d.mesh.geometry.dispose();_dustPool.splice(i,1);}
    }
    // Tick destruction animations (collapse, explode, topple, sink)
    for(let i=_destructAnims.length-1;i>=0;i--){
        const a=_destructAnims[i];
        a.elapsed+=dt;
        a.update(a,dt);
        if(a.elapsed>=a.duration){
            a.finish(a);
            _destructAnims.splice(i,1);
        }
    }
}

// Fireball system (wizard's attack)
let _fireball=null;
function spawnFireball(from,to){
    const geo=new THREE.SphereGeometry(.5,12,12);
    const mat=new THREE.MeshBasicMaterial({color:"#ff4400"});
    const fb=new THREE.Mesh(geo,mat);
    fb.position.copy(from);fb.position.y+=2;
    // Glow
    const glow=new THREE.PointLight(0xff4400,3,12);
    fb.add(glow);
    scene.add(fb);
    const dir=new THREE.Vector3().subVectors(to,fb.position).normalize();
    _fireball={mesh:fb,vel:dir.multiplyScalar(25),target:to,life:5};
}
function tickFireball(dt){
    if(!_fireball)return;
    _fireball.mesh.position.addScaledVector(_fireball.vel,dt);
    _fireball.life-=dt;
    // Check if reached target (player)
    const playerPos=state.mode==="walking"?avatar.position:car.position;
    const dist=_fireball.mesh.position.distanceTo(playerPos);
    if(dist<2||_fireball.life<=0){
        if(dist<3){
            killPlayer();
        }else{
            // Dodged! Fireball expired without hitting player
            state.fireballsDodged++;
            if(state.fireballsDodged>=5)unlock("dodge5");
        }
        scene.remove(_fireball.mesh);
        spawnDebris(_fireball.mesh.position,"#ff4400",8);
        _fireball=null;
    }
}

// Player death
function killPlayer(){
    if(state.isDead)return;
    state.isDead=true;
    state.deathCount++;
    unlock("died");
    if(state.deathCount>=3)unlock("phoenix");
    state.gunEquipped=false;
    _shooting=false;
    unscopeGun();
    gunPivot.visible=false;
    crosshairEl.classList.remove("show");
    gunHudEl.classList.remove("show");
    hpBar.classList.remove("show");
    if(document.pointerLockElement)document.exitPointerLock();
    deathScreen.classList.add("show");
    audio.chime(150,.3);
    setTimeout(()=>{
        deathScreen.classList.remove("show");
        state.isDead=false;
        state.wizardWarnings=0;
        // Respawn at town center
        if(state.mode==="walking"){
            avatar.position.set(0,ROAD_Y+.1,5);
            state.avatarAngle=0;avatar.rotation.y=0;
            _camYaw=0;_camPitch=.3;
        }else{
            car.position.set(0,ROAD_Y+.1,5);car.rotation.y=0;state.speed=0;
        }
    },3000);
}

// Shooting raycaster
const _shootRay=new THREE.Raycaster();
let _shootCooldown=0;
let _shooting=false;
const FIRE_RATE=0.12; // seconds between shots
const BULLET_DAMAGE=10;

function findDestroyableAncestor(obj){
    let cur=obj;
    while(cur){
        if(cur.userData._destroyIdx!==undefined)return destroyables[cur.userData._destroyIdx];
        cur=cur.parent;
    }
    return null;
}

function isWizardHit(obj){
    let cur=obj;
    while(cur){
        if(cur===npcGuide)return true;
        cur=cur.parent;
    }
    return false;
}

function shootGun(){
    if(_shootCooldown>0||state.isDead||state.mode==="dialog")return;
    _shootCooldown=FIRE_RATE;
    // Muzzle flash
    muzzleFlashEl.style.opacity="1";
    setTimeout(()=>{muzzleFlashEl.style.opacity="0";},50);
    // Sound
    audio.chime(120+Math.random()*40,.06);
    setTimeout(()=>audio.chime(80,.03),30);
    // Raycast from camera center
    _shootRay.setFromCamera(new THREE.Vector2(0,0),camera);
    // Get gun muzzle tip world position for tracer
    const gunTip=new THREE.Vector3();
    _gunMuzzleTip.getWorldPosition(gunTip);
    _muzzleLight.position.copy(gunTip);
    _muzzleLight.intensity=4;
    // Intersect everything in scene
    const hits=_shootRay.intersectObjects(scene.children,true);
    let hitPoint=null;
    for(const hit of hits){
        // Skip gun, avatar, armed avatar, gates, tracer
        if(hit.object===_tracerLine)continue;
        let skip=false;
        let cur=hit.object;
        while(cur){
            if(cur===gunPivot||cur===gunGroup||cur===avatar||cur===_tracerLine){skip=true;break;}
            // Skip gate meshes
            if(hotlapGates.some(g=>g.group===cur)){skip=true;break;}
            cur=cur.parent;
        }
        if(skip)continue;
        hitPoint=hit.point.clone();
        // Check wizard
        if(isWizardHit(hit.object)){
            handleWizardShot();
            break;
        }
        // Check destroyable
        const dest=findDestroyableAncestor(hit.object);
        if(dest&&dest.alive){
            dest.health-=BULLET_DAMAGE;
            // Show HP bar
            hpBar.classList.add("show");
            hpFill.style.width=Math.max(0,(dest.health/dest.maxHealth)*100)+"%";
            clearTimeout(shootGun._hpT);
            shootGun._hpT=setTimeout(()=>hpBar.classList.remove("show"),1500);
            if(dest.health<=0){
                destroyObject(dest);
                hpBar.classList.remove("show");
            }
            // Hit particles
            spawnDebris(hit.point,"#aaaaaa",3);
            _camShake=Math.max(_camShake,.15);
            break;
        }
        // Hit terrain/road/other ‚Äî spark
        spawnDebris(hit.point,"#666666",2);
        break;
    }
    // Tracer line
    const endPoint=hitPoint||_shootRay.ray.at(80,new THREE.Vector3());
    const positions=_tracerLine.geometry.attributes.position;
    positions.setXYZ(0,gunTip.x,gunTip.y,gunTip.z);
    positions.setXYZ(1,endPoint.x,endPoint.y,endPoint.z);
    positions.needsUpdate=true;
    _tracerLine.visible=true;_tracerTimer=0.06;
}

function destroyObject(dest){
    if(!dest.alive)return;
    dest.alive=false;
    const pos=new THREE.Vector3();
    dest.mesh.getWorldPosition(pos);
    const meshBox=new THREE.Box3().setFromObject(dest.mesh);
    // Remove from staticCol immediately so player can walk through
    for(let i=staticCol.length-1;i>=0;i--){
        const b=staticCol[i];
        if(b.intersectsBox(meshBox)||b.containsPoint(pos)){staticCol.splice(i,1);break;}
    }
    // Remove from dynCol too (benches, signs, crates, barrels, etc.)
    for(let i=dynCol.length-1;i>=0;i--){
        if(dynCol[i].mesh===dest.mesh){dynCol.splice(i,1);break;}
    }
    // Track destruction for achievements
    state.destroyCount++;
    if(dest.type==="building")state.destroyBuildings++;
    if(dest.type==="car")state.destroyCars++;
    if(dest.type==="billboard")state.destroyBillboards++;
    if(dest.type==="ship")state.destroyShips++;
    state.destroyTimestamps.push(performance.now());
    // Trim old timestamps (keep last 30s)
    const cutoff=performance.now()-30000;
    state.destroyTimestamps=state.destroyTimestamps.filter(t=>t>cutoff);
    // Achievement checks
    unlock("first_kill");
    if(state.destroyBuildings>=5)unlock("build5");
    if(state.destroyCars>=5)unlock("car5");
    if(state.destroyBillboards>=5)unlock("bb5");
    if(dest.type==="ship")unlock("ship");
    if(state.destroyCount>=10)unlock("destroy10");
    if(state.destroyCount>=25)unlock("destroy25");
    if(state.destroyTimestamps.length>=5)unlock("rampage5");
    // Check if ALL destroyables are dead
    if(destroyables.every(d=>!d.alive))unlock("destroy_all");
    // Check if ALL buildings destroyed
    if(destroyables.filter(d=>d.type==="building").every(d=>!d.alive))unlock("build_all");

    // TYPE-SPECIFIC DESTRUCTION ANIMATIONS
    if(dest.type==="building"){
        // BUILDING COLLAPSE: rubble chunks burst out, dust cloud rises,
        // the building itself shrinks downward and fades over ~2.5s
        const h=meshBox.max.y-meshBox.min.y;
        spawnBuildingRubble(pos,meshBox);
        spawnDustCloud(new THREE.Vector3(pos.x,pos.y+h*.3,pos.z),"#c0b8a0",12,Math.max(meshBox.max.x-meshBox.min.x,meshBox.max.z-meshBox.min.z));
        spawnSparks(pos,6);
        audio.chime(40,.2);setTimeout(()=>audio.chime(30,.15),200);setTimeout(()=>audio.chime(25,.1),500);
        _camShake=Math.max(_camShake,.8);
        // Save original transforms for the animated collapse
        const origScaleY=dest.mesh.scale.y;
        const origY=dest.mesh.position.y;
        _destructAnims.push({
            mesh:dest.mesh,elapsed:0,duration:2.5,origScaleY,origY,
            update(a,dt){
                const t=Math.min(a.elapsed/a.duration,1);
                // Building shrinks vertically and sinks into ground
                const ease=t*t; // accelerating
                a.mesh.scale.y=a.origScaleY*(1-ease*.95);
                a.mesh.position.y=a.origY-ease*2;
                // Fade mesh opacity
                a.mesh.traverse(ch=>{if(ch.isMesh&&ch.material){
                    if(!ch.material._origOpacity){ch.material._origOpacity=ch.material.opacity;ch.material.transparent=true;}
                    ch.material.opacity=ch.material._origOpacity*(1-t);
                }});
                // Spawn trailing dust during collapse
                if(Math.random()<dt*3){
                    spawnDustCloud(new THREE.Vector3(
                        pos.x+(Math.random()-.5)*3,pos.y+1,pos.z+(Math.random()-.5)*3
                    ),"#b0a890",1,2);
                }
            },
            finish(a){a.mesh.visible=false;
                a.mesh.traverse(ch=>{if(ch.isMesh&&ch.material&&ch.material._origOpacity){ch.material.opacity=ch.material._origOpacity;delete ch.material._origOpacity;}});
            }
        });

    }else if(dest.type==="car"){
        // CAR EXPLOSION: car parts fly off, fire + smoke, car flips upward and spins
        spawnCarParts(pos);
        spawnFire(pos,15);
        spawnDustCloud(new THREE.Vector3(pos.x,pos.y+1,pos.z),"#333333",6,2);
        spawnSparks(pos,12);
        audio.chime(80,.2);setTimeout(()=>audio.chime(50,.15),80);setTimeout(()=>audio.chime(35,.1),200);
        _camShake=Math.max(_camShake,.6);
        // Flash light for explosion
        const expLight=new THREE.PointLight(0xff6600,5,15);
        expLight.position.copy(pos);expLight.position.y+=1.5;scene.add(expLight);
        const origY=dest.mesh.position.y;
        _destructAnims.push({
            mesh:dest.mesh,elapsed:0,duration:2.0,expLight,origY,
            update(a,dt){
                const t=Math.min(a.elapsed/a.duration,1);
                // Car launches up, spins, and falls
                const upPhase=Math.min(t*3,1); // rises for first third
                const arc=Math.sin(upPhase*Math.PI)*5; // parabolic arc
                a.mesh.position.y=a.origY+arc;
                a.mesh.rotation.x+=dt*4; // tumble
                a.mesh.rotation.z+=dt*2.5;
                // Fade explosion light
                a.expLight.intensity=Math.max(0,5*(1-t*2));
                // Shrink car as it burns
                if(t>.5){
                    const fade=(t-.5)*2;
                    a.mesh.scale.multiplyScalar(1-dt*1.2);
                    a.mesh.traverse(ch=>{if(ch.isMesh&&ch.material){
                        if(!ch.material._origOpacity){ch.material._origOpacity=ch.material.opacity;ch.material.transparent=true;}
                        ch.material.opacity=ch.material._origOpacity*(1-fade);
                    }});
                }
                // Trailing fire during explosion
                if(t<.7&&Math.random()<dt*8){
                    spawnFire(a.mesh.position,2);
                }
            },
            finish(a){a.mesh.visible=false;scene.remove(a.expLight);
                a.mesh.traverse(ch=>{if(ch.isMesh&&ch.material&&ch.material._origOpacity){ch.material.opacity=ch.material._origOpacity;delete ch.material._origOpacity;}});
            }
        });

    }else if(dest.type==="billboard"){
        // BILLBOARD TOPPLE: leans to one side, falls over with a creak, shatters on impact
        spawnSparks(pos,8);
        spawnDebris(pos,"#3a3a40",6);
        audio.chime(200,.1);setTimeout(()=>audio.chime(100,.08),300);setTimeout(()=>audio.chime(50,.12),800);
        _camShake=Math.max(_camShake,.3);
        const fallDir=Math.random()>.5?1:-1;
        const origRotZ=dest.mesh.rotation.z;
        const origRotX=dest.mesh.rotation.x;
        const fallAngle=(Math.random()>.5?1:0); // fall on X or Z axis
        _destructAnims.push({
            mesh:dest.mesh,elapsed:0,duration:1.8,fallDir,origRotZ,origRotX,fallAngle,shattered:false,
            update(a,dt){
                const t=Math.min(a.elapsed/a.duration,1);
                // Slow start, then accelerating fall (like gravity)
                const angle=a.fallDir*(Math.PI/2)*Math.min(t*t*1.5,1);
                if(a.fallAngle===0){
                    a.mesh.rotation.z=a.origRotZ+angle;
                }else{
                    a.mesh.rotation.x=a.origRotX+angle;
                }
                // On impact (halfway through), spawn impact debris
                if(t>.55&&!a.shattered){
                    a.shattered=true;
                    const impactPos=new THREE.Vector3();a.mesh.getWorldPosition(impactPos);
                    spawnDebris(impactPos,"#555555",8);
                    spawnDustCloud(impactPos,"#999999",4,3);
                    audio.chime(50,.15);
                    _camShake=Math.max(_camShake,.25);
                }
                // Fade out after hitting ground
                if(t>.6){
                    const fade=(t-.6)/0.4;
                    a.mesh.traverse(ch=>{if(ch.isMesh&&ch.material){
                        if(!ch.material._origOpacity){ch.material._origOpacity=ch.material.opacity;ch.material.transparent=true;}
                        ch.material.opacity=ch.material._origOpacity*(1-fade);
                    }});
                }
            },
            finish(a){a.mesh.visible=false;
                a.mesh.traverse(ch=>{if(ch.isMesh&&ch.material&&ch.material._origOpacity){ch.material.opacity=ch.material._origOpacity;delete ch.material._origOpacity;}});
            }
        });

    }else if(dest.type==="ship"){
        // SHIP SINKING: massive explosion, ship tilts and slowly sinks, water splashes
        const shipH=meshBox.max.y-meshBox.min.y;
        spawnFire(new THREE.Vector3(pos.x,pos.y+shipH*.5,pos.z),25);
        spawnDustCloud(new THREE.Vector3(pos.x,pos.y+shipH*.6,pos.z),"#222222",15,8);
        spawnSplash(pos,20);
        spawnBuildingRubble(pos,meshBox); // ship hull fragments
        spawnSparks(new THREE.Vector3(pos.x,pos.y+shipH*.3,pos.z),15);
        audio.chime(30,.25);setTimeout(()=>audio.chime(25,.2),300);setTimeout(()=>audio.chime(20,.15),700);setTimeout(()=>audio.chime(15,.1),1200);
        _camShake=Math.max(_camShake,1.5);
        // Explosion flash
        const expLight=new THREE.PointLight(0xff4400,8,30);
        expLight.position.copy(pos);expLight.position.y+=shipH*.5;scene.add(expLight);
        const origY=dest.mesh.position.y;
        const origRotX=dest.mesh.rotation.x;
        const origRotZ=dest.mesh.rotation.z;
        const tiltDir=(Math.random()-.5)*.3;
        _destructAnims.push({
            mesh:dest.mesh,elapsed:0,duration:5.0,expLight,origY,origRotX,origRotZ,tiltDir,shipH,
            update(a,dt){
                const t=Math.min(a.elapsed/a.duration,1);
                // Ship slowly tilts and sinks
                const sinkEase=t*t; // accelerating sink
                a.mesh.position.y=a.origY-sinkEase*a.shipH*1.2;
                a.mesh.rotation.x=a.origRotX+t*a.tiltDir;
                a.mesh.rotation.z=a.origRotZ+t*.15;
                // Fade explosion light quickly
                a.expLight.intensity=Math.max(0,8*(1-t*3));
                // Ongoing fire while sinking
                if(t<.6&&Math.random()<dt*5){
                    const firePos=new THREE.Vector3(
                        pos.x+(Math.random()-.5)*6,
                        Math.max(a.mesh.position.y+a.shipH*.3,ROAD_Y),
                        pos.z+(Math.random()-.5)*6
                    );
                    spawnFire(firePos,3);
                }
                // Water splashes as it sinks
                if(t>.2&&t<.8&&Math.random()<dt*4){
                    spawnSplash(new THREE.Vector3(pos.x+(Math.random()-.5)*8,ROAD_Y,pos.z+(Math.random()-.5)*8),3);
                }
                // Fade opacity in last 40%
                if(t>.6){
                    const fade=(t-.6)/0.4;
                    a.mesh.traverse(ch=>{if(ch.isMesh&&ch.material){
                        if(!ch.material._origOpacity){ch.material._origOpacity=ch.material.opacity;ch.material.transparent=true;}
                        ch.material.opacity=ch.material._origOpacity*(1-fade);
                    }});
                }
            },
            finish(a){a.mesh.visible=false;scene.remove(a.expLight);
                a.mesh.traverse(ch=>{if(ch.isMesh&&ch.material&&ch.material._origOpacity){ch.material.opacity=ch.material._origOpacity;delete ch.material._origOpacity;}});
            }
        });

    }else if(dest.type==="prop"){
        // PROP SMASH: pops upward, spins, debris burst, fades quickly
        spawnDebris(pos,"#8a7a60",8);
        spawnDustCloud(pos,"#b0a890",4,1.5);
        spawnSparks(pos,4);
        audio.chime(300,.08);setTimeout(()=>audio.chime(180,.06),100);
        _camShake=Math.max(_camShake,.15);
        const origY=dest.mesh.position.y;
        const spinDir=(Math.random()-.5)*12;
        const launchX=(Math.random()-.5)*3;
        const launchZ=(Math.random()-.5)*3;
        _destructAnims.push({
            mesh:dest.mesh,elapsed:0,duration:1.2,origY,spinDir,launchX,launchZ,
            update(a,dt){
                const t=Math.min(a.elapsed/a.duration,1);
                // Pop upward then fall
                const arc=Math.sin(t*Math.PI)*2.5;
                a.mesh.position.y=a.origY+arc*(1-t);
                a.mesh.position.x+=a.launchX*dt;
                a.mesh.position.z+=a.launchZ*dt;
                // Spin wildly
                a.mesh.rotation.x+=a.spinDir*dt;
                a.mesh.rotation.z+=a.spinDir*.7*dt;
                // Shrink
                const shrink=Math.max(1-t*t,.01);
                if(!a._origScale)a._origScale=a.mesh.scale.clone();
                a.mesh.scale.copy(a._origScale).multiplyScalar(shrink);
                if(t>.3){
                    a.mesh.traverse(ch=>{if(ch.isMesh&&ch.material){
                        if(!ch.material._origOpacity){ch.material._origOpacity=ch.material.opacity;ch.material.transparent=true;}
                        ch.material.opacity=ch.material._origOpacity*(1-((t-.3)/.7));
                    }});
                }
            },
            finish(a){a.mesh.visible=false;
                a.mesh.traverse(ch=>{if(ch.isMesh&&ch.material&&ch.material._origOpacity){ch.material.opacity=ch.material._origOpacity;delete ch.material._origOpacity;}});
            }
        });

    }else if(dest.type==="tree"){
        // TREE TIMBER: leans to one side and crashes down with leaves scattering
        spawnDebris(pos,"#4a8a3a",10); // green leaf debris
        spawnDebris(pos,"#7d5a38",4);  // bark chunks
        spawnDustCloud(new THREE.Vector3(pos.x,pos.y+1,pos.z),"#8a9a60",6,2);
        audio.chime(120,.1);setTimeout(()=>audio.chime(60,.12),500);setTimeout(()=>audio.chime(40,.08),900);
        _camShake=Math.max(_camShake,.25);
        const fallDir=Math.random()>.5?1:-1;
        const fallAxis=Math.random()>.5?0:1; // 0=Z, 1=X
        const origRotX=dest.mesh.rotation.x;
        const origRotZ=dest.mesh.rotation.z;
        _destructAnims.push({
            mesh:dest.mesh,elapsed:0,duration:2.0,fallDir,fallAxis,origRotX,origRotZ,impacted:false,
            update(a,dt){
                const t=Math.min(a.elapsed/a.duration,1);
                // Slow start, accelerating fall like timber
                const angle=a.fallDir*(Math.PI/2)*Math.min(t*t*2,1);
                if(a.fallAxis===0){
                    a.mesh.rotation.z=a.origRotZ+angle;
                }else{
                    a.mesh.rotation.x=a.origRotX+angle;
                }
                // Ground impact at ~70%
                if(t>.55&&!a.impacted){
                    a.impacted=true;
                    const impPos=new THREE.Vector3();a.mesh.getWorldPosition(impPos);
                    spawnDebris(impPos,"#4a8a3a",6);
                    spawnDustCloud(impPos,"#889870",3,2.5);
                    audio.chime(50,.1);
                    _camShake=Math.max(_camShake,.15);
                }
                // Fade out after hitting ground
                if(t>.65){
                    const fade=(t-.65)/0.35;
                    a.mesh.traverse(ch=>{if(ch.isMesh&&ch.material){
                        if(!ch.material._origOpacity){ch.material._origOpacity=ch.material.opacity;ch.material.transparent=true;}
                        ch.material.opacity=ch.material._origOpacity*(1-fade);
                    }});
                }
            },
            finish(a){a.mesh.visible=false;
                a.mesh.traverse(ch=>{if(ch.isMesh&&ch.material&&ch.material._origOpacity){ch.material.opacity=ch.material._origOpacity;delete ch.material._origOpacity;}});
            }
        });

    }else{
        // FALLBACK: generic instant destruction
        spawnDebris(pos,"#888888",10);
        _camShake=Math.max(_camShake,.4);
        audio.chime(60,.15);
        dest.mesh.visible=false;
    }
}

// Wizard protection & boss fight
function handleWizardShot(){
    if(state.wizardDead)return;
    state.wizardWarnings++;
    unlock("wizard_warn");
    if(state.wizardWarnings===1){
        speechBubble.textContent="Careful where you aim that, mortal...";
        speechBubble.classList.add("show");
        _jokeShow=4;
        audio.chime(300,.1);
    }else if(state.wizardWarnings===2){
        speechBubble.textContent="I'm WARNING you. Stop. Now.";
        speechBubble.classList.add("show");
        _jokeShow=4;
        audio.chime(200,.15);
    }else if(state.wizardWarnings>=3&&state.wizardWarnings<10){
        // Wizard attacks ‚Äî escalating fury
        const taunts=[
            "You've chosen poorly!",
            "FOOL! You cannot defeat me!",
            "My power built this WORLD!",
            "Every pixel answers to ME!",
            "Is that all you've got?!",
            "I will END your simulation!",
            "You're NOTHING without my code!"
        ];
        speechBubble.textContent=taunts[Math.min(state.wizardWarnings-3,taunts.length-1)];
        speechBubble.classList.add("show");
        _jokeShow=3;
        audio.chime(Math.max(60,200-(state.wizardWarnings-3)*20),.2);
        // Fire back ‚Äî more fireballs at higher hit counts
        const wizPos=npcGuide.position.clone();
        const pPos=avatar.position.clone();
        spawnFireball(wizPos,pPos);
        // After 6 hits, wizard fires a second fireball with slight offset
        if(state.wizardWarnings>=6){
            setTimeout(()=>{
                if(state.wizardDead||state.isDead)return;
                const p2=avatar.position.clone();
                p2.x+=(Math.random()-.5)*4;p2.z+=(Math.random()-.5)*4;
                spawnFireball(npcGuide.position.clone(),p2);
            },400);
        }
    }else if(state.wizardWarnings>=10){
        // WIZARD DEFEATED!
        killWizard();
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê WIZARD DEATH ‚Äî MATRIX RAIN SEQUENCE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function killWizard(){
    if(state.wizardDead)return;
    state.wizardDead=true;
    unlock("wizard_kill");
    // Holster gun
    state.gunEquipped=false;_shooting=false;unscopeGun();
    gunPivot.visible=false;crosshairEl.classList.remove("show");gunHudEl.classList.remove("show");
    hpBar.classList.remove("show");
    if(document.pointerLockElement)document.exitPointerLock();
    // Wizard death speech
    speechBubble.textContent="No... NO! Without me... there is no simulation...";
    speechBubble.classList.add("show");
    audio.chime(80,.3);
    // Wizard explosion ‚Äî burst of debris
    const wPos=npcGuide.position.clone();
    spawnDebris(wPos,"#aa44ff",20);
    spawnDebris(wPos,"#ff4400",15);
    spawnDebris(wPos,"#00ff88",10);
    _camShake=2.0;
    // Wizard dissolves
    let _wizFade=1;
    const _wizFadeInt=setInterval(()=>{
        _wizFade-=0.02;
        npcGuide.traverse(ch=>{if(ch.isMesh){ch.material=ch.material.clone();ch.material.transparent=true;ch.material.opacity=Math.max(0,_wizFade);}});
        if(_wizFade<=0){
            clearInterval(_wizFadeInt);
            npcGuide.visible=false;
            speechBubble.classList.remove("show");
        }
    },30);
    // Phase 1: World shakes and objects start falling (1.5s delay)
    setTimeout(()=>{
        _camShake=3.0;
        audio.chime(40,.4);
        // Make all visible objects slowly fall/sink
        const _crumbleObjs=[];
        scene.children.forEach(ch=>{
            if(ch.isMesh||ch.isGroup){
                if(ch===camera||ch===avatar||ch===gunPivot||ch===_tracerLine)return;
                _crumbleObjs.push({obj:ch,vy:-(Math.random()*2+1),rot:new THREE.Vector3((Math.random()-.5)*.02,(Math.random()-.5)*.02,(Math.random()-.5)*.02)});
            }
        });
        let _crumbleT=0;
        const _crumbleInt=setInterval(()=>{
            _crumbleT+=0.016;
            _crumbleObjs.forEach(c=>{
                c.obj.position.y+=c.vy*0.016*(_crumbleT*2);
                c.obj.rotation.x+=c.rot.x;c.obj.rotation.z+=c.rot.z;
            });
            _camShake=Math.max(1,3-_crumbleT);
            if(_crumbleT>3)clearInterval(_crumbleInt);
        },16);
    },1500);
    // Phase 2: Matrix screen fades in (3s delay)
    setTimeout(()=>{
        const matScreen=document.getElementById("matrix-screen");
        const matCanvas=document.getElementById("matrix-canvas");
        const matText=document.getElementById("matrix-text");
        const matReturn=document.getElementById("matrix-return");
        matScreen.style.opacity="1";matScreen.style.pointerEvents="auto";
        // Matrix rain canvas
        const ctx=matCanvas.getContext("2d");
        matCanvas.width=window.innerWidth;matCanvas.height=window.innerHeight;
        const fontSize=14;
        const cols=Math.floor(matCanvas.width/fontSize);
        const drops=new Array(cols).fill(1);
        const chars="„Ç¢„Ç§„Ç¶„Ç®„Ç™„Ç´„Ç≠„ÇØ„Ç±„Ç≥„Çµ„Ç∑„Çπ„Çª„ÇΩ„Çø„ÉÅ„ÉÑ„ÉÜ„Éà„Éä„Éã„Éå„Éç„Éé„Éè„Éí„Éï„Éò„Éõ„Éû„Éü„É†„É°„É¢„É§„É¶„É®„É©„É™„É´„É¨„É≠„ÉØ„É≤„É≥0123456789ABCDEF{}[]<>=/\\|;:~`!@#$%^&*()_+";
        function drawMatrix(){
            ctx.fillStyle="rgba(0,0,0,0.05)";
            ctx.fillRect(0,0,matCanvas.width,matCanvas.height);
            ctx.fillStyle="#00ff41";
            ctx.font=fontSize+"px 'Courier New',monospace";
            for(let i=0;i<drops.length;i++){
                const ch=chars[Math.floor(Math.random()*chars.length)];
                // Vary brightness
                const bright=Math.random();
                if(bright>.9)ctx.fillStyle="#aaffaa";
                else if(bright>.6)ctx.fillStyle="#00ff41";
                else ctx.fillStyle="#008f22";
                ctx.fillText(ch,i*fontSize,drops[i]*fontSize);
                if(drops[i]*fontSize>matCanvas.height&&Math.random()>.975)drops[i]=0;
                drops[i]++;
            }
        }
        const _matInt=setInterval(drawMatrix,33);
        // Resize handler
        const _matResize=()=>{matCanvas.width=window.innerWidth;matCanvas.height=window.innerHeight;drops.length=Math.floor(matCanvas.width/fontSize);for(let i=0;i<drops.length;i++)if(drops[i]===undefined)drops[i]=Math.floor(Math.random()*matCanvas.height/fontSize);};
        window.addEventListener("resize",_matResize);
        // Phase 3: Text fades in (5s after matrix starts)
        setTimeout(()=>{
            matText.style.opacity="1";
            matText.style.pointerEvents="auto";
            audio.chime(200,.15);setTimeout(()=>audio.chime(150,.12),400);setTimeout(()=>audio.chime(100,.1),800);
        },4000);
        // Phase 4: Return button appears (8s after matrix starts)
        setTimeout(()=>{
            matReturn.style.opacity="1";
            matReturn.onclick=()=>{
                // Fade out matrix screen
                matScreen.style.opacity="0";
                setTimeout(()=>{
                    matScreen.style.pointerEvents="none";
                    clearInterval(_matInt);
                    window.removeEventListener("resize",_matResize);
                    // Reset the world ‚Äî reload
                    location.reload();
                },1800);
            };
        },8000);
    },3000);
}

// Equip/holster gun
function toggleGun(){
    if(IS_MOBILE)return; // Combat disabled on mobile (requires pointer lock)
    if(!state.hasGun||state.mode!=="walking"||state.isDead||state.swimming)return;
    state.gunEquipped=!state.gunEquipped;
    if(state.gunEquipped){
        // Avatar stays visible ‚Äî gun appears at their side
        gunPivot.visible=true;
        crosshairEl.classList.add("show");
        gunHudEl.classList.add("show");
        unlock("armed");
        _camPitch=0; // Level pitch for FPS
        // Request pointer lock for FPS aiming
        renderer.domElement.requestPointerLock();
        showToast("SMG equipped ‚Äî LMB fire ¬∑ RMB scope ¬∑ 1/ESC holster");
        updateModeBadge();
    }else{
        holsterGun();
    }
}
function holsterGun(){
    state.gunEquipped=false;
    unscopeGun();
    gunPivot.visible=false;
    crosshairEl.classList.remove("show");
    gunHudEl.classList.remove("show");
    hpBar.classList.remove("show");
    _camPitch=.3; // Reset to normal walking pitch
    if(document.pointerLockElement)document.exitPointerLock();
    updateModeBadge();
}
function scopeGun(){
    if(!state.gunEquipped||_scoped)return;
    _scoped=true;
    scopeOverlay.classList.add("show");
    scopeZoomLabel.classList.add("show");
    crosshairEl.classList.remove("show");
    gunPivot.visible=false; // hide gun mesh in scope view
}
function unscopeGun(){
    if(!_scoped)return;
    _scoped=false;
    scopeOverlay.classList.remove("show");
    scopeZoomLabel.classList.remove("show");
    if(state.gunEquipped){
        crosshairEl.classList.add("show");
        gunPivot.visible=true;
    }
    camera.fov=NORMAL_FOV;camera.updateProjectionMatrix();
}

// Pointer lock change handler
document.addEventListener("pointerlockchange",()=>{
    if(!document.pointerLockElement&&state.gunEquipped){
        holsterGun();
    }
    // If lost pointer lock while diving, exit diving
    if(!document.pointerLockElement&&state.mode==="diving"){
        state.mode="walking";
        state.swimming=false;state.underwater=false;state.diving=false;
        avatar.visible=true;
        avatar.position.set(0,.3,-55);
        state.jumpVelY=0;state.isJumping=false;
        diveLight.visible=false;diveAmbient.visible=false;
        camera.fov=NORMAL_FOV;camera.updateProjectionMatrix();
        _camPitch=.3;
        state.divePos=null;
    }
});

/* ====== GARAGE RENDERER ====== */
// Mini renderer for garage preview
const _prevRenderer=new THREE.WebGLRenderer({alpha:true,antialias:true});
_prevRenderer.setSize(360,200);_prevRenderer.setPixelRatio(Math.min(devicePixelRatio,2));
const _prevScene=new THREE.Scene();
_prevScene.add(new THREE.AmbientLight(0xffffff,.6));
_prevScene.add(new THREE.DirectionalLight(0xffffff,.8));
const _prevCam=new THREE.PerspectiveCamera(35,1.6,0.1,50);
_prevCam.position.set(3,2,4);_prevCam.lookAt(0,.5,0);
// ===== Virtual Garage (Carousel Modal) =====
const _garageKeys=Object.keys(CAR_MODELS);
let _garageIdx=0;
let _garageModel=null;
let _garageSpinRAF=null;
let _garageOpenedFrom=null; // mode we came from ‚Äî return here on close without selecting
const garagePreviewEl=document.getElementById("garage-preview"),
      garageNameEl=document.getElementById("garage-car-name"),
      garageDescEl=document.getElementById("garage-car-desc"),
      garageBadgeEl=document.getElementById("garage-car-badge"),
      garageSelectBtn=document.getElementById("garage-select-btn"),
      garageDotsEl=document.getElementById("garage-dots"),
      garageCounterEl=document.getElementById("garage-counter");

function openGarage(){
    if(state.unlockedCars.length<2)return; // need at least 2 cars
    _garageOpenedFrom=state.mode; // remember so we can return on cancel
    _garageIdx=Math.max(0,_garageKeys.indexOf(state.activeCar));
    _updateGarageUI();
    garageOverlay.classList.add("show");
    _startGarageSpin();
}
function _updateGarageUI(){
    const key=_garageKeys[_garageIdx];
    const cm=CAR_MODELS[key];
    const unlocked=state.unlockedCars.includes(key);
    garageNameEl.textContent=cm.name;
    garageDescEl.textContent=cm.desc;
    // Counter
    const collected=state.unlockedCars.length;
    garageCounterEl.textContent=`${collected} / ${_garageKeys.length} collected`;
    // Badge & button
    if(state.activeCar===key){
        garageBadgeEl.textContent="Currently Equipped";garageBadgeEl.className="garage-car-badge current";
        garageSelectBtn.textContent="Spawn This Car";garageSelectBtn.disabled=false;
    }else if(unlocked){
        garageBadgeEl.textContent="Unlocked";garageBadgeEl.className="garage-car-badge available";
        garageSelectBtn.textContent="Spawn This Car";garageSelectBtn.disabled=false;
    }else{
        garageBadgeEl.textContent="Locked";garageBadgeEl.className="garage-car-badge locked";
        garageSelectBtn.textContent="Locked";garageSelectBtn.disabled=true;
    }
    // Clear old preview model
    while(_prevScene.children.length>2)_prevScene.remove(_prevScene.children[2]);
    _garageModel=null;
    // Preview canvas
    garagePreviewEl.innerHTML="";
    if(unlocked){
        const cvs=document.createElement("canvas");cvs.width=640;cvs.height=400;
        garagePreviewEl.appendChild(cvs);
        new GLTFLoader().load(cm.path,gltf=>{
            const m=gltf.scene;m.updateMatrixWorld(true);
            const b=realBounds(m);const maxDim=Math.max(b.max.x-b.min.x,b.max.y-b.min.y,b.max.z-b.min.z);
            const sc=2.5/maxDim;m.scale.setScalar(sc);m.updateMatrixWorld(true);
            const b2=realBounds(m);
            m.position.y-=b2.min.y;m.position.x-=(b2.min.x+b2.max.x)/2;m.position.z-=(b2.min.z+b2.max.z)/2;
            m.traverse(ch=>{if(ch.isMesh){const mats=Array.isArray(ch.material)?ch.material:[ch.material];mats.forEach(mt=>{mt.side=THREE.FrontSide;});}});
            _prevScene.add(m);
            _garageModel=m;
        });
    }else{
        garagePreviewEl.innerHTML='<div class="locked-overlay"><span>&#128274;</span><div class="locked-text">Complete the quest to unlock</div></div>';
    }
    // Dots
    garageDotsEl.innerHTML="";
    _garageKeys.forEach((k,i)=>{
        const dot=document.createElement("div");
        const u=state.unlockedCars.includes(k);
        dot.className="garage-dot"+(i===_garageIdx?" active":"")+(u?"":" locked");
        dot.onclick=()=>{_garageIdx=i;_updateGarageUI();audio.chime(440,.05);};
        garageDotsEl.appendChild(dot);
    });
}
function _startGarageSpin(){
    if(_garageSpinRAF)cancelAnimationFrame(_garageSpinRAF);
    function spin(){
        _garageSpinRAF=requestAnimationFrame(spin);
        if(!garageOverlay.classList.contains("show")){cancelAnimationFrame(_garageSpinRAF);_garageSpinRAF=null;return;}
        if(_garageModel)_garageModel.rotation.y+=0.008;
        _prevRenderer.setSize(640,400);
        _prevRenderer.render(_prevScene,_prevCam);
        const c2=garagePreviewEl.querySelector("canvas");
        if(c2){const ctx=c2.getContext("2d");ctx.clearRect(0,0,c2.width,c2.height);ctx.drawImage(_prevRenderer.domElement,0,0,c2.width,c2.height);}
    }
    spin();
}
function _cleanupGarage(){
    garageOverlay.classList.remove("show");
    if(_garageSpinRAF){cancelAnimationFrame(_garageSpinRAF);_garageSpinRAF=null;}
    while(_prevScene.children.length>2)_prevScene.remove(_prevScene.children[2]);
    _garageModel=null;
}
window._garageClose=function(){
    _cleanupGarage();
    // Return to the mode we came from ‚Äî don't force enterCarMode
    if(_garageOpenedFrom==="walking"){
        state.mode="walking";updateModeBadge();
    }else if(_garageOpenedFrom==="driving"){
        // Already in driving mode / car mode
    }
    _garageOpenedFrom=null;
};
window._garagePrev=function(){
    _garageIdx=(_garageIdx-1+_garageKeys.length)%_garageKeys.length;
    _updateGarageUI();
    audio.chime(440,.06);
};
window._garageNext=function(){
    _garageIdx=(_garageIdx+1)%_garageKeys.length;
    _updateGarageUI();
    audio.chime(440,.06);
};
window._garageSelect=function(){
    const key=_garageKeys[_garageIdx];
    if(!state.unlockedCars.includes(key))return;
    selectCar(key);
};
function selectCar(key){
    const fromMode=_garageOpenedFrom||state.mode;
    const wasSameCar=(key===state.activeCar);
    _cleanupGarage();
    _garageOpenedFrom=null;
    // Save to localStorage
    state.activeCar=key;
    _saveGarage();
    if(wasSameCar){
        // Same car selected ‚Äî just enter car mode
        enterCarMode();return;
    }
    // Remove current car children & load new model
    while(car.children.length)car.remove(car.children[0]);
    const cm=CAR_MODELS[key];
    // If opened from walking mode, move the car to the avatar's position
    if(fromMode==="walking"){
        const heading=state.avatarAngle;
        const spawnDist=3.5;
        car.position.set(
            avatar.position.x+Math.sin(heading)*spawnDist,
            avatar.position.y,
            avatar.position.z+Math.cos(heading)*spawnDist
        );
        car.rotation.y=heading;
        state.speed=0;
        state.carParkedAt=car.position.clone();
    }
    // Load new model
    new GLTFLoader().load(cm.path,gltf=>{
        const m=gltf.scene;
        let b=realBounds(m);
        const rawW=b.max.x-b.min.x,rawD=b.max.z-b.min.z;
        const sc=(cm.targetSize||4.0)/Math.max(rawW,rawD);
        m.scale.setScalar(sc);
        m.updateMatrixWorld(true);
        m.traverse(ch=>{
            if(!ch.isMesh)return;
            const chn=ch.name.toLowerCase();
            if(chn.includes('collider')||chn.includes('ground')||chn.includes('floor')||chn.includes('shadow_plane')||chn.includes('road')||chn.includes('asphalt')||chn.includes('parking')){ch.visible=false;return;}
            const wb=new THREE.Box3().setFromObject(ch);
            const wh=wb.max.y-wb.min.y, ww=wb.max.x-wb.min.x, wd=wb.max.z-wb.min.z;
            const area=ww*wd;
            if(wh<0.05&&area>4){ch.visible=false;return;}
            const mats=Array.isArray(ch.material)?ch.material:[ch.material];
            mats.forEach(mt=>{
                mt.depthWrite=true;
                const nm=(mt.name||'').toLowerCase()+chn;
                if(nm.includes('glass')||nm.includes('window')||nm.includes('transparent')){
                    mt.transparent=true;mt.opacity=0.3;mt.side=THREE.FrontSide;
                }else{
                    mt.transparent=false;mt.opacity=1;mt.side=THREE.FrontSide;
                }});});
        const wrap=new THREE.Group();wrap.add(m);
        wrap.rotation.y=cm.rotY;
        // Reset car transform, measure, then center the model on origin
        const savedPos=car.position.clone();
        const savedRot=car.rotation.y;
        car.position.set(0,0,0);car.rotation.y=0;
        car.add(wrap);
        wrap.position.set(0,0,0);
        car.updateMatrixWorld(true);
        b=realBounds(car);
        const cxW=(b.min.x+b.max.x)/2,czW=(b.min.z+b.max.z)/2;
        wrap.position.y=-b.min.y;
        wrap.position.x=-cxW;
        wrap.position.z=-czW;
        // Shadow sized from visible-only bounds
        const vb=realBounds(car,true);
        carShadowW=Math.min((vb.max.x-vb.min.x)*1.05,6);carShadowD=Math.min((vb.max.z-vb.min.z)*1.05,3);
        // Restore car position/rotation
        car.position.copy(savedPos);car.rotation.y=savedRot;
        const wh=[];m.traverse(c=>{if(c.isMesh){const n=c.name.toLowerCase();if(n.includes('wheel')||n.includes('tire')||n.includes('rim'))wh.push(c);}});
        car.userData.wheels=wh;
        enterCarMode();
        showToast("Now driving: "+cm.name);
    },undefined,()=>{
        car.add(fb.group);car.userData.wheels=fb.wheels;
        enterCarMode();
    });
}
function enterCarMode(){
    if(state.gunEquipped)holsterGun();
    state.mode="driving";
    avatar.visible=false;
    state.speed=0;
    state.canInteract=null;
    promptEl.classList.remove("show");
    _mouseDragging=false;
    updateModeBadge();
}

/* ====== PARTICLES ====== */
const LEAF_N=PERF.leafCount;const leafPos=new Float32Array(LEAF_N*3),leafSizes=new Float32Array(LEAF_N);
for(let i=0;i<LEAF_N;i++){leafPos[i*3]=(Math.random()-.5)*160;leafPos[i*3+1]=3+Math.random()*25;leafPos[i*3+2]=(Math.random()-.5)*160;leafSizes[i]=1.5+Math.random()*2.5;}
const leafGeo=new THREE.BufferGeometry();leafGeo.setAttribute("position",new THREE.BufferAttribute(leafPos,3));leafGeo.setAttribute("aSize",new THREE.BufferAttribute(leafSizes,1));
const leafMat=new THREE.ShaderMaterial({uniforms:{fogColor:{value:scene.fog.color},fogNear:{value:70},fogFar:{value:240}},vertexShader:`attribute float aSize;varying float vAlpha,vFD;void main(){vAlpha=.5+.3*sin(position.x+position.z);vec4 mv=modelViewMatrix*vec4(position,1.);vFD=-mv.z;gl_PointSize=aSize*(200./max(-mv.z,1.));gl_Position=projectionMatrix*mv;}`,fragmentShader:`uniform vec3 fogColor;uniform float fogNear,fogFar;varying float vAlpha,vFD;void main(){float d=length(gl_PointCoord-.5);if(d>.45)discard;float ff=smoothstep(fogNear,fogFar,vFD);vec3 col=mix(vec3(.85,.6,.28),fogColor,ff);gl_FragColor=vec4(col,vAlpha*(1.-d*2.2));}`,transparent:true,depthWrite:false});
scene.add(new THREE.Points(leafGeo,leafMat));

// ‚îÄ‚îÄ Underwater bubble particles ‚îÄ‚îÄ
const BUBBLE_N=40;
const bubbleGeo=new THREE.SphereGeometry(.06,6,6);
const bubbleMat=new THREE.MeshBasicMaterial({color:"#80d0f0",transparent:true,opacity:.4});
const bubbles=[];
for(let i=0;i<BUBBLE_N;i++){
    const b=new THREE.Mesh(bubbleGeo,bubbleMat.clone());
    b.visible=false;b.userData.vy=0;b.userData.life=0;b.userData.maxLife=0;
    b.scale.setScalar(.5+Math.random()*.8);
    scene.add(b);bubbles.push(b);
}
let _bubbleTimer=0;

// ‚îÄ‚îÄ Underwater fish ‚îÄ‚îÄ
const fishGroup=new THREE.Group();fishGroup.visible=false;scene.add(fishGroup);
const FISH_COLORS=["#ff8844","#44aaff","#ffcc22","#88dd55","#dd66aa","#55ddcc","#ff6666","#aabb44"];
const fishArr=[];
for(let i=0;i<25;i++){
    const fg=new THREE.Group();
    const col=FISH_COLORS[i%FISH_COLORS.length];
    // Body
    fg.add((()=>{const m=new THREE.Mesh(new THREE.SphereGeometry(.3,6,4),new THREE.MeshStandardMaterial({color:col,roughness:.4}));m.scale.set(1.8,1,.7);return m;})());
    // Tail
    fg.add((()=>{const m=new THREE.Mesh(new THREE.ConeGeometry(.2,.5,4),new THREE.MeshStandardMaterial({color:col,roughness:.4}));m.rotation.z=Math.PI/2;m.position.x=.5;return m;})());
    // Eye
    fg.add((()=>{const m=new THREE.Mesh(new THREE.SphereGeometry(.06,4,4),new THREE.MeshBasicMaterial({color:"#111"}));m.position.set(-.35,.08,.15);return m;})());
    fg.add((()=>{const m=new THREE.Mesh(new THREE.SphereGeometry(.06,4,4),new THREE.MeshBasicMaterial({color:"#111"}));m.position.set(-.35,.08,-.15);return m;})());
    // Randomize size
    const sc=.4+Math.random()*.8;fg.scale.setScalar(sc);
    // Random position in ocean area
    fg.position.set((Math.random()-.5)*100,-1.5-Math.random()*6,-65-Math.random()*50);
    fg.userData.speed=.8+Math.random()*1.5;
    fg.userData.phase=Math.random()*Math.PI*2;
    fg.userData.baseY=fg.position.y;
    fg.userData.circleR=5+Math.random()*15;
    fg.userData.centerX=fg.position.x;
    fg.userData.centerZ=fg.position.z;
    fishGroup.add(fg);fishArr.push(fg);
}
// Seaweed clusters
for(let i=0;i<15;i++){
    const sw=new THREE.Group();
    const stems=3+Math.floor(Math.random()*4);
    for(let s=0;s<stems;s++){
        const h=1+Math.random()*2;
        const m=new THREE.Mesh(new THREE.CylinderGeometry(.03,.06,h,4),new THREE.MeshStandardMaterial({color:"#2a6a30",roughness:.6}));
        m.position.set((Math.random()-.5)*.5,h/2,(Math.random()-.5)*.5);
        m.rotation.x=(Math.random()-.5)*.3;m.rotation.z=(Math.random()-.5)*.3;
        sw.add(m);
    }
    sw.position.set((Math.random()-.5)*80,terrainHeight((Math.random()-.5)*80,-70-Math.random()*30),-70-Math.random()*30);
    fishGroup.add(sw);
}
// Diver headlamp ‚Äî follows diver position in the animation loop
const diveLight=new THREE.PointLight("#88ccff",6,30);
diveLight.visible=false;scene.add(diveLight);
// Underwater ambient ‚Äî makes fish/hull visible
const diveAmbient=new THREE.PointLight("#4488aa",3,60);
diveAmbient.position.set(5,-3,-80);diveAmbient.visible=false;scene.add(diveAmbient);

/* ====== AUDIO ====== */
class AudioEngine{constructor(){this.ctx=null;this.master=null;this.initialized=false;this.muted=false;}
init(){if(this.initialized)return;try{this.ctx=new(window.AudioContext||window.webkitAudioContext)();this.master=this.ctx.createGain();this.master.gain.value=.2;this.master.connect(this.ctx.destination);this.lo=this.ctx.createOscillator();this.hi=this.ctx.createOscillator();this.lo.type="sawtooth";this.hi.type="triangle";this.lg=this.ctx.createGain();this.hg=this.ctx.createGain();this.lg.gain.value=0;this.hg.gain.value=0;this.lo.connect(this.lg).connect(this.master);this.hi.connect(this.hg).connect(this.master);this.lo.start();this.hi.start();const buf=this.ctx.createBuffer(1,this.ctx.sampleRate*2,this.ctx.sampleRate),d=buf.getChannelData(0);for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;this.wind=this.ctx.createBufferSource();this.wind.buffer=buf;this.wind.loop=true;const bp=this.ctx.createBiquadFilter();bp.type="bandpass";bp.frequency.value=500;this.wg=this.ctx.createGain();this.wg.gain.value=.01;this.wind.connect(bp).connect(this.wg).connect(this.master);this.wind.start();this.initialized=true;}catch(e){}}
update(spd,thr){if(!this.initialized||this.muted)return;const n=this.ctx.currentTime,r=.2+Math.min(Math.abs(spd)/30,1);this.lo.frequency.setTargetAtTime(65+r*110,n,.03);this.hi.frequency.setTargetAtTime(120+r*240,n,.03);this.lg.gain.setTargetAtTime(.02+r*.06+thr*.02,n,.04);this.hg.gain.setTargetAtTime(.006+r*.035,n,.04);this.wg.gain.setTargetAtTime(.007+r*.02,n,.1);}
chime(f=880,d=.12){if(!this.initialized||this.muted)return;const o=this.ctx.createOscillator(),g=this.ctx.createGain();o.type="sine";o.frequency.value=f;g.gain.value=0;o.connect(g).connect(this.master);const n=this.ctx.currentTime;g.gain.setValueAtTime(0,n);g.gain.linearRampToValueAtTime(.1,n+.015);g.gain.exponentialRampToValueAtTime(.0001,n+d);o.start(n);o.stop(n+d+.03);}
setMuted(v){this.muted=v;if(this.initialized)this.master.gain.value=v?0:.2;}}
const audio=new AudioEngine();
function toggleMute(){state.muted=!state.muted;audio.setMuted(state.muted);muteBtn.textContent=`Audio: ${state.muted?"OFF":"ON"}`;}
muteBtn.addEventListener("click",toggleMute);

/* ====== INPUT ====== */
const pressed=new Set();const KM={KeyW:"f",ArrowUp:"f",KeyS:"b",ArrowDown:"b",KeyA:"l",ArrowLeft:"l",KeyD:"r",ArrowRight:"r",ShiftLeft:"x",ShiftRight:"x",Space:"j"};
window.addEventListener("keydown",e=>{
    const k=KM[e.code];if(k){pressed.add(k);e.preventDefault();}
    if(!audio.initialized)audio.init();
    if(e.code==="KeyM")toggleMute();
    // F key: exit/enter car
    if(e.code==="KeyF"){
        if(state.mode==="driving"&&Math.abs(state.speed)<1){
            // Exit car ‚Üí walking mode
            state.mode="walking";
            state.carParkedAt=car.position.clone();
            state.canInteract=null;
            state.speed=0;
            unlock("walker");
            // Place avatar next to car (driver side offset)
            const heading=car.rotation.y;
            // Place avatar to the left side of the car (driver door)
            const sideAngle=heading+Math.PI/2;
            const ox=Math.sin(sideAngle)*2.5, oz=Math.cos(sideAngle)*2.5;
            avatar.position.set(car.position.x+ox,car.position.y,car.position.z+oz);
            // Avatar faces the same direction the car is facing
            state.avatarAngle=heading;
            avatar.rotation.y=heading;
            _camYaw=heading; // camera behind avatar (looking at avatar's back)
            _camPitch=1.0; // near-isometric top-down view
            zoomFactor=3; // full zoom out
            avatar.visible=true;
            audio.chime(600,.08);
            showToast(IS_MOBILE?"Tap CAR near your vehicle to get back in":"Press F near the car to get back in");
            updateModeBadge();
        }else if(state.mode==="walking"){
            // Check near car ‚Äî enter directly or open garage
            const _fPos=avatar.position;
            if(_fPos.distanceTo(car.position)<5){
                if(state.unlockedCars.length>1){openGarage();return;}
                enterCarMode();
                audio.chime(800,.08);
            }
        }
    }
    // G key: open garage from any mode (if 2+ cars unlocked)
    if(e.code==="KeyG"&&!garageOverlay.classList.contains("show")&&state.mode!=="dialog"){
        if(state.unlockedCars.length>1){openGarage();e.preventDefault();}
    }
    // E key: context-sensitive interaction
    if(e.code==="KeyE"){
        if(state.mode==="diving"){
            // Exit water ‚Äî check if near dock/ship surface
            if(state._nearExitWater){
                // Return to walking on dock
                state.mode="walking";
                state.swimming=false;state.underwater=false;state.swimVelY=0;state.diving=false;
                avatar.visible=true;
                if(window._avatarGun&&state.gunEquipped)window._avatarGun.visible=true;
                avatar.position.set(0,.3,-55); // Place on dock center
                state.jumpVelY=0;state.isJumping=false;
                diveLight.visible=false;diveAmbient.visible=false;
                camera.fov=NORMAL_FOV;camera.updateProjectionMatrix();
                _camPitch=.3; // Reset to walking pitch
                if(document.pointerLockElement)document.exitPointerLock();
                showToast("Back on solid ground!");
                audio.chime(400,.08);setTimeout(()=>audio.chime(500,.06),100);
                state.divePos=null;
            }
        }else if(state.mode==="driving"){
            openBB(); // existing billboard interaction
        }else if(state.mode==="walking"){
            // Check NPC proximity first, then billboard, then water entry
            const _ePos=avatar.position;
            if(_ePos.distanceTo(npcGuide.position)<4&&!state.wizardDead){
                showDialog(npcGuide);
            }else if(state.canInteract){
                openBB(); // open billboard on foot
            }else if(state._nearWaterEdge){
                // Enter diving mode!
                state.mode="diving";
                state.diving=true;state.swimming=true;state.underwater=true;
                state.divePos=new THREE.Vector3(avatar.position.x,WATER_LEVEL-.5,avatar.position.z-3);
                _camPitch=0; // Level pitch for diving
                state.swimVelY=0;
                if(state.gunEquipped)holsterGun();
                avatar.visible=false;
                if(window._avatarGun)window._avatarGun.visible=false;
                renderer.domElement.requestPointerLock();
                unlock("swimmer");unlock("diver");
                showToast("Diving! WASD swim ¬∑ Space up ¬∑ Shift down ¬∑ Mouse look ¬∑ E exit");
                audio.chime(180,.15);setTimeout(()=>audio.chime(120,.1),100);
            }
        }else if(state.mode==="dialog"){
            window._closeDialog();
        }
    }
    // 1 key: toggle gun
    if(e.code==="Digit1"){
        toggleGun();
    }
    // Escape: close dialogs / garage / holster gun
    if(e.code==="Escape"){
        if(state.gunEquipped){holsterGun();return;}
        if(state.mode==="dialog")window._closeDialog();
        if(garageOverlay.classList.contains("show")){window._garageClose();}
    }
    // F key also holsters gun first
    if(e.code==="KeyF"&&state.gunEquipped){holsterGun();return;}
},{passive:false});
window.addEventListener("keyup",e=>{const k=KM[e.code];if(k){pressed.delete(k);e.preventDefault();}},{passive:false});
window.addEventListener("pointerdown",()=>{if(!audio.initialized)audio.init();});
document.addEventListener("visibilitychange",()=>{if(document.hidden)pressed.clear();});

/* ====== MOBILE TOUCH CONTROLS ====== */
if(IS_MOBILE){
const _mobileCtrl=document.getElementById("mobile-controls");
if(_mobileCtrl)_mobileCtrl.style.display="block";

// ‚îÄ‚îÄ Virtual Joystick ‚îÄ‚îÄ
const _jZone=document.getElementById("joystick-zone");
const _jBase=document.getElementById("joystick-base");
const _jStick=document.getElementById("joystick-stick");
let _jTouchId=null;
const _jCenter={x:0,y:0};
const J_MAX=48,J_DEAD=10;

function _jUpdate(tx,ty){
    let dx=tx-_jCenter.x,dy=ty-_jCenter.y;
    const dist=Math.sqrt(dx*dx+dy*dy);
    if(dist>J_MAX){dx=dx/dist*J_MAX;dy=dy/dist*J_MAX;}
    _jStick.style.transform=`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    pressed.delete("f");pressed.delete("b");pressed.delete("l");pressed.delete("r");
    if(dy<-J_DEAD)pressed.add("f");
    if(dy>J_DEAD)pressed.add("b");
    if(dx<-J_DEAD)pressed.add("l");
    if(dx>J_DEAD)pressed.add("r");
}
_jZone.addEventListener("touchstart",e=>{
    e.preventDefault();if(_jTouchId!==null)return;
    const t=e.changedTouches[0];_jTouchId=t.identifier;
    const r=_jBase.getBoundingClientRect();
    _jCenter.x=r.left+r.width/2;_jCenter.y=r.top+r.height/2;
    _jUpdate(t.clientX,t.clientY);
    if(!audio.initialized)audio.init();
},{passive:false});
_jZone.addEventListener("touchmove",e=>{
    e.preventDefault();
    for(const t of e.changedTouches){if(t.identifier===_jTouchId)_jUpdate(t.clientX,t.clientY);}
},{passive:false});
function _jEnd(e){for(const t of e.changedTouches){if(t.identifier===_jTouchId){
    _jTouchId=null;_jStick.style.transform="translate(-50%,-50%)";
    pressed.delete("f");pressed.delete("b");pressed.delete("l");pressed.delete("r");
}}}
_jZone.addEventListener("touchend",_jEnd);
_jZone.addEventListener("touchcancel",_jEnd);

// ‚îÄ‚îÄ Camera Touch (right side of screen) ‚îÄ‚îÄ
const _camZone=document.getElementById("cam-touch-zone");
let _camTouchId=null,_camLastX=0,_camLastY=0;

_camZone.addEventListener("touchstart",e=>{
    if(_camTouchId!==null)return;
    const t=e.changedTouches[0];
    // Don't capture if touch is on a button
    const el=document.elementFromPoint(t.clientX,t.clientY);
    if(el&&(el.closest("#mobile-btns")||el.closest("#mobile-top")))return;
    _camTouchId=t.identifier;_camLastX=t.clientX;_camLastY=t.clientY;
    e.preventDefault();
    if(!audio.initialized)audio.init();
},{passive:false});
_camZone.addEventListener("touchmove",e=>{
    e.preventDefault();
    for(const t of e.changedTouches){
        if(t.identifier!==_camTouchId)continue;
        const dx=t.clientX-_camLastX,dy=t.clientY-_camLastY;
        _camYaw-=dx*.005;
        if(state.mode==="driving"){
            // Driving: no pitch changes needed, camera follows car
        }else{
            _camPitch=THREE.MathUtils.clamp(_camPitch-dy*.004,.05,1.2);
        }
        _camLastX=t.clientX;_camLastY=t.clientY;
    }
},{passive:false});
function _camEnd(e){for(const t of e.changedTouches){if(t.identifier===_camTouchId)_camTouchId=null;}}
_camZone.addEventListener("touchend",_camEnd);
_camZone.addEventListener("touchcancel",_camEnd);

// ‚îÄ‚îÄ Action Buttons ‚îÄ‚îÄ
const _btnJump=document.getElementById("btn-jump");
const _btnSprint=document.getElementById("btn-sprint");
const _btnAction=document.getElementById("btn-action");
const _btnCar=document.getElementById("btn-car");
const _btnGarage=document.getElementById("btn-mob-garage");
const _btnMute=document.getElementById("btn-mob-mute");

function _mobHold(btn,key){
    btn.addEventListener("touchstart",e=>{e.preventDefault();e.stopPropagation();pressed.add(key);btn.classList.add("pressed");if(!audio.initialized)audio.init();},{passive:false});
    btn.addEventListener("touchend",e=>{e.preventDefault();e.stopPropagation();pressed.delete(key);btn.classList.remove("pressed");},{passive:false});
    btn.addEventListener("touchcancel",e=>{pressed.delete(key);btn.classList.remove("pressed");});
}
_mobHold(_btnJump,"j");
_mobHold(_btnSprint,"x");

// E button ‚Äî context-sensitive interact (direct call, no synthetic events)
_btnAction.addEventListener("touchstart",e=>{
    e.preventDefault();e.stopPropagation();
    if(!audio.initialized)audio.init();
    if(state.mode==="driving"){openBB();}
    else if(state.mode==="walking"){
        const ap=avatar.position;
        if(ap.distanceTo(npcGuide.position)<4){showDialog(npcGuide);}
        else if(state.canInteract){openBB();}
    }else if(state.mode==="dialog"){window._closeDialog();}
},{passive:false});

// F button ‚Äî enter/exit car (direct call, no synthetic events)
_btnCar.addEventListener("touchstart",e=>{
    e.preventDefault();e.stopPropagation();
    if(!audio.initialized)audio.init();
    if(state.mode==="driving"&&Math.abs(state.speed)<1){
        // Exit car ‚Üí walking mode
        state.mode="walking";
        state.carParkedAt=car.position.clone();
        state.canInteract=null;state.speed=0;
        unlock("walker");
        const heading=car.rotation.y;
        const sideAngle=heading+Math.PI/2;
        const ox=Math.sin(sideAngle)*2.5,oz=Math.cos(sideAngle)*2.5;
        avatar.position.set(car.position.x+ox,car.position.y,car.position.z+oz);
        state.avatarAngle=heading;avatar.rotation.y=heading;
        _camYaw=heading;_camPitch=1.0;zoomFactor=3;
        avatar.visible=true;
        audio.chime(600,.08);
        showToast("Tap CAR near your vehicle to get back in");
        updateModeBadge();
    }else if(state.mode==="walking"){
        const _fPos=avatar.position;
        if(_fPos.distanceTo(car.position)<5){
            if(state.unlockedCars.length>1){openGarage();return;}
            enterCarMode();audio.chime(800,.08);
        }
    }
},{passive:false});

// Garage button
if(_btnGarage)_btnGarage.addEventListener("touchstart",e=>{
    e.preventDefault();e.stopPropagation();
    if(state.unlockedCars.length>1)openGarage();
},{passive:false});

// Mute button
if(_btnMute)_btnMute.addEventListener("touchstart",e=>{
    e.preventDefault();e.stopPropagation();
    toggleMute();
    _btnMute.textContent=state.muted?"üîá":"üîä";
},{passive:false});

// ‚îÄ‚îÄ Mobile UI Update (called from game loop, throttled to ~15fps for perf) ‚îÄ‚îÄ
let _mobUILast=0;
window._mobileUIUpdate=function(){
    if(!IS_MOBILE)return;
    const now=performance.now();if(now-_mobUILast<66)return;_mobUILast=now;
    // Contextual button visibility
    const showAction=state.canInteract||state.nearNPC||(state.mode==="dialog");
    _btnAction.classList.toggle("ctx-hidden",!showAction);
    // Action button label
    if(state.mode==="dialog"){_btnAction.textContent="OK";}
    else if(state.nearNPC){_btnAction.textContent="TALK";}
    else if(state.canInteract){_btnAction.textContent="OPEN";}

    // Car button
    const nearCar=state.mode==="walking"&&avatar.position.distanceTo(car.position)<5;
    const canExit=state.mode==="driving"&&Math.abs(state.speed)<1;
    _btnCar.classList.toggle("ctx-hidden",!nearCar&&!canExit);
    _btnCar.textContent=canExit?"EXIT":"CAR";

    // Jump label changes
    if(state.mode==="diving"){
        _btnJump.textContent="UP";
        _btnSprint.textContent="DOWN";
    }else{
        _btnJump.textContent="JUMP";
        _btnSprint.textContent="‚ö°";
    }
    // Show action button to enter/exit diving
    if(state._nearWaterEdge&&state.mode==="walking"){
        _btnAction.classList.remove("ctx-hidden");
        _btnAction.textContent="SWIM";
    }else if(state._nearExitWater&&state.mode==="diving"){
        _btnAction.classList.remove("ctx-hidden");
        _btnAction.textContent="EXIT";
    }

    // Garage button visibility
    if(_btnGarage)_btnGarage.style.display=state.unlockedCars.length>1?"flex":"none";
};

// ‚îÄ‚îÄ Pinch-to-zoom for camera distance ‚îÄ‚îÄ
let _pinchDist=0;
document.addEventListener("touchstart",e=>{
    if(e.touches.length===2){
        const dx=e.touches[0].clientX-e.touches[1].clientX;
        const dy=e.touches[0].clientY-e.touches[1].clientY;
        _pinchDist=Math.sqrt(dx*dx+dy*dy);
    }
},{passive:true});
document.addEventListener("touchmove",e=>{
    if(e.touches.length===2&&_pinchDist>0){
        const dx=e.touches[0].clientX-e.touches[1].clientX;
        const dy=e.touches[0].clientY-e.touches[1].clientY;
        const dist=Math.sqrt(dx*dx+dy*dy);
        const delta=_pinchDist-dist;
        zoomFactor=THREE.MathUtils.clamp(zoomFactor+delta*.005,.2,3);
        _pinchDist=dist;
    }
},{passive:true});
document.addEventListener("touchend",e=>{if(e.touches.length<2)_pinchDist=0;},{passive:true});

// ‚îÄ‚îÄ Prevent iOS rubber-band scrolling and double-tap zoom ‚îÄ‚îÄ
document.addEventListener("touchmove",e=>{if(e.target.closest("#app"))e.preventDefault();},{passive:false});
document.addEventListener("gesturestart",e=>e.preventDefault());
document.addEventListener("gesturechange",e=>e.preventDefault());

} // end IS_MOBILE block

/* ====== ZOOM (mouse wheel) ====== */
let zoomFactor=1; // 0.12 = bonnet cam, 1 = default, 3 = bird's eye
renderer.domElement.addEventListener("wheel",e=>{zoomFactor+=e.deltaY*.0008;zoomFactor=THREE.MathUtils.clamp(zoomFactor,.12,3);e.preventDefault();},{passive:false});

/* ====== MOUSE LOOK (walking mode ‚Äî LMB hold to orbit) ====== */
let _camYaw=0,_camPitch=.3; // radians ‚Äî yaw orbits around avatar, pitch is elevation
let _mouseDragging=false;
renderer.domElement.addEventListener("mousedown",e=>{
    if(state.gunEquipped&&document.pointerLockElement&&e.button===0){
        _shooting=true;shootGun();e.preventDefault();return;
    }
    // RMB = scope in
    if(state.gunEquipped&&document.pointerLockElement&&e.button===2){
        scopeGun();e.preventDefault();return;
    }
    if(state.mode==="walking"&&e.button===0&&!state.gunEquipped){_mouseDragging=true;e.preventDefault();}
});
window.addEventListener("mouseup",e=>{
    if(e.button===0){_mouseDragging=false;_shooting=false;}
    if(e.button===2&&_scoped){unscopeGun();}
});
// Prevent context menu when gun is out (RMB is scope)
renderer.domElement.addEventListener("contextmenu",e=>{
    if(state.gunEquipped)e.preventDefault();
});
window.addEventListener("mousemove",e=>{
    // FPS aiming with pointer lock ‚Äî full vertical range
    if(document.pointerLockElement&&state.gunEquipped){
        const sens=_scoped?.0006:.002;
        _camYaw-=e.movementX*sens;
        _camPitch=THREE.MathUtils.clamp(_camPitch+e.movementY*sens,-1.4,1.4);
        return;
    }
    // Diving: pointer lock mouse look with full vertical range
    if(document.pointerLockElement&&state.mode==="diving"){
        _camYaw-=e.movementX*.002;
        _camPitch=THREE.MathUtils.clamp(_camPitch+e.movementY*.002,-1.3,1.3);
        return;
    }
    if(!_mouseDragging||state.mode!=="walking")return;
    _camYaw-=e.movementX*.004;
    _camPitch=THREE.MathUtils.clamp(_camPitch-e.movementY*.003,.05,1.2);
});

/* ====== INTERACTION ====== */
const raycaster=new THREE.Raycaster(),pointer=new THREE.Vector2();
function openBB(){if(!state.canInteract)return;window.open(state.canInteract.u,"_blank","noopener");state.visited.add(state.canInteract.t);visitedEl.textContent=`${state.visited.size} / ${ALL_PROJECTS.length}`;unlock("first");
const portAll=DISTRICTS.maritime.projects.every(p=>state.visited.has(p.t));if(portAll)unlock("port");
const simAll=DISTRICTS.simulations.projects.every(p=>state.visited.has(p.t));if(simAll)unlock("science");
if(state.visited.size===ALL_PROJECTS.length)unlock("all");audio.chime(960,.12);updateQuestTracker();}
renderer.domElement.addEventListener("pointerdown",e=>{const rc=renderer.domElement.getBoundingClientRect();pointer.x=((e.clientX-rc.left)/rc.width)*2-1;pointer.y=-((e.clientY-rc.top)/rc.height)*2+1;raycaster.setFromCamera(pointer,camera);const hit=raycaster.intersectObjects(interactables,false)[0];if(!hit)return;const p=hit.object.userData.project;if(!p||!state.canInteract||state.canInteract.t!==p.t)return;openBB();});

/* ====== SEASONS ====== */
const SP=[
    {sky:"#78b8e6",fog:"#a8d4ec",sun:"#fff0c8",hS:"#b4d8f0",hG:"#5a8040",gA:"#3d8a2e",gB:"#80c848",gBase:"#3d8a2e",gTip:"#a8d44e"},
    {sky:"#68a8e0",fog:"#90c4e4",sun:"#ffe8a0",hS:"#a0d0f0",hG:"#4a7a34",gA:"#308020",gB:"#6ab838",gBase:"#2e7a22",gTip:"#8cc040"},
    {sky:"#90a4c8",fog:"#b0b8cc",sun:"#ffd090",hS:"#c8d0e0",hG:"#7a6040",gA:"#8a7040",gB:"#b09040",gBase:"#7a6030",gTip:"#c0a048"},
    {sky:"#c0cce0",fog:"#d0d8e4",sun:"#fff4d4",hS:"#e0e8f4",hG:"#708090",gA:"#a0aab8",gB:"#c4ccd8",gBase:"#90a0a8",gTip:"#c0d0d4"},
];
function applyTerrain(p){const gA=new THREE.Color(p.gA),gB=new THREE.Color(p.gB),sand=new THREE.Color("#c8b888"),dirt=new THREE.Color("#8a7858");
for(let i=0;i<tPos.count;i++){const x=tPos.getX(i),z=tPos.getZ(i),y=tPos.getY(i);const bl=Math.min(Math.max((y+4)/12,0),1);
const c=gA.clone().lerp(gB,bl);if(z<-35)c.lerp(sand,Math.min(1,Math.max(0,(-z-35)/25))*.5);
const rd=roadDist(x,z);if(rd>0&&rd<4)c.lerp(dirt,(1-rd/4)*.35);const nv=vn(x*.3,z*.3);c.r*=.92+nv*.16;c.g*=.92+nv*.16;c.b*=.92+nv*.16;
tColors[i*3]=c.r;tColors[i*3+1]=c.g;tColors[i*3+2]=c.b;}tGeo.setAttribute("color",new THREE.BufferAttribute(tColors,3));tGeo.attributes.color.needsUpdate=true;}
function applySeason(){const p=SP[state.seasonIndex];scene.background.set(p.sky);scene.fog.color.set(p.fog);sun.color.set(p.sun);sunSphere.material.color.set(p.sun);hemi.color.set(p.hS);hemi.groundColor.set(p.hG);applyTerrain(p);grassMat.uniforms.uBase.value.set(p.gBase);grassMat.uniforms.uTip.value.set(p.gTip);}
applySeason();visitedEl.textContent=`0 / ${ALL_PROJECTS.length}`;

/* ====== LOAD LOCAL GLB MODELS ====== */
const glbLoader=new GLTFLoader();
// Helper: extract named child from GLTF scene
function extractChild(root,name){let found=null;root.traverse(c=>{if(!found&&c.name===name)found=c;});return found;}
// Helper: place a model at world position, auto-grounded, scaled to target height
function placeGLB(model,x,z,targetH,rotY){
    const m=model.clone();const b=realBounds(m);
    const curH=b.max.y-b.min.y;const sc=curH>0?targetH/curH:1;
    m.scale.multiplyScalar(sc);
    m.position.set(x,Math.max(terrainHeight(x,z),ROAD_Y),z);
    // Ground: recompute bounds after scaling and shift so bottom touches position.y
    const b2=realBounds(m);m.position.y-=(b2.min.y-m.position.y);
    if(rotY!==undefined)m.rotation.y=rotY;
    scene.add(m);return m;}
function placeGLBDestroy(model,x,z,targetH,rotY,hp,type){
    const m=placeGLB(model,x,z,targetH,rotY);addStatic(m,.2);registerDestroyable(m,hp||80,type||"building");return m;}

// ---- BUILDINGS PACK ----
if(PERF.extraGltf)glbLoader.load('models/buidlings/low_poly_public_buildings_pack.glb',gltf=>{
    const root=gltf.scene;root.updateMatrixWorld(true);
    const bldgs={};
    ['Pharmacy','Police','CityHall','Hospital','GasStation','School','Light','Bin'].forEach(n=>{
        const c=extractChild(root,'PublicBuilding_'+n);if(c)bldgs[n]=c;});
    // Town Center ‚Äî CityHall + Police
    if(bldgs.CityHall)placeGLBDestroy(bldgs.CityHall,-18,-18,12,0,80);
    if(bldgs.Police)placeGLBDestroy(bldgs.Police,18,-18,10,Math.PI,80);
    // Science Park ‚Äî Hospital
    if(bldgs.Hospital){placeGLBDestroy(bldgs.Hospital,64,22,11,Math.PI/2,80);placeGLBDestroy(bldgs.Hospital,70,-20,9,-Math.PI/2,80);}
    // Tech Hub ‚Äî GasStation
    if(bldgs.GasStation){placeGLBDestroy(bldgs.GasStation,-66,20,7,0,60);placeGLBDestroy(bldgs.GasStation,-74,-16,7,Math.PI,60);}
    // Creative Village ‚Äî School + Pharmacy
    if(bldgs.School)placeGLBDestroy(bldgs.School,-50,68,9,0,80);
    if(bldgs.Pharmacy){placeGLBDestroy(bldgs.Pharmacy,50,68,8,Math.PI,60);placeGLBDestroy(bldgs.Pharmacy,-18,18,8,Math.PI/2,60);}
    // Port ‚Äî extra buildings
    if(bldgs.CityHall)placeGLBDestroy(bldgs.CityHall,18,18,10,Math.PI,80);
    // Street Lights ‚Äî lined along road EDGES, never in the middle of roads
    // Road bands: N-S x=-8..8, E-W z=-8..8, Port z=-46..-34, Creative z=44..56,
    //   Connectors x=-42..-34 & x=34..42, Science x=45..55, Tech x=-55..-45
    if(bldgs.Light){
        const _lights=[
         // Town center corners (outside all road bands, 4+ units from edge)
         [14,14],[-14,14],[14,-14],[-14,-14],
         // Along N-S road edges (x=¬±12, 4 units from road edge, safe z away from E-W)
         [12,-20],[-12,-20],[12,-28],[-12,-28],[12,20],[-12,20],[12,28],[-12,28],
         // Along E-W road edges (z=¬±12, 4 units from road edge, safe x away from N-S)
         [22,12],[-22,12],[22,-12],[-22,-12],[30,12],[-30,12],[30,-12],[-30,-12],
         // Port district road edges (z=-32 or z=-48, x clear of N-S & connectors)
         [20,-32],[-20,-32],[48,-32],[-48,-32],[20,-48],[-20,-48],
         // Creative district road edges (z=42 or z=58, x clear of N-S & connectors)
         [20,42],[-20,42],[20,58],[-20,58],[46,58],[-46,58],
         // Science park (x=58 or x=42, z clear of E-W road ‚Äî note: connector is x=34..42)
         [58,14],[58,-14],[44,26],[44,-26],
         // Tech hub (x=-58 or x=-44, z clear of E-W road ‚Äî note: connector is x=-42..-34)
         [-58,14],[-58,-14],[-44,26],[-44,-26],
        ];
        // On mobile only place every 3rd light to reduce draw calls
        const _lightArr=IS_MOBILE?_lights.filter((_,i)=>i%3===0):_lights;
        _lightArr.forEach(([lx,lz])=>{const m=placeGLB(bldgs.Light,lx,lz,4.5,Math.random()*Math.PI*2);registerDestroyable(m,15,"prop");});}
    // Bins near benches/intersections ‚Äî all clear of roads
    if(bldgs.Bin){
        [[12,12],[-12,12],[12,-12],[-12,-12],[20,20],[-20,-20],
         [22,-33],[-22,-33],[22,43],[-22,43],[56,20],[-56,20]
        ].forEach(([bx,bz])=>{const m=placeGLB(bldgs.Bin,bx,bz,1.2,Math.random()*Math.PI*2);registerDestroyable(m,8,"prop");});}
    console.log('Buildings pack loaded:',Object.keys(bldgs).join(', '));
},undefined,e=>console.warn('Buildings GLB failed:',e));

// ---- CARS PACK ‚Äî NPC vehicles for city life ----
const npcCars=[];
if(PERF.traffic)glbLoader.load('models/cars/low_poly_cars_pack.glb',gltf=>{
    const root=gltf.scene;root.updateMatrixWorld(true);
    const vehicles=[];
    for(let i=1;i<=7;i++){const c=extractChild(root,'Transport'+i);if(c){
        // Fix materials: hide colliders, solid body, tinted windows
        c.traverse(ch=>{
            if(!ch.isMesh)return;
            // Hide invisible collider meshes
            if(ch.name.toLowerCase().includes('collider')){ch.visible=false;return;}
            const mats=Array.isArray(ch.material)?ch.material:[ch.material];
            mats.forEach(mt=>{
                mt.depthWrite=true;
                if(ch.name.includes('transparent')){
                    // Windows ‚Äî semi-transparent tinted glass
                    mt.transparent=true;mt.opacity=0.35;mt.side=THREE.FrontSide;
                }else{
                    // Body ‚Äî fully opaque, front-face only (hides interior)
                    mt.transparent=false;mt.opacity=1;mt.side=THREE.FrontSide;
                }});});
        vehicles.push(c);}}
    if(!vehicles.length)return;
    // Model orientation offset: test common rotations
    // Low-poly packs vary ‚Äî PI/2 means model's +X becomes forward (-Z)
    const MODEL_ROT=Math.PI/2;
    // Helper: place car with correct orientation + fixed materials
    function placeCar(model,x,z,facingAngle){
        const v=placeGLB(model,x,z,1.4,facingAngle+MODEL_ROT);
        return v;}
    // Parked cars along roads ‚Äî facing matches road direction
    // N-S roads: facing 0 (north, -Z) or PI (south, +Z)
    // E-W roads: facing PI/2 (east, -X) or -PI/2 (west, +X)
    const parkSpots=[
        // N-S main road ‚Äî parked at road edges (x=¬±7), not in travel lanes
        [7,-22,0],[7,-14,0],[7,20,0],[7,30,0],[7,40,0],
        [-7,-18,Math.PI],[-7,-10,Math.PI],[-7,24,Math.PI],[-7,34,Math.PI],
        // E-W main road ‚Äî edges (z=¬±7)
        [22,7,Math.PI/2],[32,7,Math.PI/2],[-22,-7,-Math.PI/2],[-32,-7,-Math.PI/2],
        // Port road edges (z=-35 or z=-45)
        [18,-35,Math.PI/2],[30,-35,Math.PI/2],[-18,-45,-Math.PI/2],[-30,-45,-Math.PI/2],
        // Creative road edges (z=45 or z=55)
        [18,45,Math.PI/2],[30,45,Math.PI/2],[-18,55,-Math.PI/2],[-30,55,-Math.PI/2],
        // Science entry edges (x=46)
        [46,14,0],[46,-14,Math.PI],
        // Tech entry edges (x=-46)
        [-46,14,0],[-46,-14,Math.PI],
    ];
    parkSpots.forEach(([px,pz,pr],i)=>{
        const v=placeCar(vehicles[i%vehicles.length],px,pz,pr);
        // Physics-enabled: velocity, angular velocity, crash timer
        v.userData._vel=new THREE.Vector3();v.userData._angVel=0;v.userData._crashed=0;
        registerDestroyable(v,30,"car");
        npcCars.push(v);});
    // Driving cars follow actual road waypoint routes
    const routes=[
        // Route 0: N-S main road loop (drive north on right, south on left)
        {pts:[[4,-55],[4,65],[-4,65],[-4,-55]],speed:6},
        // Route 1: E-W main road loop
        {pts:[[-75,4],[75,4],[75,-4],[-75,-4]],speed:7},
        // Route 2: Port road loop
        {pts:[[-50,-38],[50,-38],[50,-42],[-50,-42]],speed:5},
        // Route 3: Creative road loop
        {pts:[[-45,48],[45,48],[45,52],[-45,52]],speed:5},
    ];
    const driveCars=[];
    routes.forEach((route,ri)=>{
        const v=placeCar(vehicles[(ri+3)%vehicles.length],route.pts[0][0],route.pts[0][1],0);
        v.userData.route=route;v.userData.wpIdx=0;
        v.userData.wpT=Math.random(); // start at random point along first segment
        // Physics-enabled
        v.userData._vel=new THREE.Vector3();v.userData._angVel=0;v.userData._crashed=0;
        registerDestroyable(v,30,"car");
        driveCars.push(v);npcCars.push(v);});
    // NPC tick: waypoint-following + crash physics
    window._npcTick=function(t,dt){
        driveCars.forEach(c=>{
            // Skip destroyed cars
            if(!c.visible)return;
            // If crashed, apply physics instead of route-following
            if(c.userData._crashed>0){
                c.userData._crashed-=dt;
                // Apply crash velocity
                const v=c.userData._vel;
                if(v.lengthSq()>.01){
                    c.position.addScaledVector(v,dt);
                    v.y-=15*dt; // gravity
                    const gy=Math.max(terrainHeight(c.position.x,c.position.z),ROAD_Y);
                    if(c.position.y<gy){c.position.y=gy;v.y=Math.abs(v.y)*.2;v.x*=.88;v.z*=.88;}
                    v.multiplyScalar(.94);
                    c.rotation.y+=c.userData._angVel*dt;
                    c.userData._angVel*=.94;
                }
                // Once crash timer expires, snap back onto nearest route point
                if(c.userData._crashed<=0){
                    c.userData._vel.set(0,0,0);c.userData._angVel=0;
                    // Find nearest waypoint to resume
                    const r=c.userData.route,pts=r.pts;
                    let bestD=Infinity,bestI=0;
                    pts.forEach(([px,pz],i)=>{const d=Math.hypot(c.position.x-px,c.position.z-pz);if(d<bestD){bestD=d;bestI=i;}});
                    c.userData.wpIdx=bestI;c.userData.wpT=0;
                }
                return;
            }
            const r=c.userData.route,pts=r.pts;
            c.userData.wpT+=dt*r.speed*.02;
            if(c.userData.wpT>=1){c.userData.wpT-=1;c.userData.wpIdx=(c.userData.wpIdx+1)%pts.length;}
            const i0=c.userData.wpIdx,i1=(i0+1)%pts.length;
            const t2=c.userData.wpT;
            const x=pts[i0][0]+(pts[i1][0]-pts[i0][0])*t2;
            const z=pts[i0][1]+(pts[i1][1]-pts[i0][1])*t2;
            const dx=pts[i1][0]-pts[i0][0],dz=pts[i1][1]-pts[i0][1];
            const facing=Math.atan2(-dx,-dz); // face direction of travel
            const gy=Math.max(terrainHeight(x,z),ROAD_Y);
            c.position.set(x,gy,z);
            c.rotation.y=facing+MODEL_ROT;
        });};
    console.log(`Cars pack: ${vehicles.length} types, ${parkSpots.length} parked, ${driveCars.length} driving`);
},undefined,e=>console.warn('Cars GLB failed:',e));

// ---- TREES ‚Äî realistic collection ----
if(PERF.extraGltf)glbLoader.load('models/trees/realistic_trees_collection.glb',gltf=>{
    const root=gltf.scene;root.updateMatrixWorld(true);
    // Extract individual tree types
    const treeTypes=[];
    const treeNames=['Tree EZTree0.Large','Tree EZTree0.Medium010','Tree EZTree0.Medium011',
        'Tree EZTree1.Bush006','Tree EZTree1.Large001','Tree EZTree1.Large009','Tree EZTree1.Medium002'];
    treeNames.forEach(n=>{const c=extractChild(root,n);if(c)treeTypes.push(c);});
    if(!treeTypes.length){console.warn('No trees found in pack');return;}
    // Scatter realistic trees ‚Äî replace some procedural ones
    let placed=0;const maxTrees=52;
    while(placed<maxTrees){
        const x=(Math.random()-.5)*300,z=(Math.random()-.5)*280;
        if(roadDist(x,z)<5||z<-50)continue;
        const y=terrainHeight(x,z);if(y<-.3)continue;
        const tIdx=Math.floor(Math.random()*treeTypes.length);
        const isBush=treeTypes[tIdx].name.includes('Bush');
        const targetH=isBush?1.5+Math.random()*2:5+Math.random()*6;
        const tm=placeGLB(treeTypes[tIdx],x,z,targetH,Math.random()*Math.PI*2);registerDestroyable(tm,isBush?10:25,"tree");
        placed++;}
    // Line trees along road edges for avenues ‚Äî skip any spot ON a crossing road
    for(let z2=-55;z2<70;z2+=12){
        if(Math.abs(z2)<10)continue; // skip main intersection
        if(roadDist(10,z2)>=1){const m=placeGLB(treeTypes[0%treeTypes.length],10,z2,7+Math.random()*3,Math.random()*6);registerDestroyable(m,25,"tree");}
        if(roadDist(-10,z2)>=1){const m=placeGLB(treeTypes[1%treeTypes.length],-10,z2,7+Math.random()*3,Math.random()*6);registerDestroyable(m,25,"tree");}}
    for(let x2=-55;x2<55;x2+=12){
        if(Math.abs(x2)<10)continue;
        if(roadDist(x2,10)>=1){const m=placeGLB(treeTypes[2%treeTypes.length],x2,10,6+Math.random()*3,Math.random()*6);registerDestroyable(m,25,"tree");}
        if(roadDist(x2,-10)>=1){const m=placeGLB(treeTypes[3%treeTypes.length],x2,-10,6+Math.random()*3,Math.random()*6);registerDestroyable(m,25,"tree");}}
    console.log(`Trees: ${treeTypes.length} types, ${placed} scattered + avenue trees`);
},undefined,e=>console.warn('Trees GLB failed:',e));

/* ====== GAME LOOP ====== */
const clock=new THREE.Clock();
setTimeout(()=>{const ld=document.getElementById("loading");ld.style.opacity="0";setTimeout(()=>{ld.remove();if(IS_MOBILE)showToast("Use joystick to drive ¬∑ Swipe right side to look around");},800);},800);
const CAR_R=1.0;const NPC_R=1.4;const AVATAR_R=0.4;
let _camShake=0;
const frameBudget=PERF.fpsCap>0?1/PERF.fpsCap:0;
let frameAccum=0;

function tick(){
    requestAnimationFrame(tick);
    try{
    const rawDt=clock.getDelta(),t=clock.getElapsedTime();
    if(frameBudget>0){frameAccum+=rawDt;if(frameAccum<frameBudget)return;}
    const dt=Math.min(frameBudget>0?frameAccum:rawDt,.033);
    if(frameBudget>0)frameAccum=0;
    const wF=pressed.has("f"),wB=pressed.has("b"),wL=pressed.has("l"),wR=pressed.has("r"),bst=pressed.has("x");

    // Dead state ‚Äî freeze and tick only combat visuals
    if(state.isDead){
        tickDebris(dt);tickFireball(dt);
        if(_muzzleLight.intensity>0)_muzzleLight.intensity=Math.max(0,_muzzleLight.intensity-dt*40);
        if(composer)composer.render();else renderer.render(scene,camera);
        return;
    }

    // ====== MODE: DRIVING ======
    if(state.mode==="driving"){
    const accel=bst?34:24,brake=38,revRate=14,drag=7,mxF=bst?45:32,mxR=-14;
    if(wF){if(state.speed<0){state.speed+=brake*dt;if(state.speed>0)state.speed=0;}else state.speed+=accel*dt;}
    if(wB){if(state.speed>.5){state.speed-=brake*dt;if(state.speed<0)state.speed=0;}else state.speed-=revRate*dt;}
    if(!wF&&!wB){if(Math.abs(state.speed)<.2)state.speed=0;else state.speed-=Math.sign(state.speed)*drag*dt;}
    state.speed=Math.max(mxR,Math.min(mxF,state.speed));
    if(Math.abs(state.speed)>.8)unlock("ignite");state.maxSpeed=Math.max(state.maxSpeed,Math.abs(state.speed));if(state.maxSpeed*4.2>120)unlock("speed");if(state.maxSpeed*4.2>180)unlock("speed2");
    // Distance tracking (speed is in units/s, *4.2 for km/h ‚Üí /1000 for km)
    state.totalDistance+=Math.abs(state.speed)*dt*4.2/1000;if(state.totalDistance>=10)unlock("distance");
    const si=(wL?1:0)-(wR?1:0);
    if(Math.abs(state.speed)>.3){const sn2=Math.min(Math.abs(state.speed)/mxF,1);const steer=si*(2+sn2*2.5)*dt;car.rotation.y+=steer*(state.speed<0?-.6:1);state.speed*=1-Math.min(Math.abs(steer)*2.2,.12);
        // Drift detection: steering hard at decent speed
        if(Math.abs(steer)>.03&&Math.abs(state.speed)>5){state.driftTime+=dt;if(state.driftTime>=3)unlock("drift");}else{state.driftTime=Math.max(0,state.driftTime-dt*2);}
    }else{state.driftTime=0;}
    const dir=new THREE.Vector3(-Math.sin(car.rotation.y),0,-Math.cos(car.rotation.y));
    car.position.addScaledVector(dir,state.speed*dt);
    car.position.x=THREE.MathUtils.clamp(car.position.x,-160,160);car.position.z=THREE.MathUtils.clamp(car.position.z,-68,160);
    const cp=car.position;
    // STATIC COLLISIONS
    for(const box of staticCol){
        const nx2=Math.max(box.min.x,Math.min(cp.x,box.max.x)),nz2=Math.max(box.min.z,Math.min(cp.z,box.max.z));
        const dx=cp.x-nx2,dz=cp.z-nz2,dist=Math.sqrt(dx*dx+dz*dz);
        if(dist<CAR_R&&dist>.01){const push=(CAR_R-dist)/dist;cp.x+=dx*push;cp.z+=dz*push;state.speed*=.5;}
        else if(dist<.01&&cp.x>=box.min.x&&cp.x<=box.max.x&&cp.z>=box.min.z&&cp.z<=box.max.z){
            const pushX=Math.min(cp.x-box.min.x,box.max.x-cp.x),pushZ=Math.min(cp.z-box.min.z,box.max.z-cp.z);
            if(pushX<pushZ)cp.x+=(cp.x-box.min.x<box.max.x-cp.x)?-pushX-CAR_R:pushX+CAR_R;
            else cp.z+=(cp.z-box.min.z<box.max.z-cp.z)?-pushZ-CAR_R:pushZ+CAR_R;
            state.speed*=.4;
        }
    }
    // DYNAMIC COLLISIONS
    for(const d of dynCol){const dp=d.mesh.position;const dx=dp.x-cp.x,dz=dp.z-cp.z;const dist=Math.sqrt(dx*dx+dz*dz);
        if(dist<CAR_R+.8&&Math.abs(state.speed)>.5){const imp=new THREE.Vector3(dx,.5,dz).normalize().multiplyScalar(Math.max(Math.abs(state.speed)*1.5,3));
        d.vel.add(imp);state.speed*=.92;state.crashes++;if(state.crashes>=10)unlock("crash");if(state.crashes>=50)unlock("crash50");audio.chime(200,.08);}}
    for(const d of dynCol){if(d.vel.lengthSq()<.01)continue;d.mesh.position.addScaledVector(d.vel,dt);d.mesh.rotation.x+=d.vel.z*dt*2;d.mesh.rotation.z-=d.vel.x*dt*2;d.vel.y-=15*dt;d.vel.multiplyScalar(.96);
    const gy2=terrainHeight(d.mesh.position.x,d.mesh.position.z);if(d.mesh.position.y<gy2+.3){d.mesh.position.y=gy2+.3;d.vel.y=Math.abs(d.vel.y)*.3;d.vel.x*=.85;d.vel.z*=.85;}}
    // NPC CAR COLLISIONS
    const absSpd=Math.abs(state.speed);
    for(const npc of npcCars){
        const np=npc.position;
        const dx=cp.x-np.x,dz=cp.z-np.z;
        const dist=Math.sqrt(dx*dx+dz*dz);
        const minDist=CAR_R+NPC_R;
        if(dist>=minDist||dist<.01)continue;
        const nx3=dx/dist,nz3=dz/dist;
        const overlap=minDist-dist;
        cp.x+=nx3*overlap*.6;cp.z+=nz3*overlap*.6;
        np.x-=nx3*overlap*.4;np.z-=nz3*overlap*.4;
        const playerVn=state.speed*(dir.x*nx3+dir.z*nz3);
        let npcVn=0;
        if(npc.userData.route&&npc.userData._crashed<=0){
            const r=npc.userData.route,pts=r.pts;
            const i0=npc.userData.wpIdx,i1=(i0+1)%pts.length;
            const rdx=pts[i1][0]-pts[i0][0],rdz=pts[i1][1]-pts[i0][1];
            const rLen=Math.hypot(rdx,rdz);
            if(rLen>.01){npcVn=r.speed*((-rdx/rLen)*nx3+(-rdz/rLen)*nz3);}
        }
        const e2=0.55;
        const relVn=playerVn-npcVn;
        if(relVn>0)continue;
        const impulse=-(1+e2)*relVn*0.5;
        const impactForce=Math.abs(impulse);
        state.speed+=impulse*(dir.x*nx3+dir.z*nz3)*.8;
        state.speed=THREE.MathUtils.clamp(state.speed,-mxF*.6,mxF*.6);
        const npcImpulse=Math.max(impactForce*1.2,absSpd*.4);
        npc.userData._vel.x-=nx3*npcImpulse*.7;
        npc.userData._vel.z-=nz3*npcImpulse*.7;
        npc.userData._vel.y=Math.min(npcImpulse*.08,2);
        npc.userData._angVel=(Math.random()-.5)*npcImpulse*.5;
        npc.userData._crashed=Math.max(npc.userData._crashed,1.5+impactForce*.15);
        _camShake=Math.max(_camShake,Math.min(impactForce*.25,2.0));
        state.crashes++;if(state.crashes>=10)unlock("crash");if(state.crashes>=50)unlock("crash50");
        audio.chime(80+impactForce*5,Math.min(impactForce*.04,.3));
    }
    // NPC car sliding physics
    for(const npc of npcCars){
        const v=npc.userData._vel;
        if(!v||v.lengthSq()<.005)continue;
        if(npc.userData.route&&npc.userData._crashed<=0)continue;
        npc.position.addScaledVector(v,dt);
        v.y-=15*dt;
        const gy2=Math.max(terrainHeight(npc.position.x,npc.position.z),ROAD_Y);
        if(npc.position.y<gy2){npc.position.y=gy2;v.y=Math.abs(v.y)*.15;v.x*=.88;v.z*=.88;}
        v.multiplyScalar(.94);
        if(npc.userData._angVel){npc.rotation.y+=npc.userData._angVel*dt;npc.userData._angVel*=.93;}
        if(v.lengthSq()<.005){v.set(0,0,0);npc.userData._angVel=0;}
    }
    // HOT LAP: Gate collision detection
    if(state.hotlapActive&&hotlapGates.length>0&&state.gatesHit<state.totalGates){
        const nextGate=hotlapGates[state.gatesHit];
        if(nextGate&&!nextGate.hit){
            const gd=cp.distanceTo(nextGate.pos);
            if(gd<5){
                nextGate.hit=true;
                state.gatesHit++;
                audio.chime(880,.1);setTimeout(()=>audio.chime(1100,.08),100);
                showToast(`Gate ${state.gatesHit} / ${state.totalGates}`);
                updateGateVisuals();
                updateQuestTracker();
                // Animate gate disappear
                nextGate.group.visible=false;
            }
        }
    }
    // Ground following ‚Äî dock acts as solid surface for cars too
    let gy=terrainHeight(cp.x,cp.z);
    const carOnDock=cp.z<-44.5&&cp.z>-65.5&&cp.x>-60&&cp.x<60;
    if(carOnDock) gy=Math.max(gy,0.2);
    else if(roadDist(cp.x,cp.z)<=0) gy=Math.max(gy,ROAD_Y);
    cp.y=THREE.MathUtils.lerp(cp.y,gy,.6);
    carShadow.position.set(cp.x,gy+.03,cp.z);
    carShadow.scale.set(carShadowW,carShadowD,1);
    const rv=new THREE.Vector3(dir.z,0,-dir.x);
    const hF=terrainHeight(cp.x+dir.x*1.6,cp.z+dir.z*1.6),hB=terrainHeight(cp.x-dir.x*1.6,cp.z-dir.z*1.6);
    const hL=terrainHeight(cp.x-rv.x*.9,cp.z-rv.z*.9),hR=terrainHeight(cp.x+rv.x*.9,cp.z+rv.z*.9);
    car.rotation.x=THREE.MathUtils.lerp(car.rotation.x,-Math.atan2(hF-hB,3.2),.2);
    car.rotation.z=THREE.MathUtils.lerp(car.rotation.z,Math.atan2(hR-hL,1.8),.2);
    car.userData.wheels.forEach((w,i)=>{w.rotation.x-=state.speed*dt*2;if(i<2)w.rotation.y=((wL?1:0)-(wR?1:0))*.22;});
    speedEl.textContent=`${Math.round(Math.abs(state.speed)*4.2)} km/h`;
    districtEl.textContent=getDistrict(cp.x,cp.z);
    audio.update(state.speed,wF?1:0);
    orbs.forEach(o=>{if(!o.visible)return;o.rotation.y+=.025;o.position.y+=Math.sin(t*3+o.position.x)*.004;if(cp.distanceTo(o.position)<2.2){o.visible=false;state.collectibles.add(o.userData.id);audio.chime(1100,.09);if(state.collectibles.size>=Math.ceil(orbs.length/2))unlock("orbhalf");if(state.collectibles.size===orbs.length)unlock("collector");}});
    // Billboard proximity ‚Äî park in bay
    let nearBB=null,nearD=Infinity;billboards.forEach(b=>{const d2=cp.distanceTo(b.bayPos);if(d2<nearD){nearD=d2;nearBB=b;}});
    const parked=nearD<4&&Math.abs(state.speed)<.4&&nearBB;
    if(parked){
        state.canInteract=nearBB.project;const di=DISTRICTS[nearBB.project.district];
        promptEl.innerHTML=`<strong>${nearBB.project.t}</strong><span class="dt ${di.dtClass}">${di.label}</span><br><span style="font-size:.7rem;color:var(--s)">${IS_MOBILE?"Tap OPEN to view project":"F to exit car ¬∑ E to open project"}</span>`;
        promptEl.classList.add("show");renderer.domElement.style.cursor="pointer";
    }else{state.canInteract=null;promptEl.classList.remove("show");renderer.domElement.style.cursor="default";}
    updateArcade(t,dt,parked,nearBB);
    // Driving camera
    const sn=Math.min(Math.abs(state.speed)/32,1);
    if(zoomFactor<.25){
        const fwd=dir.clone().multiplyScalar(.8);const up=new THREE.Vector3(0,1.8+(.25-zoomFactor)*4,0);
        const driverPos=cp.clone().add(fwd).add(up);
        camera.position.lerp(driverPos,1-Math.exp(-dt*8));
        const lookFwd=cp.clone().add(dir.clone().multiplyScalar(20)).add(new THREE.Vector3(0,1.5,0));
        camera.lookAt(lookFwd.x,lookFwd.y,lookFwd.z);
    }else{
        const baseDist=(14+sn*4)*zoomFactor,baseH=(7+sn*2)*zoomFactor;
        const dc=cp.clone().add(new THREE.Vector3(-dir.x*baseDist,baseH,-dir.z*baseDist));
        camera.position.lerp(dc,1-Math.exp(-dt*4.5));camera.lookAt(cp.x,cp.y+1.2,cp.z);
    }
    } // end driving mode

    // ====== MODE: WALKING ======
    else if(state.mode==="walking"){
    const WALK_SPEED=bst?8:5;
    // Always use the normal avatar ‚Äî gun is attached separately
    const activeAvatar=avatar;
    const ap=avatar.position;
    // Camera yaw defines the "forward" direction for movement
    const fwdX=-Math.sin(_camYaw),fwdZ=-Math.cos(_camYaw);
    const rightX=fwdZ,rightZ=-fwdX; // perpendicular (strafe)
    // W/S = forward/backward along camera yaw, A/D = strafe left/right
    const moveDir=new THREE.Vector3();
    if(wF){moveDir.x+=fwdX;moveDir.z+=fwdZ;}
    if(wB){moveDir.x-=fwdX;moveDir.z-=fwdZ;}
    if(wL){moveDir.x+=rightX;moveDir.z+=rightZ;} // strafe left
    if(wR){moveDir.x-=rightX;moveDir.z-=rightZ;} // strafe right
    const moving=moveDir.lengthSq()>0.01;
    if(moving){
        moveDir.normalize();
        ap.addScaledVector(moveDir,WALK_SPEED*dt);
        if(state.gunEquipped){
            // In gun mode: avatar faces camera direction
            state.avatarAngle=_camYaw;
            activeAvatar.rotation.y=_camYaw;
        }else{
            // Target angle: avatar always faces direction of travel
            const targetAngle=Math.atan2(-moveDir.x,-moveDir.z);
            let diff=targetAngle-state.avatarAngle;
            while(diff>Math.PI)diff-=Math.PI*2;
            while(diff<-Math.PI)diff+=Math.PI*2;
            state.avatarAngle+=diff*Math.min(dt*12,1);
            activeAvatar.rotation.y=state.avatarAngle;
        }
    }else if(state.gunEquipped){
        state.avatarAngle=_camYaw;
        activeAvatar.rotation.y=_camYaw;
    }
    // Clamp world bounds ‚Äî walking stops at dock edge (can't walk into water)
    ap.x=THREE.MathUtils.clamp(ap.x,-160,160);ap.z=THREE.MathUtils.clamp(ap.z,-65,160);

    // ‚îÄ‚îÄ Constants ‚îÄ‚îÄ
    const DOCK_TOP=0.2;
    const GRAVITY=18;
    const JUMP_VEL=7.5;
    const groundH=terrainHeight(ap.x,ap.z);
    const wantJump=pressed.has("j");

    // ‚îÄ‚îÄ Surface detection ‚îÄ‚îÄ
    // Dock mesh spans x=-60..60, z=-65..-45, top surface at y=0.2
    const onDock=ap.z<-44.5&&ap.z>-65.5&&ap.x>-60&&ap.x<60;
    let onShipDeck=false, shipDeckY=1.5;
    if(window._shipGroup&&window._shipGroup.visible){
        const sp=window._shipGroup.position;
        const dx2=ap.x-sp.x,dz2=ap.z-sp.z;
        const cosR=Math.cos(-window._shipGroup.rotation.y),sinR=Math.sin(-window._shipGroup.rotation.y);
        const lx=dx2*cosR-dz2*sinR,lz=dx2*sinR+dz2*cosR;
        shipDeckY=window._shipDeckY||1.5;
        // Ship ~55 long, ~9 wide (scaled up); detect when above deck height
        if(Math.abs(lx)<28&&Math.abs(lz)<6&&ap.y>shipDeckY-2){
            onShipDeck=true;
            if(!state.onShip){state.onShip=true;unlock("aboard");showToast("You've boarded the frigate!");}
        }else{state.onShip=false;}
    }

    // ‚îÄ‚îÄ Gangplank detection ‚îÄ‚îÄ
    let onGangplank=false, gangplankY=0;
    if(window._gangplank){
        const gp=window._gangplank;
        if(Math.abs(ap.x-gp.x)<gp.w&&ap.z<gp.z1&&ap.z>gp.z2){
            const t2=(gp.z1-ap.z)/(gp.z1-gp.z2); // 0=dock end, 1=ship end
            gangplankY=gp.y1+(gp.y2-gp.y1)*t2;
            onGangplank=true;
        }
    }
    // Determine solid ground Y under feet
    const onRoad=roadDist(ap.x,ap.z)<=0;
    let solidY;
    if(onShipDeck) solidY=shipDeckY;
    else if(onGangplank) solidY=gangplankY;
    else if(onDock) solidY=DOCK_TOP;
    else if(onRoad) solidY=ROAD_Y;
    else solidY=groundH;

    // ‚îÄ‚îÄ Water edge detection (for prompt, NOT auto-enter) ‚îÄ‚îÄ
    const nearWaterEdge=onDock&&ap.z<-62;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê LAND / DECK (player never auto-falls into water) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    {
        const onGround=ap.y<=solidY+.05&&state.jumpVelY<=0;
        if(onGround){
            ap.y=THREE.MathUtils.lerp(ap.y,solidY,.45);
            state.isJumping=false;state.jumpVelY=0;
            if(wantJump){state.jumpVelY=JUMP_VEL;state.isJumping=true;audio.chime(500,.06);}
        }else{
            state.jumpVelY-=GRAVITY*dt;ap.y+=state.jumpVelY*dt;
            if(ap.y<=solidY){ap.y=solidY;state.jumpVelY=0;state.isJumping=false;}
        }
        // Clamp: never sink below dock surface when on dock
        if(onDock&&ap.y<DOCK_TOP)ap.y=DOCK_TOP;
    }

    // Static collision for avatar
    for(const box of staticCol){
        if(box.max.y<ap.y+0.3)continue;
        const nx2=Math.max(box.min.x,Math.min(ap.x,box.max.x)),nz2=Math.max(box.min.z,Math.min(ap.z,box.max.z));
        const dx3=ap.x-nx2,dz3=ap.z-nz2,dist3=Math.sqrt(dx3*dx3+dz3*dz3);
        if(dist3<AVATAR_R&&dist3>.01){const push=(AVATAR_R-dist3)/dist3;ap.x+=dx3*push;ap.z+=dz3*push;}
    }
    // ‚îÄ‚îÄ Avatar animation (land only ‚Äî no swimming animation needed, diving is FPS) ‚îÄ‚îÄ
    {
        const ud=avatar.userData;
        activeAvatar.rotation.x=0; // always upright
        if(ud._fallback&&ud.lArm){ud.lArm.rotation.z=0;ud.rArm.rotation.z=0;}
        if(ud.mixer){
                ud.mixer.update(dt);
                if(ud.walkAction){
                    if(moving){
                        if(ud.walkAction.paused){ud.walkAction.paused=false;}
                        if(!ud.walkAction.isRunning()){
                            if(ud.idleAction)ud.idleAction.fadeOut(.2);
                            ud.walkAction.reset().fadeIn(.2).play();
                        }
                    }else{
                        if(ud.idleAction&&ud.walkAction.isRunning()){
                            ud.walkAction.fadeOut(.2);
                            ud.idleAction.reset().fadeIn(.2).play();
                        }else if(!ud.idleAction){
                            ud.walkAction.paused=true;
                        }
                    }
                }
            }else if(ud._fallback){
                if(moving){
                    ud.walkTime=(ud.walkTime||0)+dt*8;
                    const sw=Math.sin(ud.walkTime)*.4;
                    if(ud.lLeg){ud.lLeg.rotation.x=sw;ud.rLeg.rotation.x=-sw;}
                    // Arm swing while walking
                    if(ud.lArm){ud.lArm.rotation.x=-sw*.5;ud.rArm.rotation.x=sw*.5;}
                }else{
                    ud.walkTime=0;
                    if(ud.lLeg){ud.lLeg.rotation.x=0;ud.rLeg.rotation.x=0;}
                }
            }

            // Walking bob (disabled)

        }
    // Proximity checks ‚Äî NPC, billboards, car
    state._nearWaterEdge=false;
    const npcDist=ap.distanceTo(npcGuide.position);
    // Check billboards on foot ‚Äî use billboard board position (not bay)
    let _walkBB=null,_walkBBd=Infinity;
    billboards.forEach(b=>{const d2=ap.distanceTo(b.group.position);if(d2<_walkBBd){_walkBBd=d2;_walkBB=b;}});
    const nearBBOnFoot=_walkBBd<5&&_walkBB;
    if(npcDist<4&&!state.wizardDead){
        promptEl.innerHTML=`<strong>${npcGuide.userData.name}</strong> ‚Äî ${IS_MOBILE?"Tap <b>TALK</b>":"Press <b>E</b> to talk"}`;
        promptEl.classList.add("show");
        state.nearNPC=true;
        state.canInteract=null;
    }else if(nearBBOnFoot){
        state.nearNPC=false;
        state.canInteract=_walkBB.project;
        const di=DISTRICTS[_walkBB.project.district];
        promptEl.innerHTML=`<strong>${_walkBB.project.t}</strong><span class="dt ${di.dtClass}">${di.label}</span><br><span style="font-size:.7rem;color:var(--s)">${IS_MOBILE?"Tap OPEN to view":"E to open project"}</span>`;
        promptEl.classList.add("show");
        renderer.domElement.style.cursor="pointer";
    }else{
        state.nearNPC=false;
        state.canInteract=null;
        // Ship proximity
        const shipNear=window._shipGroup&&window._shipGroup.visible&&ap.distanceTo(window._shipGroup.position)<35;
        if(state.onShip){
            promptEl.innerHTML=`<b>On Ship</b> ‚Äî Walk around the deck`;
            promptEl.classList.add("show");
            renderer.domElement.style.cursor="default";
        }else if(nearWaterEdge){
            promptEl.innerHTML=`<b>Dock Edge</b> ‚Äî Press <b>E</b> to put on diving gear and enter the water`;
            promptEl.classList.add("show");
            renderer.domElement.style.cursor="pointer";
            state._nearWaterEdge=true;
        }else if(shipNear&&!state.onShip){
            promptEl.innerHTML=`<b>Frigate</b> ‚Äî Walk to the dock edge and jump the railing to board`;
            promptEl.classList.add("show");
            renderer.domElement.style.cursor="default";
        }else if(ap.distanceTo(car.position)<5){
            promptEl.innerHTML=IS_MOBILE?`Tap <b>CAR</b> to enter`:`Press <b>F</b> to enter car`;
            promptEl.classList.add("show");
            renderer.domElement.style.cursor="pointer";
        }else{
            promptEl.classList.remove("show");
            renderer.domElement.style.cursor="default";
        }
    }
    // Activate arcade glow frame around billboard when on foot
    updateArcade(t,dt,nearBBOnFoot,_walkBB);
    districtEl.textContent=getDistrict(ap.x,ap.z);
    speedEl.textContent=state.onShip?"On Ship":"On Foot";
    audio.update(0,0);
    // Walking camera
    if(state.gunEquipped){
        // TRUE FPS Over-The-Shoulder camera
        const cosPitch=Math.cos(_camPitch);
        const aimX=-Math.sin(_camYaw)*cosPitch;
        const aimY=-Math.sin(_camPitch);
        const aimZ=-Math.cos(_camYaw)*cosPitch;
        const aimRightX=Math.cos(_camYaw),aimRightZ=-Math.sin(_camYaw);

        // Scope zoom: smoothly interpolate FOV
        const targetFOV=_scoped?SCOPE_FOV:NORMAL_FOV;
        if(Math.abs(camera.fov-targetFOV)>.1){
            camera.fov=THREE.MathUtils.lerp(camera.fov,targetFOV,1-Math.exp(-dt*12));
            camera.updateProjectionMatrix();
        }

        // Camera position ‚Äî tighter when scoped (closer to head, centered)
        const shoulderBack=_scoped?1.2:3.0;
        const shoulderRight=_scoped?0.15:1.0;
        const shoulderH=_scoped?1.7:1.9;
        const camPos=new THREE.Vector3(
            ap.x-aimX*shoulderBack+aimRightX*shoulderRight,
            ap.y+shoulderH+aimY*(_scoped?0.2:0.5),
            ap.z-aimZ*shoulderBack+aimRightZ*shoulderRight
        );
        camera.position.lerp(camPos,1-Math.exp(-dt*(_scoped?18:14)));
        // Camera looks where the crosshair/reticle points
        const lookTarget=new THREE.Vector3(
            camera.position.x+aimX*50,
            camera.position.y+aimY*50,
            camera.position.z+aimZ*50
        );
        camera.lookAt(lookTarget);

        // Position gun at avatar's right hand, raised and pointing at crosshair
        if(!_scoped){
            const gunOffRight=0.5,gunOffForward=0.35,gunOffUp=1.2;
            gunPivot.position.set(
                ap.x+aimRightX*gunOffRight-Math.sin(_camYaw)*gunOffForward,
                ap.y+gunOffUp,
                ap.z+aimRightZ*gunOffRight-Math.cos(_camYaw)*gunOffForward
            );
            gunPivot.rotation.set(0,_camYaw,0);
            gunGroup.rotation.set(-_camPitch,0,0);
        }

        // Auto-fire when holding LMB
        if(_shooting){shootGun();}
    }else{
        // Normal walking camera ‚Äî orbits around avatar based on mouse yaw/pitch
        const camDist=6*zoomFactor;
        const camOX=Math.sin(_camYaw)*Math.cos(_camPitch)*camDist;
        const camOZ=Math.cos(_camYaw)*Math.cos(_camPitch)*camDist;
        const camOY=Math.sin(_camPitch)*camDist+1.2;
        const targetCam=new THREE.Vector3(ap.x+camOX,ap.y+camOY,ap.z+camOZ);
        camera.position.lerp(targetCam,1-Math.exp(-dt*8));
        camera.lookAt(ap.x,ap.y+1.2,ap.z);
    }
    } // end walking mode

    // ====== MODE: DIVING (FPS underwater) ======
    else if(state.mode==="diving"){
    const DIVE_SPEED=5;
    const dp=state.divePos;
    if(!dp){state.mode="walking";avatar.visible=true;}
    else{
    // Wider FOV for diving immersion
    const diveFOV=65;
    if(Math.abs(camera.fov-diveFOV)>.1){camera.fov=THREE.MathUtils.lerp(camera.fov,diveFOV,1-Math.exp(-dt*6));camera.updateProjectionMatrix();}

    // ‚îÄ‚îÄ Mouse look: yaw/pitch directly from shared _camYaw/_camPitch ‚îÄ‚îÄ
    // _camPitch is clamped in the mouse handler; for diving we allow full vertical
    const dYaw=_camYaw;
    const dPitch=THREE.MathUtils.clamp(_camPitch,-1.3,1.3);

    // ‚îÄ‚îÄ Forward/right vectors from look direction (horizontal plane only for WASD) ‚îÄ‚îÄ
    const fwdX=-Math.sin(dYaw), fwdZ=-Math.cos(dYaw);
    const rtX=Math.cos(dYaw), rtZ=-Math.sin(dYaw);

    // ‚îÄ‚îÄ Build movement vector ‚îÄ‚îÄ
    // WASD = horizontal movement in the direction the camera faces (same as walking)
    const mv=new THREE.Vector3();
    if(wF){mv.x+=fwdX; mv.z+=fwdZ;}  // W = forward
    if(wB){mv.x-=fwdX; mv.z-=fwdZ;}  // S = backward
    if(wL){mv.x+=rtX;  mv.z+=rtZ;}   // A = strafe left
    if(wR){mv.x-=rtX;  mv.z-=rtZ;}   // D = strafe right
    if(pressed.has("j")){mv.y+=1;}    // Space = go UP (surface)
    if(bst){mv.y-=1;}                 // Shift = go DOWN (dive deeper)
    if(mv.lengthSq()>.001)mv.normalize();
    dp.addScaledVector(mv,DIVE_SPEED*dt);

    // Clamp to ocean area
    dp.x=THREE.MathUtils.clamp(dp.x,-120,120);
    dp.z=THREE.MathUtils.clamp(dp.z,-130,-46);
    const seabedHere=terrainHeight(dp.x,dp.z)+0.3;
    dp.y=THREE.MathUtils.clamp(dp.y,seabedHere,WATER_LEVEL-.15);

    // ‚îÄ‚îÄ FPS camera: position at diver, look in mouse direction ‚îÄ‚îÄ
    camera.position.lerp(dp.clone(),1-Math.exp(-dt*14));
    const lookDir=new THREE.Vector3(
        -Math.sin(dYaw)*Math.cos(dPitch),
        -Math.sin(dPitch),
        -Math.cos(dYaw)*Math.cos(dPitch)
    );
    const lookTarget=dp.clone().add(lookDir.multiplyScalar(10));
    camera.lookAt(lookTarget);

    // Headlamp follows diver
    diveLight.position.copy(dp);diveLight.visible=true;
    diveAmbient.visible=true;
    // Avatar hidden during diving
    avatar.visible=false;
    if(window._avatarGun)window._avatarGun.visible=false;
    fishGroup.visible=true;
    state.underwater=true;state.swimming=true;
    // Achievements
    unlock("swimmer");unlock("diver");
    if(window._shipGroup&&window._shipGroup.visible){
        const sdx=dp.x-window._shipGroup.position.x,sdz=dp.z-window._shipGroup.position.z;
        if(Math.sqrt(sdx*sdx+sdz*sdz)<32)unlock("hull_inspect");
    }
    // Exit detection ‚Äî near dock edge or near ship
    const nearDockReturn=dp.z>-48&&dp.y>WATER_LEVEL-1;
    const nearShipSurface=window._shipGroup&&window._shipGroup.visible&&dp.distanceTo(window._shipGroup.position)<20&&dp.y>WATER_LEVEL-1.5;
    state._nearExitWater=nearDockReturn||nearShipSurface;
    if(state._nearExitWater){
        promptEl.innerHTML=`Press <b>E</b> to exit the water`;
        promptEl.classList.add("show");
    }else{
        promptEl.innerHTML=`<b>Diving</b> ‚Äî WASD swim ¬∑ Space up ¬∑ Shift down ¬∑ Mouse look ¬∑ E exit near dock/ship`;
        promptEl.classList.add("show");
    }
    districtEl.textContent="Ocean";
    speedEl.textContent="Diving";
    } // end else(dp exists)
    } // end diving mode

    // ====== MODE: DIALOG ======
    // (No movement, camera stays put)

    // ====== SHARED: always runs ======
    // Dive mask overlay & fog
    const _diveMask=document.getElementById("dive-mask");
    if(_diveMask)_diveMask.style.opacity=state.mode==="diving"?"1":"0";
    // Fish visibility
    fishGroup.visible=state.mode==="diving";
    const _isDiving=state.mode==="diving";
    if(_isDiving){scene.fog.near=5;scene.fog.far=35;scene.fog.color.lerp(new THREE.Color("#1a4a60"),.1);scene.background.lerp(new THREE.Color("#0a2838"),.1);}
    else{
        scene.fog.near=THREE.MathUtils.lerp(scene.fog.near,IS_MOBILE?30:70,.03);
        scene.fog.far=THREE.MathUtils.lerp(scene.fog.far,IS_MOBILE?120:240,.03);
        scene.fog.color.lerp(new THREE.Color("#a8d4ec"),.05);
        scene.background.lerp(new THREE.Color("#78b8e6"),.05);
    }
    // Animate fish
    if(_isDiving){
        for(const f of fishArr){
            f.userData.phase+=dt*f.userData.speed*.4;
            const r=f.userData.circleR;
            f.position.x=f.userData.centerX+Math.cos(f.userData.phase)*r;
            f.position.z=f.userData.centerZ+Math.sin(f.userData.phase)*r;
            f.position.y=f.userData.baseY+Math.sin(f.userData.phase*1.5)*.5;
            // Face direction of movement
            const ang=f.userData.phase+Math.PI/2;
            f.rotation.y=ang;
            // Tail wag
            if(f.children[1])f.children[1].rotation.z=Math.PI/2+Math.sin(t*8+f.userData.phase)*.3;
        }
    }
    // Bubbles ‚Äî spawn when diving
    _bubbleTimer+=dt;
    if(_isDiving&&_bubbleTimer>.08){
        _bubbleTimer=0;
        const free=bubbles.find(b=>!b.visible);
        if(free){
            const ap2=state.divePos||avatar.position;
            free.position.set(ap2.x+(Math.random()-.5)*.8,ap2.y+(Math.random()-.5)*.4,ap2.z+(Math.random()-.5)*.8);
            free.userData.vy=1+Math.random()*1.5;free.userData.life=0;free.userData.maxLife=1.5+Math.random()*2;
            free.material.opacity=.35+Math.random()*.2;
            free.scale.setScalar(.3+Math.random()*.5);
            free.visible=true;
        }
    }
    for(const b of bubbles){
        if(!b.visible)continue;
        b.userData.life+=dt;
        if(b.userData.life>b.userData.maxLife||b.position.y>WATER_LEVEL+.1){b.visible=false;continue;}
        b.position.y+=b.userData.vy*dt;
        b.position.x+=Math.sin(t*3+b.position.z*10)*.003;
        b.position.z+=Math.cos(t*2+b.position.x*10)*.003;
        b.material.opacity*=.995; // fade out
    }
    if(!state.swimming){bubbles.forEach(b=>{if(b.visible){b.userData.life+=dt*3;if(b.userData.life>b.userData.maxLife)b.visible=false;}});}
    // Play time & district tracking
    state.playTime+=dt;
    if(state.playTime>=300)unlock("night"); // 5 minutes
    const _cpForDist=state.mode==="driving"?car.position:avatar.position;
    const _curDist=getDistrict(_cpForDist.x,_cpForDist.z);
    state.visitedDistricts.add(_curDist);
    if(state.visitedDistricts.size>=5)unlock("districts");
    // Mountaineer: check if on high terrain
    const _pTH=terrainHeight(_cpForDist.x,_cpForDist.z);
    if(_pTH>5)unlock("mountain");
    // Car collection check
    if(state.unlockedCars.length>=Object.keys(CAR_MODELS||{}).length&&state.unlockedCars.length>=2)unlock("all_cars");
    // Combat systems tick
    if(_shootCooldown>0)_shootCooldown-=dt;
    if(_tracerTimer>0){_tracerTimer-=dt;if(_tracerTimer<=0)_tracerLine.visible=false;}
    if(_muzzleLight.intensity>0)_muzzleLight.intensity=Math.max(0,_muzzleLight.intensity-dt*40);
    tickDebris(dt);
    tickFireball(dt);
    // Gate pulse animation
    if(state.hotlapActive&&hotlapGates.length>0){
        const nextIdx=state.gatesHit;
        if(nextIdx<hotlapGates.length){
            const g=hotlapGates[nextIdx];
            if(g&&!g.hit&&g.group.visible){
                g.torus.material.opacity=0.6+Math.sin(t*4)*0.3;
                g.torus.rotation.x=Math.sin(t*2)*.1;
            }
        }
    }
    // Quest objective tracking
    const activeQ=QUESTS.find(q=>q.status==="active");
    if(activeQ&&activeQ.objective()&&activeQ.status==="active"){
        activeQ.status="complete";
        updateNPCIcon();updateQuestTracker();
        // Big celebration fanfare when objectives complete ‚Äî clearly tells player what to do
        showObjectiveCompleteFanfare(activeQ);
    }
    // NPC wander AI ‚Äî patrol waypoints, idle pauses, face player when near
    const npcD=npcGuide.userData;
    if(state.wizardDead){/* wizard is dead ‚Äî skip all AI */}
    else{
    if(npcD.mixer)npcD.mixer.update(dt);
    // Determine player position for proximity
    const _playerPos=state.mode==="walking"?avatar.position:car.position;
    const _wizPlayerDist=npcGuide.position.distanceTo(_playerPos);
    const _wizNearPlayer=_wizPlayerDist<6&&state.mode==="walking";
    if(state.mode==="dialog"||_wizNearPlayer){
        // Freeze wizard: dialog or player is nearby ‚Äî face the player
        npcGuide.position.y=npcD.baseY+Math.sin(t*1.5)*.06;
        if(_wizNearPlayer||state.mode==="dialog"){
            const toPlayer=Math.atan2(_playerPos.x-npcGuide.position.x,-(_playerPos.z-npcGuide.position.z));
            npcGuide.rotation.y=toPlayer;
        }
        // Switch to idle if was walking
        if(!npcD.isIdle&&npcD.walkAction&&npcD.idleAction){
            npcD.idleAction.setEffectiveWeight(1);
            npcD.walkAction.setEffectiveWeight(0);
        }
    }else{
        if(npcD.isIdle){
            // Idle pause ‚Äî gentle bob
            npcGuide.position.y=npcD.baseY+Math.sin(t*1.5)*.06;
            npcD.idleTimer-=dt;
            if(npcD.idleTimer<=0){
                // Pick next waypoint
                npcD.wpIdx=(npcD.wpIdx+1)%_wizWaypoints.length;
                npcD.isIdle=false;
                // Cross-fade to walk animation
                if(npcD.walkAction&&npcD.idleAction){
                    npcD.walkAction.setEffectiveWeight(1);npcD.walkAction.time=0;
                    npcD.idleAction.setEffectiveWeight(0);
                }
            }
        }else{
            // Walking toward waypoint
            const wp=_wizWaypoints[npcD.wpIdx];
            const dx=wp[0]-npcGuide.position.x, dz=wp[1]-npcGuide.position.z;
            const dist=Math.sqrt(dx*dx+dz*dz);
            if(dist<2){
                // Arrived ‚Äî start idle pause
                npcD.isIdle=true;
                npcD.idleTimer=3+Math.random()*5;
                npcD.baseY=Math.max(terrainHeight(npcGuide.position.x,npcGuide.position.z),ROAD_Y);
                npcGuide.position.y=npcD.baseY;
                npcD.stuckTimer=0;
                if(npcD.walkAction&&npcD.idleAction){
                    npcD.idleAction.setEffectiveWeight(1);
                    npcD.walkAction.setEffectiveWeight(0);
                }
            }else{
                let nx=dx/dist, nz=dz/dist;
                const spd=npcD.wanderSpeed*dt;
                const _wizPx=npcGuide.position.x, _wizPz=npcGuide.position.z;
                // ‚îÄ‚îÄ 1) Proactive building avoidance (highest priority) ‚îÄ‚îÄ
                // Fixed look-ahead distance (not frame-rate dependent)
                let _bldgSteer=0; // track if building avoidance is active
                const _LA=4.0; // look-ahead units
                const _avoidR=NPC_R+1.2;
                for(const box of staticCol){
                    const cx=(box.min.x+box.max.x)*.5, cz=(box.min.z+box.max.z)*.5;
                    const hw=(box.max.x-box.min.x)*.5+_LA+NPC_R, hd=(box.max.z-box.min.z)*.5+_LA+NPC_R;
                    if(Math.abs(_wizPx-cx)>hw||Math.abs(_wizPz-cz)>hd)continue;
                    // Check TWO look-ahead distances: near and far
                    for(const la of[_LA*0.5,_LA]){
                        const futX=_wizPx+nx*la, futZ=_wizPz+nz*la;
                        const clX=Math.max(box.min.x,Math.min(futX,box.max.x));
                        const clZ=Math.max(box.min.z,Math.min(futZ,box.max.z));
                        const aDx=futX-clX, aDz=futZ-clZ;
                        const aDist=Math.sqrt(aDx*aDx+aDz*aDz);
                        if(aDist<_avoidR&&aDist>0.01){
                            const str=Math.max(0,(_avoidR-aDist)/_avoidR)*2.0;
                            nx+=aDx/aDist*str; nz+=aDz/aDist*str;
                            _bldgSteer+=str;
                        }else if(aDist<0.01){
                            // Future pos inside box ‚Äî push along shortest exit
                            const pXL=futX-box.min.x, pXR=box.max.x-futX;
                            const pZN=futZ-box.min.z, pZF=box.max.z-futZ;
                            const minP=Math.min(pXL,pXR,pZN,pZF);
                            if(minP===pXL)nx-=2;else if(minP===pXR)nx+=2;
                            else if(minP===pZN)nz-=2;else nz+=2;
                            _bldgSteer+=2;
                        }
                    }
                    // Also check current position proximity (immediate danger)
                    const clNx=Math.max(box.min.x,Math.min(_wizPx,box.max.x));
                    const clNz=Math.max(box.min.z,Math.min(_wizPz,box.max.z));
                    const nDx=_wizPx-clNx, nDz=_wizPz-clNz;
                    const nDist=Math.sqrt(nDx*nDx+nDz*nDz);
                    if(nDist<NPC_R+0.5&&nDist>0.01){
                        const str=Math.max(0,(NPC_R+0.5-nDist)/(NPC_R+0.5))*3.0;
                        nx+=nDx/nDist*str; nz+=nDz/nDist*str;
                        _bldgSteer+=str;
                    }
                }
                // Normalize after building avoidance
                let _len=Math.sqrt(nx*nx+nz*nz);
                if(_len>0){nx/=_len;nz/=_len;}
                // ‚îÄ‚îÄ 2) Road avoidance (skip if building avoidance is strongly active to prevent oscillation) ‚îÄ‚îÄ
                if(_bldgSteer<0.5){
                    const nextX=_wizPx+nx*spd;
                    const nextZ=_wizPz+nz*spd;
                    if(roadDist(nextX,nextZ)<3){
                        const px=-nz, pz=nx;
                        if(roadDist(_wizPx+px*spd*3,_wizPz+pz*spd*3)>3){
                            nx=px;nz=pz;
                        }else{nx=-px;nz=-pz;}
                    }
                }
                // ‚îÄ‚îÄ 3) Car avoidance ‚îÄ‚îÄ
                const carDx=_wizPx-car.position.x;
                const carDz=_wizPz-car.position.z;
                const carD=Math.sqrt(carDx*carDx+carDz*carDz);
                if(carD<8&&carD>0.1){
                    const pushStr=Math.max(0,(8-carD)/8)*.6;
                    nx+=carDx/carD*pushStr; nz+=carDz/carD*pushStr;
                    _len=Math.sqrt(nx*nx+nz*nz);
                    if(_len>0){nx/=_len;nz/=_len;}
                }
                // ‚îÄ‚îÄ Apply movement ‚îÄ‚îÄ
                const prevX=npcGuide.position.x, prevZ=npcGuide.position.z;
                npcGuide.position.x+=nx*spd;
                npcGuide.position.z+=nz*spd;
                // ‚îÄ‚îÄ Reactive collision push-out (hard constraint, like avatar) ‚îÄ‚îÄ
                const wp2=npcGuide.position;
                for(const box of staticCol){
                    const cnx=Math.max(box.min.x,Math.min(wp2.x,box.max.x));
                    const cnz=Math.max(box.min.z,Math.min(wp2.z,box.max.z));
                    const cdx=wp2.x-cnx, cdz=wp2.z-cnz;
                    const cd=Math.sqrt(cdx*cdx+cdz*cdz);
                    if(cd<NPC_R&&cd>0.01){
                        const push=(NPC_R-cd)/cd;
                        wp2.x+=cdx*push; wp2.z+=cdz*push;
                    }else if(cd<0.01&&wp2.x>=box.min.x&&wp2.x<=box.max.x&&wp2.z>=box.min.z&&wp2.z<=box.max.z){
                        const pXL=wp2.x-box.min.x, pXR=box.max.x-wp2.x;
                        const pZN=wp2.z-box.min.z, pZF=box.max.z-wp2.z;
                        const minP=Math.min(pXL,pXR,pZN,pZF);
                        if(minP===pXL)wp2.x=box.min.x-NPC_R;else if(minP===pXR)wp2.x=box.max.x+NPC_R;
                        else if(minP===pZN)wp2.z=box.min.z-NPC_R;else wp2.z=box.max.z+NPC_R;
                    }
                }
                // Clamp to world bounds
                npcGuide.position.x=THREE.MathUtils.clamp(npcGuide.position.x,-70,70);
                npcGuide.position.z=THREE.MathUtils.clamp(npcGuide.position.z,-65,70);
                npcD.baseY=Math.max(terrainHeight(npcGuide.position.x,npcGuide.position.z),ROAD_Y);
                npcGuide.position.y=npcD.baseY+Math.sin(t*3)*.03;
                npcGuide.rotation.y=Math.atan2(nx,-nz);
                // ‚îÄ‚îÄ Stuck detection ‚Äî skip waypoint if no progress ‚îÄ‚îÄ
                const movedDist=Math.sqrt((npcGuide.position.x-prevX)**2+(npcGuide.position.z-prevZ)**2);
                if(movedDist<spd*0.1){
                    npcD.stuckTimer=(npcD.stuckTimer||0)+dt;
                    if(npcD.stuckTimer>2){
                        npcD.wpIdx=(npcD.wpIdx+1)%_wizWaypoints.length;
                        npcD.stuckTimer=0;
                    }
                }else{npcD.stuckTimer=0;}
            }
        }
    }
    } // end wizardDead else
    // Quest icon pulse ‚Äî large, no circle bg, bold text
    if(!state.wizardDead){
        const iconS=1.6+Math.sin(t*3)*.25;
        npcD.iconGroup.children.forEach(sp=>{if(sp.visible)sp.scale.set(iconS,iconS,1);});
        npcD.iconGroup.rotation.y=t*.5;
    }else{npcD.iconGroup.visible=false;}
    // NPC speech bubble
    updateSpeechBubble(t,dt);
    // Camera shake from crashes
    if(_camShake>.01){
        camera.position.x+=(Math.random()-.5)*_camShake*.35;
        camera.position.y+=(Math.random()-.5)*_camShake*.2;
        camera.position.z+=(Math.random()-.5)*_camShake*.35;
        _camShake*=.85;
    }
    // Season cycle
    const si3=Math.floor(t/50)%4;if(si3!==state.seasonIndex){state.seasonIndex=si3;applySeason();}seasonEl.textContent=["Spring","Summer","Autumn","Winter"][si3];
    // Sun, water, windmill, NPC cars, leaves
    const so=t*.04;sun.position.set(Math.cos(so)*100,80+Math.sin(so*.6)*20,Math.sin(so)*60);sunSphere.position.copy(sun.position.clone().setLength(170));
    waterMat.uniforms.uTime.value=t;bladeGroup.rotation.z+=dt*.5;
    if(window._npcTick)window._npcTick(t,dt);
    // Cam position for proximity checks
    const cpRef=state.mode==="driving"?car.position:avatar.position;
    for(let i=0;i<LEAF_N;i++){const i3=i*3;leafPos[i3]+=(Math.sin(t*.7+i*2.3)*.2+.03)*dt*12;leafPos[i3+1]-=(.6+Math.sin(t+i)*.15)*dt*2;leafPos[i3+2]+=Math.cos(t*.5+i*1.7)*.15*dt*12;if(leafPos[i3+1]<0){leafPos[i3+1]=22+Math.random()*12;leafPos[i3]=cpRef.x+(Math.random()-.5)*100;leafPos[i3+2]=cpRef.z+(Math.random()-.5)*100;}}leafGeo.attributes.position.needsUpdate=true;
    // Hologram ambient animations (skip on mobile to save CPU)
    if(!IS_MOBILE){billboards.forEach(b=>{
        if(!b.group.visible)return;
        if(b.displayType==="hologram"){
            b.group.traverse(ch=>{
                if(ch.userData._holoFloat){ch.position.y=3.2+Math.sin(t*1.5+b.group.position.x)*.15;}
            });
        }
    });}
    // GIF textures (5fps on mobile, 10fps on desktop)
    const gf=Math.floor(t*(IS_MOBILE?5:10));
    if(gf!==tick._lg){tick._lg=gf;
        const parked2=state.canInteract; // play GIF in both driving and walking mode
        billboards.forEach(b=>{
            const gd=gifData[b.gifIdx];if(!gd.loaded||gd._failed)return;
            const d2=cpRef.distanceTo(b.group.position);
            const isParkedHere=parked2&&state.canInteract&&state.canInteract.t===b.project.t;
            if(isParkedHere){
                if(gd._dec&&gd._fCount>0&&!gd._busy){
                    gd._busy=true;
                    gd._dec.decode({frameIndex:gd._fIdx}).then(result=>{
                        const c=gd.ctx;
                        c.drawImage(result.image,0,0,_GIF_W,_GIF_H);
                        result.image.close();
                        const _gs=IS_MOBILE?.5:1;
                        c.fillStyle="rgba(0,0,0,.55)";c.fillRect(_GIF_W-88*_gs,6*_gs,80*_gs,26*_gs);
                        c.fillStyle="#ff3344";c.beginPath();c.arc(_GIF_W-74*_gs,19*_gs,5*_gs,0,Math.PI*2);c.fill();
                        c.fillStyle="#fff";c.font=`bold ${12*_gs}px Segoe UI`;c.fillText("LIVE",_GIF_W-62*_gs,24*_gs);
                        const gr=c.createLinearGradient(0,_GIF_H-56*_gs,0,_GIF_H);gr.addColorStop(0,"rgba(0,0,0,0)");gr.addColorStop(.4,"rgba(0,0,0,.75)");gr.addColorStop(1,"rgba(0,0,0,.9)");
                        c.fillStyle=gr;c.fillRect(0,_GIF_H-56*_gs,_GIF_W,56*_gs);
                        const di=DISTRICTS[b.project.district];
                        c.fillStyle=di.color;c.font=`600 ${11*_gs}px Segoe UI`;c.fillText(di.label.toUpperCase(),14*_gs,_GIF_H-31*_gs);
                        c.fillStyle="#fff";c.font=`700 ${16*_gs}px Segoe UI`;c.fillText(gd.title,14*_gs,_GIF_H-11*_gs);
                        c.fillStyle="#00ff88";c.font=`bold ${10*_gs}px Segoe UI`;c.fillText(IS_MOBILE?"TAP OPEN":"PRESS E TO OPEN",IS_MOBILE?_GIF_W-72*_gs:_GIF_W-122*_gs,_GIF_H-11*_gs);
                        gd.tex.needsUpdate=true;gd.playing=true;
                        gd._fIdx=(gd._fIdx+1)%gd._fCount;
                        gd._busy=false;
                    }).catch(()=>{gd._busy=false;gd._fIdx=0;});
                }else if(!gd._dec&&gd.img){
                    const c=gd.ctx;
                    c.drawImage(gd.img,0,0,_GIF_W,_GIF_H);
                    const _gs=IS_MOBILE?.5:1;
                    c.fillStyle="rgba(0,0,0,.55)";c.fillRect(_GIF_W-88*_gs,6*_gs,80*_gs,26*_gs);
                    c.fillStyle="#ff3344";c.beginPath();c.arc(_GIF_W-74*_gs,19*_gs,5*_gs,0,Math.PI*2);c.fill();
                    c.fillStyle="#fff";c.font=`bold ${12*_gs}px Segoe UI`;c.fillText("LIVE",_GIF_W-62*_gs,24*_gs);
                    const gr=c.createLinearGradient(0,_GIF_H-56*_gs,0,_GIF_H);gr.addColorStop(0,"rgba(0,0,0,0)");gr.addColorStop(.4,"rgba(0,0,0,.75)");gr.addColorStop(1,"rgba(0,0,0,.9)");
                    c.fillStyle=gr;c.fillRect(0,_GIF_H-56*_gs,_GIF_W,56*_gs);
                    const di=DISTRICTS[b.project.district];
                    c.fillStyle=di.color;c.font=`600 ${11*_gs}px Segoe UI`;c.fillText(di.label.toUpperCase(),14*_gs,_GIF_H-31*_gs);
                    c.fillStyle="#fff";c.font=`700 ${16*_gs}px Segoe UI`;c.fillText(gd.title,14*_gs,_GIF_H-11*_gs);
                    c.fillStyle="#00ff88";c.font=`bold ${10*_gs}px Segoe UI`;c.fillText(IS_MOBILE?"TAP OPEN":"PRESS E TO OPEN",IS_MOBILE?_GIF_W-72*_gs:_GIF_W-122*_gs,_GIF_H-11*_gs);
                    gd.tex.needsUpdate=true;gd.playing=true;
                }
            }else if(d2<(IS_MOBILE?30:55)){
                if(gd.playing||!gd._hasStatic){
                    const c=gd.ctx;const _gs=IS_MOBILE?.5:1;
                    if(gd.img&&gd.img.complete&&gd.img.naturalWidth>0)c.drawImage(gd.img,0,0,_GIF_W,_GIF_H);
                    else{c.fillStyle="#0a0a14";c.fillRect(0,0,_GIF_W,_GIF_H);}
                    c.fillStyle="rgba(0,0,10,.5)";c.fillRect(0,0,_GIF_W,_GIF_H);
                    const di=DISTRICTS[b.project.district];
                    c.fillStyle=di.color;c.font=`bold ${14*_gs}px Segoe UI`;c.fillText(di.label.toUpperCase(),20*_gs,30*_gs);
                    c.fillStyle="#fff";c.font=`bold ${22*_gs}px Segoe UI`;c.fillText(gd.title,20*_gs,65*_gs);
                    c.fillStyle="rgba(255,255,255,.5)";c.font=`${16*_gs}px Segoe UI`;c.fillText("\u25B6 Park to preview",20*_gs,100*_gs);
                    c.strokeStyle=di.color;c.lineWidth=IS_MOBILE?1:2;c.strokeRect(1,1,_GIF_W-2,_GIF_H-2);
                    gd.tex.needsUpdate=true;gd.playing=false;gd._hasStatic=true;
                }
            }
        });}
    grassMat.uniforms.uTime.value=t;
    grassMat.uniforms.uCarPos.value.copy(cpRef);
    grassMat.uniforms.uCarSpeed.value=state.mode==="driving"?state.speed:0;
    grassMat.uniforms.uCamPos.value.copy(camera.position);
    // Mobile UI contextual updates
    if(window._mobileUIUpdate)window._mobileUIUpdate();
    if(composer)composer.render();else renderer.render(scene,camera);
    }catch(e){console.error("Loop:",e);}
}
tick();
window.addEventListener("resize",()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);renderer.setPixelRatio(Math.min(devicePixelRatio,PERF.pixelRatioCap));if(composer)composer.setSize(innerWidth,innerHeight);});
</script>
</body>
</html>
